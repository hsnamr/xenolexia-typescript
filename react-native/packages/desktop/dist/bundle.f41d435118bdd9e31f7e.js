"use strict";(self.webpackChunkxenolexia_desktop=self.webpackChunkxenolexia_desktop||[]).push([[300],{1103(module){eval("{\n\nmodule.exports = value => {\n\tif (Object.prototype.toString.call(value) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEwMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly94ZW5vbGV4aWEtZGVza3RvcC8uLi8uLi9ub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqL2luZGV4LmpzPzIzY2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbHVlID0+IHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Y29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcblx0cmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1103\n\n}")},4300(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  BookParserService: () => (/* reexport */ BookParserService/* BookParserService */.s),\n  ChapterContentService: () => (/* reexport */ ChapterContentService/* ChapterContentService */.W),\n  EPUBExtractor: () => (/* reexport */ EPUBExtractor/* EPUBExtractor */.D),\n  EPUBParser: () => (/* reexport */ EPUBParser/* EPUBParser */.g),\n  FB2Parser: () => (/* reexport */ FB2Parser/* FB2Parser */.O),\n  MOBIParser: () => (/* reexport */ MOBIParser/* MOBIParser */.L),\n  MetadataExtractor: () => (/* reexport */ MetadataExtractor),\n  TXTParser: () => (/* reexport */ TXTParser/* TXTParser */.Y),\n  TextProcessingService: () => (/* reexport */ TextProcessingService),\n  chapterContentService: () => (/* reexport */ ChapterContentService/* chapterContentService */.I),\n  countTOCItems: () => (/* reexport */ TOCParser/* countTOCItems */.g6),\n  extractEPUBCover: () => (/* reexport */ extractEPUBCover),\n  extractEPUBInfo: () => (/* reexport */ extractEPUBInfo),\n  extractEPUBMetadata: () => (/* reexport */ extractEPUBMetadata),\n  findTOCItemByHref: () => (/* reexport */ TOCParser/* findTOCItemByHref */.XC),\n  flattenTOC: () => (/* reexport */ TOCParser/* flattenTOC */.Hd),\n  parseNAV: () => (/* reexport */ TOCParser/* parseNAV */.LH),\n  parseNCX: () => (/* reexport */ TOCParser/* parseNCX */.rD),\n  textProcessingService: () => (/* reexport */ textProcessingService)\n});\n\n// EXTERNAL MODULE: ../shared/src/services/BookParser/BookParserService.ts\nvar BookParserService = __webpack_require__(9648);\n// EXTERNAL MODULE: ../shared/src/services/BookParser/EPUBParser.ts\nvar EPUBParser = __webpack_require__(2888);\n// EXTERNAL MODULE: ../shared/src/services/BookParser/TXTParser.ts\nvar TXTParser = __webpack_require__(9790);\n// EXTERNAL MODULE: ../shared/src/services/BookParser/FB2Parser.ts\nvar FB2Parser = __webpack_require__(9904);\n// EXTERNAL MODULE: ../shared/src/services/BookParser/MOBIParser.ts + 3 modules\nvar MOBIParser = __webpack_require__(7429);\n// EXTERNAL MODULE: ../shared/src/services/BookParser/ChapterContentService.ts\nvar ChapterContentService = __webpack_require__(4120);\n// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 3 modules\nvar slicedToArray = __webpack_require__(2061);\n// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\nvar asyncToGenerator = __webpack_require__(6330);\n// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js\nvar classCallCheck = __webpack_require__(5152);\n// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/createClass.js\nvar createClass = __webpack_require__(414);\n// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(4586);\n// EXTERNAL MODULE: ../../node_modules/@babel/runtime/regenerator/index.js\nvar regenerator = __webpack_require__(5799);\nvar regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);\n// EXTERNAL MODULE: ../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 3 modules\nvar toConsumableArray = __webpack_require__(4619);\n;// ../shared/src/services/TranslationEngine/Tokenizer.ts\n\n\n\n\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n/**\n * Tokenizer - Extracts words from HTML while preserving structure\n *\n * Features:\n * - Preserves HTML tags and structure\n * - Handles punctuation attached to words\n * - Identifies word boundaries correctly\n * - Supports Unicode characters for non-Latin scripts\n * - Skips content that shouldn\'t be translated (code, scripts, styles)\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/** Tags whose content should not be processed */\nvar SKIP_TAGS = new Set([\'script\', \'style\', \'code\', \'pre\', \'kbd\', \'samp\', \'var\', \'noscript\', \'svg\', \'math\']);\n\n/** Common English contractions to handle */\nvar CONTRACTIONS = new Set(["n\'t", "\'s", "\'re", "\'ve", "\'ll", "\'d", "\'m"]);\n\n/** Common proper name prefixes */\nvar NAME_PREFIXES = new Set([\'mr\', \'mrs\', \'ms\', \'dr\', \'prof\', \'sir\', \'lord\', \'lady\']);\n\n/** Common abbreviations that shouldn\'t be translated */\nvar ABBREVIATIONS = new Set([\'etc\', \'eg\', \'ie\', \'vs\', \'mr\', \'mrs\', \'ms\', \'dr\', \'jr\', \'sr\', \'inc\', \'ltd\', \'co\', \'corp\']);\n\n// ============================================================================\n// Tokenizer Class\n// ============================================================================\n\nvar Tokenizer = /*#__PURE__*/function () {\n  function Tokenizer() {\n    var _options$skipQuotes, _options$skipNames, _options$skipCode, _options$minWordLengt, _options$maxWordLengt, _options$skipWords;\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0,classCallCheck/* default */.A)(this, Tokenizer);\n    this.options = {\n      skipQuotes: (_options$skipQuotes = options.skipQuotes) !== null && _options$skipQuotes !== void 0 ? _options$skipQuotes : true,\n      skipNames: (_options$skipNames = options.skipNames) !== null && _options$skipNames !== void 0 ? _options$skipNames : true,\n      skipCode: (_options$skipCode = options.skipCode) !== null && _options$skipCode !== void 0 ? _options$skipCode : true,\n      minWordLength: (_options$minWordLengt = options.minWordLength) !== null && _options$minWordLengt !== void 0 ? _options$minWordLengt : 2,\n      maxWordLength: (_options$maxWordLengt = options.maxWordLength) !== null && _options$maxWordLengt !== void 0 ? _options$maxWordLengt : 30,\n      skipWords: (_options$skipWords = options.skipWords) !== null && _options$skipWords !== void 0 ? _options$skipWords : new Set()\n    };\n  }\n\n  /**\n   * Tokenize HTML content into words while preserving structure\n   */\n  return (0,createClass/* default */.A)(Tokenizer, [{\n    key: "tokenize",\n    value: function tokenize(html) {\n      var segments = this.extractTextSegments(html);\n      var tokens = [];\n      var _iterator = _createForOfIteratorHelper(segments),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var segment = _step.value;\n          if (segment.isProtected && this.shouldSkipProtected(segment.protectionType)) {\n            continue;\n          }\n          var segmentTokens = this.tokenizeSegment(segment);\n          tokens.push.apply(tokens, (0,toConsumableArray/* default */.A)(segmentTokens));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return tokens;\n    }\n\n    /**\n     * Extract text segments from HTML, marking protected regions\n     */\n  }, {\n    key: "extractTextSegments",\n    value: function extractTextSegments(html) {\n      var segments = [];\n      var currentIndex = 0;\n      var insideSkipTag = false;\n      var skipTagName = \'\';\n      var quoteDepth = 0;\n\n      // Regex to match HTML tags\n      var tagRegex = /<\\/?([a-zA-Z][a-zA-Z0-9]*)[^>]*>/g;\n      var match;\n      while ((match = tagRegex.exec(html)) !== null) {\n        var tagStart = match.index;\n        var tagEnd = match.index + match[0].length;\n        var tagName = match[1].toLowerCase();\n        var isClosing = match[0].startsWith(\'</\');\n\n        // Extract text before this tag\n        if (tagStart > currentIndex) {\n          var text = html.substring(currentIndex, tagStart);\n          if (text.trim()) {\n            segments.push({\n              text: text,\n              startIndex: currentIndex,\n              endIndex: tagStart,\n              isProtected: insideSkipTag || quoteDepth > 0,\n              protectionType: insideSkipTag ? skipTagName === \'code\' || skipTagName === \'pre\' ? \'code\' : \'script\' : quoteDepth > 0 ? \'quote\' : undefined\n            });\n          }\n        }\n\n        // Track skip tags\n        if (SKIP_TAGS.has(tagName)) {\n          if (!isClosing) {\n            insideSkipTag = true;\n            skipTagName = tagName;\n          } else if (tagName === skipTagName) {\n            insideSkipTag = false;\n            skipTagName = \'\';\n          }\n        }\n        currentIndex = tagEnd;\n      }\n\n      // Handle remaining text after last tag\n      if (currentIndex < html.length) {\n        var _text = html.substring(currentIndex);\n        if (_text.trim()) {\n          segments.push({\n            text: _text,\n            startIndex: currentIndex,\n            endIndex: html.length,\n            isProtected: insideSkipTag,\n            protectionType: insideSkipTag ? \'script\' : undefined\n          });\n        }\n      }\n      return segments;\n    }\n\n    /**\n     * Tokenize a single text segment into words\n     */\n  }, {\n    key: "tokenizeSegment",\n    value: function tokenizeSegment(segment) {\n      var tokens = [];\n      var text = segment.text;\n\n      // Word pattern: supports Latin and common Unicode letters\n      // Handles contractions and hyphenated words\n      var wordPattern = /([^\\w\\u00C0-\\u024F\\u1E00-\\u1EFF]*)([\\w\\u00C0-\\u024F\\u1E00-\\u1EFF]+(?:[\'\'][\\w\\u00C0-\\u024F\\u1E00-\\u1EFF]+)?(?:-[\\w\\u00C0-\\u024F\\u1E00-\\u1EFF]+)*)([^\\w\\u00C0-\\u024F\\u1E00-\\u1EFF]*)/g;\n      var match;\n      var inQuote = false;\n      var lastQuoteChar = \'\';\n      while ((match = wordPattern.exec(text)) !== null) {\n        var _match = match,\n          _match2 = (0,slicedToArray/* default */.A)(_match, 4),\n          prefix = _match2[1],\n          word = _match2[2],\n          suffix = _match2[3];\n        var startInSegment = match.index + prefix.length;\n        var endInSegment = startInSegment + word.length;\n\n        // Track quotes in prefix\n        var _iterator2 = _createForOfIteratorHelper(prefix),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var char = _step2.value;\n            if (char === \'"\' || char === "\\u201C" || char === "\\u201D" || char === "\'" || char === "\\u2018" || char === "\\u2019") {\n              if (!inQuote) {\n                inQuote = true;\n                lastQuoteChar = char;\n              } else if (this.isMatchingQuote(lastQuoteChar, char)) {\n                inQuote = false;\n              }\n            }\n          }\n\n          // Determine if word is protected\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        var isProtected = segment.isProtected || inQuote && this.options.skipQuotes;\n        var protectionType = segment.protectionType;\n\n        // Check for proper names (capitalized words not at sentence start)\n        if (this.options.skipNames && this.looksLikeName(word, prefix, text, startInSegment)) {\n          isProtected = true;\n          protectionType = \'name\';\n        }\n\n        // Check for abbreviations\n        var normalized = word.toLowerCase().replace(/\\./g, \'\');\n        if (ABBREVIATIONS.has(normalized)) {\n          isProtected = true;\n          protectionType = \'name\';\n        }\n\n        // Skip if word doesn\'t meet length requirements\n        if (word.length < this.options.minWordLength || word.length > this.options.maxWordLength) {\n          continue;\n        }\n\n        // Skip if in custom skip list\n        if (this.options.skipWords.has(normalized)) {\n          continue;\n        }\n        tokens.push({\n          word: normalized,\n          original: word,\n          startIndex: segment.startIndex + startInSegment,\n          endIndex: segment.startIndex + endInSegment,\n          prefix: prefix,\n          suffix: suffix,\n          isProtected: isProtected,\n          protectionType: protectionType\n        });\n\n        // Track quotes in suffix\n        var _iterator3 = _createForOfIteratorHelper(suffix),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _char = _step3.value;\n            if (_char === \'"\' || _char === "\\u201C" || _char === "\\u201D" || _char === "\'" || _char === "\\u2018" || _char === "\\u2019") {\n              if (inQuote && this.isMatchingQuote(lastQuoteChar, _char)) {\n                inQuote = false;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      return tokens;\n    }\n\n    /**\n     * Check if a word looks like a proper name\n     */\n  }, {\n    key: "looksLikeName",\n    value: function looksLikeName(word, prefix, fullText, positionInText) {\n      // Must start with capital letter\n      if (!/^[A-Z]/.test(word)) {\n        return false;\n      }\n\n      // Check if it\'s at the start of a sentence\n      var trimmedPrefix = prefix.trimEnd();\n      if (positionInText === 0 || trimmedPrefix.endsWith(\'.\') || trimmedPrefix.endsWith(\'!\') || trimmedPrefix.endsWith(\'?\') || trimmedPrefix.endsWith(\':\')) {\n        // Could be sentence start, not necessarily a name\n        // But if ALL CAPS or has internal capitals, likely a name\n        if (word === word.toUpperCase() || /[A-Z]/.test(word.slice(1))) {\n          return true;\n        }\n        return false;\n      }\n\n      // Check for name prefixes (Mr., Dr., etc.)\n      var prevWord = this.getPreviousWord(fullText, positionInText);\n      if (prevWord && NAME_PREFIXES.has(prevWord.toLowerCase().replace(\'.\', \'\'))) {\n        return true;\n      }\n\n      // Mid-sentence capitalization is likely a name\n      return true;\n    }\n\n    /**\n     * Get the previous word in the text\n     */\n  }, {\n    key: "getPreviousWord",\n    value: function getPreviousWord(text, position) {\n      var before = text.substring(0, position).trimEnd();\n      var match = before.match(/(\\w+\\.?)$/);\n      return match ? match[1] : null;\n    }\n\n    /**\n     * Check if two quote characters match\n     */\n  }, {\n    key: "isMatchingQuote",\n    value: function isMatchingQuote(open, close) {\n      var pairs = {\n        \'"\': \'"\',\n        "\\u201C": "\\u201D",\n        "\'": "\'",\n        "\\u2018": "\\u2019"\n      };\n      return pairs[open] === close || open === close;\n    }\n\n    /**\n     * Check if we should skip protected content\n     */\n  }, {\n    key: "shouldSkipProtected",\n    value: function shouldSkipProtected(type) {\n      switch (type) {\n        case \'code\':\n        case \'script\':\n        case \'style\':\n          return this.options.skipCode;\n        case \'quote\':\n          return this.options.skipQuotes;\n        case \'name\':\n          return this.options.skipNames;\n        default:\n          return false;\n      }\n    }\n\n    /**\n     * Update tokenizer options\n     */\n  }, {\n    key: "updateOptions",\n    value: function updateOptions(options) {\n      this.options = _objectSpread(_objectSpread({}, this.options), options);\n    }\n\n    /**\n     * Get unique words from tokens\n     */\n  }], [{\n    key: "getUniqueWords",\n    value: function getUniqueWords(tokens) {\n      var words = new Set();\n      var _iterator4 = _createForOfIteratorHelper(tokens),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var token = _step4.value;\n          if (!token.isProtected) {\n            words.add(token.word);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return Array.from(words);\n    }\n  }]);\n}();\n\n// Export singleton with default options\nvar tokenizer = new Tokenizer();\n;// ../shared/src/services/TranslationEngine/WordReplacer.ts\n\n\n\n\nfunction WordReplacer_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction WordReplacer_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? WordReplacer_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : WordReplacer_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction WordReplacer_createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = WordReplacer_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\nfunction WordReplacer_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return WordReplacer_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? WordReplacer_arrayLikeToArray(r, a) : void 0; } }\nfunction WordReplacer_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n/**\n * Word Replacer - Handles word replacement logic with context awareness\n *\n * Features:\n * - Respects word density settings\n * - Preserves original case\n * - Creates properly formatted foreign word markers\n * - Handles replacement in HTML without breaking structure\n * - Supports configurable replacement strategies\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nvar PROFICIENCY_ORDER = [\'beginner\', \'intermediate\', \'advanced\'];\n\n// ============================================================================\n// Word Replacer Class\n// ============================================================================\n\nvar WordReplacer = /*#__PURE__*/function () {\n  function WordReplacer() {\n    var _options$density, _options$maxProficien, _options$preferredPar, _options$excludeWords, _options$minWordSpaci, _options$selectionStr;\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0,classCallCheck/* default */.A)(this, WordReplacer);\n    this.options = {\n      density: (_options$density = options.density) !== null && _options$density !== void 0 ? _options$density : 0.15,\n      maxProficiency: (_options$maxProficien = options.maxProficiency) !== null && _options$maxProficien !== void 0 ? _options$maxProficien : \'beginner\',\n      preferredPartsOfSpeech: (_options$preferredPar = options.preferredPartsOfSpeech) !== null && _options$preferredPar !== void 0 ? _options$preferredPar : [],\n      excludeWords: (_options$excludeWords = options.excludeWords) !== null && _options$excludeWords !== void 0 ? _options$excludeWords : new Set(),\n      minWordSpacing: (_options$minWordSpaci = options.minWordSpacing) !== null && _options$minWordSpaci !== void 0 ? _options$minWordSpaci : 3,\n      selectionStrategy: (_options$selectionStr = options.selectionStrategy) !== null && _options$selectionStr !== void 0 ? _options$selectionStr : \'distributed\'\n    };\n  }\n\n  /**\n   * Replace words in HTML content with foreign equivalents\n   */\n  return (0,createClass/* default */.A)(WordReplacer, [{\n    key: "replace",\n    value: function replace(html, tokens, wordEntries) {\n      // Build list of replacement candidates\n      var candidates = this.buildCandidates(tokens, wordEntries);\n\n      // Select which words to replace based on density and strategy\n      var selected = this.selectReplacements(candidates, tokens.length);\n\n      // Sort by position descending to replace from end to start\n      // This prevents position shifts from affecting subsequent replacements\n      selected.sort(function (a, b) {\n        return b.token.startIndex - a.token.startIndex;\n      });\n\n      // Perform replacements\n      var modifiedHtml = html;\n      var foreignWords = [];\n      var offset = 0;\n      var _iterator = WordReplacer_createForOfIteratorHelper(selected),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var candidate = _step.value;\n          var token = candidate.token,\n            entry = candidate.entry;\n\n          // Preserve original case\n          var foreignWord = this.preserveCase(token.original, entry.targetWord);\n\n          // Create the foreign word marker HTML\n          var marker = this.createMarker(foreignWord, entry, token);\n\n          // Calculate positions\n          var start = token.startIndex;\n          var end = token.endIndex;\n\n          // Replace in HTML\n          modifiedHtml = modifiedHtml.substring(0, start) + marker + modifiedHtml.substring(end);\n\n          // Track foreign word data\n          foreignWords.push({\n            originalWord: token.original,\n            foreignWord: foreignWord,\n            startIndex: start,\n            endIndex: start + marker.length,\n            wordEntry: entry\n          });\n        }\n\n        // Reverse foreignWords to maintain original order\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      foreignWords.reverse();\n      var stats = {\n        totalTokens: tokens.length,\n        eligibleTokens: candidates.length,\n        replacedTokens: selected.length,\n        protectedTokens: tokens.filter(function (t) {\n          return t.isProtected;\n        }).length,\n        densitySkipped: candidates.length - selected.length\n      };\n      return {\n        html: modifiedHtml,\n        foreignWords: foreignWords,\n        stats: stats\n      };\n    }\n\n    /**\n     * Build list of replacement candidates from tokens\n     */\n  }, {\n    key: "buildCandidates",\n    value: function buildCandidates(tokens, wordEntries) {\n      var candidates = [];\n      var _iterator2 = WordReplacer_createForOfIteratorHelper(tokens),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var token = _step2.value;\n          // Skip protected tokens\n          if (token.isProtected) {\n            continue;\n          }\n\n          // Skip excluded words\n          if (this.options.excludeWords.has(token.word)) {\n            continue;\n          }\n\n          // Get word entry\n          var entry = wordEntries.get(token.word);\n          if (!entry) {\n            continue;\n          }\n\n          // Check proficiency level\n          if (!this.isWithinProficiency(entry.proficiencyLevel)) {\n            continue;\n          }\n\n          // Calculate replacement score\n          var score = this.calculateScore(token, entry);\n          candidates.push({\n            token: token,\n            entry: entry,\n            score: score\n          });\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return candidates;\n    }\n\n    /**\n     * Select which candidates to replace based on density and strategy\n     */\n  }, {\n    key: "selectReplacements",\n    value: function selectReplacements(candidates, totalTokens) {\n      if (candidates.length === 0) {\n        return [];\n      }\n\n      // Calculate target count based on density\n      var targetCount = Math.max(1, Math.floor(totalTokens * this.options.density));\n      switch (this.options.selectionStrategy) {\n        case \'frequency\':\n          return this.selectByFrequency(candidates, targetCount);\n        case \'distributed\':\n          return this.selectDistributed(candidates, targetCount);\n        case \'random\':\n        default:\n          return this.selectRandom(candidates, targetCount);\n      }\n    }\n\n    /**\n     * Select words randomly\n     */\n  }, {\n    key: "selectRandom",\n    value: function selectRandom(candidates, targetCount) {\n      var shuffled = (0,toConsumableArray/* default */.A)(candidates).sort(function () {\n        return Math.random() - 0.5;\n      });\n      return this.applySpacingConstraint(shuffled, targetCount);\n    }\n\n    /**\n     * Select words by frequency (prefer more common words)\n     */\n  }, {\n    key: "selectByFrequency",\n    value: function selectByFrequency(candidates, targetCount) {\n      // Sort by frequency rank (lower = more common)\n      var sorted = (0,toConsumableArray/* default */.A)(candidates).sort(function (a, b) {\n        return a.entry.frequencyRank - b.entry.frequencyRank;\n      });\n      return this.applySpacingConstraint(sorted, targetCount);\n    }\n\n    /**\n     * Select words distributed evenly throughout the text\n     */\n  }, {\n    key: "selectDistributed",\n    value: function selectDistributed(candidates, targetCount) {\n      if (candidates.length <= targetCount) {\n        return this.applySpacingConstraint(candidates, targetCount);\n      }\n\n      // Sort by position\n      var sorted = (0,toConsumableArray/* default */.A)(candidates).sort(function (a, b) {\n        return a.token.startIndex - b.token.startIndex;\n      });\n\n      // Select evenly distributed indices\n      var step = sorted.length / targetCount;\n      var selected = [];\n      for (var i = 0; i < targetCount; i++) {\n        var index = Math.floor(i * step + Math.random() * step * 0.5);\n        if (index < sorted.length) {\n          selected.push(sorted[index]);\n        }\n      }\n      return this.applySpacingConstraint(selected, targetCount);\n    }\n\n    /**\n     * Apply minimum word spacing constraint\n     */\n  }, {\n    key: "applySpacingConstraint",\n    value: function applySpacingConstraint(candidates, maxCount) {\n      if (this.options.minWordSpacing <= 0) {\n        return candidates.slice(0, maxCount);\n      }\n\n      // Sort by position\n      var sorted = (0,toConsumableArray/* default */.A)(candidates).sort(function (a, b) {\n        return a.token.startIndex - b.token.startIndex;\n      });\n      var selected = [];\n      var lastPosition = -Infinity;\n      var _iterator3 = WordReplacer_createForOfIteratorHelper(sorted),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var candidate = _step3.value;\n          if (selected.length >= maxCount) {\n            break;\n          }\n\n          // Check spacing from last selected word\n          // Use a rough estimate of word positions\n          var wordsBetween = Math.floor((candidate.token.startIndex - lastPosition) / 6 // Rough average word length\n          );\n          if (wordsBetween >= this.options.minWordSpacing) {\n            selected.push(candidate);\n            lastPosition = candidate.token.endIndex;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return selected;\n    }\n\n    /**\n     * Calculate a score for replacement priority\n     */\n  }, {\n    key: "calculateScore",\n    value: function calculateScore(token, entry) {\n      var score = 100;\n\n      // Prefer lower frequency rank (more common words)\n      score -= Math.min(50, entry.frequencyRank / 100);\n\n      // Prefer certain parts of speech\n      if (this.options.preferredPartsOfSpeech.length > 0 && this.options.preferredPartsOfSpeech.includes(entry.partOfSpeech)) {\n        score += 20;\n      }\n\n      // Prefer words that are not at sentence boundaries\n      if (!token.prefix.match(/[.!?]\\s*$/)) {\n        score += 10;\n      }\n\n      // Prefer shorter words (easier to understand from context)\n      if (token.word.length <= 6) {\n        score += 5;\n      }\n      return score;\n    }\n\n    /**\n     * Check if proficiency level is within max allowed\n     */\n  }, {\n    key: "isWithinProficiency",\n    value: function isWithinProficiency(level) {\n      var maxIndex = PROFICIENCY_ORDER.indexOf(this.options.maxProficiency);\n      var levelIndex = PROFICIENCY_ORDER.indexOf(level);\n      return levelIndex <= maxIndex;\n    }\n\n    /**\n     * Preserve the original word\'s case pattern\n     */\n  }, {\n    key: "preserveCase",\n    value: function preserveCase(original, replacement) {\n      if (!original || !replacement) {\n        return replacement;\n      }\n\n      // All uppercase\n      if (original === original.toUpperCase() && original.length > 1) {\n        return replacement.toUpperCase();\n      }\n\n      // Title case (first letter uppercase)\n      if (original[0] === original[0].toUpperCase() && original.slice(1) === original.slice(1).toLowerCase()) {\n        return replacement[0].toUpperCase() + replacement.slice(1).toLowerCase();\n      }\n\n      // All lowercase\n      return replacement.toLowerCase();\n    }\n\n    /**\n     * Create HTML marker for a foreign word\n     */\n  }, {\n    key: "createMarker",\n    value: function createMarker(foreignWord, entry, token) {\n      var attrs = ["class=\\"foreign-word\\"", "data-original=\\"".concat(this.escapeHtml(entry.sourceWord), "\\""), "data-word-id=\\"".concat(this.escapeHtml(entry.id), "\\""), "data-pos=\\"".concat(this.escapeHtml(entry.partOfSpeech), "\\"")];\n      if (entry.pronunciation) {\n        attrs.push("data-pronunciation=\\"".concat(this.escapeHtml(entry.pronunciation), "\\""));\n      }\n      return "<span ".concat(attrs.join(\' \'), ">").concat(this.escapeHtml(foreignWord), "</span>");\n    }\n\n    /**\n     * Escape HTML special characters\n     */\n  }, {\n    key: "escapeHtml",\n    value: function escapeHtml(text) {\n      return text.replace(/&/g, \'&amp;\').replace(/</g, \'&lt;\').replace(/>/g, \'&gt;\').replace(/"/g, \'&quot;\').replace(/\'/g, \'&#039;\');\n    }\n\n    /**\n     * Update replacer options\n     */\n  }, {\n    key: "updateOptions",\n    value: function updateOptions(options) {\n      this.options = WordReplacer_objectSpread(WordReplacer_objectSpread({}, this.options), options);\n    }\n\n    /**\n     * Get current options\n     */\n  }, {\n    key: "getOptions",\n    value: function getOptions() {\n      return WordReplacer_objectSpread({}, this.options);\n    }\n  }]);\n}();\n\n// Export factory function\nfunction createWordReplacer(options) {\n  return new WordReplacer(options);\n}\n;// ../shared/src/services/StorageService/DatabaseSchema.ts\n/**\n * Database Schema - SQL definitions for SQLite database\n */\n\nvar DatabaseSchema = {\n  /**\n   * Create all tables\n   */\n  createTables: "\\n    -- Books table\\n    CREATE TABLE IF NOT EXISTS books (\\n      id TEXT PRIMARY KEY,\\n      title TEXT NOT NULL,\\n      author TEXT,\\n      cover_path TEXT,\\n      file_path TEXT NOT NULL,\\n      format TEXT NOT NULL,\\n      added_at INTEGER NOT NULL,\\n      last_read_at INTEGER,\\n      progress REAL DEFAULT 0,\\n      current_location TEXT,\\n      source_lang TEXT NOT NULL,\\n      target_lang TEXT NOT NULL,\\n      proficiency TEXT NOT NULL,\\n      density REAL DEFAULT 0.3\\n    );\\n\\n    -- Vocabulary table\\n    CREATE TABLE IF NOT EXISTS vocabulary (\\n      id TEXT PRIMARY KEY,\\n      source_word TEXT NOT NULL,\\n      target_word TEXT NOT NULL,\\n      source_lang TEXT NOT NULL,\\n      target_lang TEXT NOT NULL,\\n      context_sentence TEXT,\\n      book_id TEXT,\\n      added_at INTEGER NOT NULL,\\n      last_reviewed_at INTEGER,\\n      review_count INTEGER DEFAULT 0,\\n      ease_factor REAL DEFAULT 2.5,\\n      interval INTEGER DEFAULT 0,\\n      status TEXT DEFAULT \'new\',\\n      FOREIGN KEY (book_id) REFERENCES books(id) ON DELETE SET NULL\\n    );\\n\\n    -- Reading sessions table\\n    CREATE TABLE IF NOT EXISTS reading_sessions (\\n      id TEXT PRIMARY KEY,\\n      book_id TEXT NOT NULL,\\n      started_at INTEGER NOT NULL,\\n      ended_at INTEGER,\\n      pages_read INTEGER DEFAULT 0,\\n      words_revealed INTEGER DEFAULT 0,\\n      words_saved INTEGER DEFAULT 0,\\n      FOREIGN KEY (book_id) REFERENCES books(id) ON DELETE CASCADE\\n    );\\n\\n    -- User preferences table\\n    CREATE TABLE IF NOT EXISTS preferences (\\n      key TEXT PRIMARY KEY,\\n      value TEXT NOT NULL\\n    );\\n\\n    -- Word list table (populated from bundled assets)\\n    CREATE TABLE IF NOT EXISTS word_list (\\n      id TEXT PRIMARY KEY,\\n      source_word TEXT NOT NULL,\\n      target_word TEXT NOT NULL,\\n      source_lang TEXT NOT NULL,\\n      target_lang TEXT NOT NULL,\\n      proficiency TEXT NOT NULL,\\n      frequency_rank INTEGER,\\n      part_of_speech TEXT,\\n      variants TEXT,\\n      pronunciation TEXT\\n    );\\n\\n    -- Create indexes for faster queries\\n    CREATE INDEX IF NOT EXISTS idx_vocabulary_book ON vocabulary(book_id);\\n    CREATE INDEX IF NOT EXISTS idx_vocabulary_status ON vocabulary(status);\\n    CREATE INDEX IF NOT EXISTS idx_vocabulary_source ON vocabulary(source_word);\\n    CREATE INDEX IF NOT EXISTS idx_word_list_source ON word_list(source_word);\\n    CREATE INDEX IF NOT EXISTS idx_word_list_langs ON word_list(source_lang, target_lang);\\n    CREATE INDEX IF NOT EXISTS idx_word_list_proficiency ON word_list(proficiency);\\n    CREATE INDEX IF NOT EXISTS idx_reading_sessions_book ON reading_sessions(book_id);\\n  ",\n  /**\n   * Queries for books\n   */\n  books: {\n    insert: "\\n      INSERT INTO books (id, title, author, cover_path, file_path, format, added_at, source_lang, target_lang, proficiency, density)\\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\\n    ",\n    update: "\\n      UPDATE books SET\\n        title = COALESCE(?, title),\\n        author = COALESCE(?, author),\\n        cover_path = COALESCE(?, cover_path),\\n        last_read_at = COALESCE(?, last_read_at),\\n        progress = COALESCE(?, progress),\\n        current_location = COALESCE(?, current_location),\\n        proficiency = COALESCE(?, proficiency),\\n        density = COALESCE(?, density)\\n      WHERE id = ?\\n    ",\n    delete: \'DELETE FROM books WHERE id = ?\',\n    getById: \'SELECT * FROM books WHERE id = ?\',\n    getAll: \'SELECT * FROM books ORDER BY last_read_at DESC, added_at DESC\',\n    search: "\\n      SELECT * FROM books\\n      WHERE title LIKE ? OR author LIKE ?\\n      ORDER BY last_read_at DESC\\n    "\n  },\n  /**\n   * Queries for vocabulary\n   */\n  vocabulary: {\n    insert: "\\n      INSERT INTO vocabulary (id, source_word, target_word, source_lang, target_lang, context_sentence, book_id, added_at, status)\\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, \'new\')\\n    ",\n    update: "\\n      UPDATE vocabulary SET\\n        last_reviewed_at = COALESCE(?, last_reviewed_at),\\n        review_count = COALESCE(?, review_count),\\n        ease_factor = COALESCE(?, ease_factor),\\n        interval = COALESCE(?, interval),\\n        status = COALESCE(?, status)\\n      WHERE id = ?\\n    ",\n    delete: \'DELETE FROM vocabulary WHERE id = ?\',\n    getById: \'SELECT * FROM vocabulary WHERE id = ?\',\n    getAll: \'SELECT * FROM vocabulary ORDER BY added_at DESC\',\n    getByStatus: \'SELECT * FROM vocabulary WHERE status = ? ORDER BY added_at DESC\',\n    getByBook: \'SELECT * FROM vocabulary WHERE book_id = ? ORDER BY added_at DESC\',\n    getDueForReview: "\\n      SELECT * FROM vocabulary\\n      WHERE status != \'learned\'\\n      AND (last_reviewed_at IS NULL OR (last_reviewed_at + interval * 86400000) <= ?)\\n      ORDER BY last_reviewed_at ASC\\n    ",\n    search: "\\n      SELECT * FROM vocabulary\\n      WHERE source_word LIKE ? OR target_word LIKE ?\\n      ORDER BY added_at DESC\\n    "\n  },\n  /**\n   * Queries for reading sessions\n   */\n  sessions: {\n    insert: "\\n      INSERT INTO reading_sessions (id, book_id, started_at)\\n      VALUES (?, ?, ?)\\n    ",\n    end: "\\n      UPDATE reading_sessions SET\\n        ended_at = ?,\\n        pages_read = ?,\\n        words_revealed = ?,\\n        words_saved = ?\\n      WHERE id = ?\\n    ",\n    getByBook: \'SELECT * FROM reading_sessions WHERE book_id = ? ORDER BY started_at DESC\',\n    getRecent: \'SELECT * FROM reading_sessions ORDER BY started_at DESC LIMIT ?\',\n    getStats: "\\n      SELECT\\n        COUNT(DISTINCT book_id) as books_read,\\n        SUM(ended_at - started_at) as total_time,\\n        SUM(words_saved) as words_saved,\\n        AVG(ended_at - started_at) as avg_session\\n      FROM reading_sessions\\n      WHERE ended_at IS NOT NULL\\n    "\n  },\n  /**\n   * Queries for preferences\n   */\n  preferences: {\n    set: \'INSERT OR REPLACE INTO preferences (key, value) VALUES (?, ?)\',\n    get: \'SELECT value FROM preferences WHERE key = ?\',\n    getAll: \'SELECT * FROM preferences\',\n    delete: \'DELETE FROM preferences WHERE key = ?\'\n  },\n  /**\n   * Queries for word list\n   */\n  wordList: {\n    insert: "\\n      INSERT INTO word_list (id, source_word, target_word, source_lang, target_lang, proficiency, frequency_rank, part_of_speech, variants, pronunciation)\\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\\n    ",\n    getByWord: "\\n      SELECT * FROM word_list\\n      WHERE source_word = ? AND source_lang = ? AND target_lang = ?\\n    ",\n    getByLevel: "\\n      SELECT * FROM word_list\\n      WHERE source_lang = ? AND target_lang = ? AND proficiency = ?\\n      ORDER BY frequency_rank\\n    ",\n    count: "\\n      SELECT COUNT(*) as count FROM word_list\\n      WHERE source_lang = ? AND target_lang = ?\\n    "\n  }\n};\n// EXTERNAL MODULE: ../shared/src/services/StorageService/DatabaseService.ts + 1 modules\nvar DatabaseService = __webpack_require__(3286);\n// EXTERNAL MODULE: ../../node_modules/merge-options/index.js\nvar merge_options = __webpack_require__(5057);\n;// ../../node_modules/merge-options/index.mjs\n/**\n * Thin ESM wrapper for CJS named exports.\n *\n * Ref: https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1\n */\n\n\n/* harmony default export */ const node_modules_merge_options = (merge_options);\n\n;// ../../node_modules/@react-native-async-storage/async-storage/lib/module/AsyncStorage.js\n/**\n * Copyright (c) Nicolas Gallagher.\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n// eslint-disable-next-line @typescript-eslint/ban-types\n\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nconst merge = node_modules_merge_options.bind({\n  concatArrays: true,\n  ignoreUndefined: true\n});\nfunction mergeLocalStorageItem(key, value) {\n  const oldValue = window.localStorage.getItem(key);\n  if (oldValue) {\n    const oldObject = JSON.parse(oldValue);\n    const newObject = JSON.parse(value);\n    const nextValue = JSON.stringify(merge(oldObject, newObject));\n    window.localStorage.setItem(key, nextValue);\n  } else {\n    window.localStorage.setItem(key, value);\n  }\n}\nfunction createPromise(getValue, callback) {\n  return new Promise((resolve, reject) => {\n    try {\n      const value = getValue();\n      callback === null || callback === void 0 ? void 0 : callback(null, value);\n      resolve(value);\n    } catch (err) {\n      callback === null || callback === void 0 ? void 0 : callback(err);\n      reject(err);\n    }\n  });\n}\nfunction createPromiseAll(promises, callback, processResult) {\n  return Promise.all(promises).then(result => {\n    const value = (processResult === null || processResult === void 0 ? void 0 : processResult(result)) ?? null;\n    callback === null || callback === void 0 ? void 0 : callback(null, value);\n    return Promise.resolve(value);\n  }, errors => {\n    callback === null || callback === void 0 ? void 0 : callback(errors);\n    return Promise.reject(errors);\n  });\n}\nconst AsyncStorage_AsyncStorage = {\n  /**\n   * Fetches `key` value.\n   */\n  getItem: (key, callback) => {\n    return createPromise(() => window.localStorage.getItem(key), callback);\n  },\n  /**\n   * Sets `value` for `key`.\n   */\n  setItem: (key, value, callback) => {\n    return createPromise(() => window.localStorage.setItem(key, value), callback);\n  },\n  /**\n   * Removes a `key`\n   */\n  removeItem: (key, callback) => {\n    return createPromise(() => window.localStorage.removeItem(key), callback);\n  },\n  /**\n   * Merges existing value with input value, assuming they are stringified JSON.\n   */\n  mergeItem: (key, value, callback) => {\n    return createPromise(() => mergeLocalStorageItem(key, value), callback);\n  },\n  /**\n   * Erases *all* AsyncStorage for the domain.\n   */\n  clear: callback => {\n    return createPromise(() => window.localStorage.clear(), callback);\n  },\n  /**\n   * Gets *all* keys known to the app, for all callers, libraries, etc.\n   */\n  getAllKeys: callback => {\n    return createPromise(() => {\n      const numberOfKeys = window.localStorage.length;\n      const keys = [];\n      for (let i = 0; i < numberOfKeys; i += 1) {\n        const key = window.localStorage.key(i) || "";\n        keys.push(key);\n      }\n      return keys;\n    }, callback);\n  },\n  /**\n   * (stub) Flushes any pending requests using a single batch call to get the data.\n   */\n  flushGetRequests: () => undefined,\n  /**\n   * multiGet resolves to an array of key-value pair arrays that matches the\n   * input format of multiSet.\n   *\n   *   multiGet([\'k1\', \'k2\']) -> [[\'k1\', \'val1\'], [\'k2\', \'val2\']]\n   */\n  multiGet: (keys, callback) => {\n    const promises = keys.map(key => AsyncStorage_AsyncStorage.getItem(key));\n    const processResult = result => result.map((value, i) => [keys[i], value]);\n    return createPromiseAll(promises, callback, processResult);\n  },\n  /**\n   * Takes an array of key-value array pairs.\n   *   multiSet([[\'k1\', \'val1\'], [\'k2\', \'val2\']])\n   */\n  multiSet: (keyValuePairs, callback) => {\n    const promises = keyValuePairs.map(item => AsyncStorage_AsyncStorage.setItem(item[0], item[1]));\n    return createPromiseAll(promises, callback);\n  },\n  /**\n   * Delete all the keys in the `keys` array.\n   */\n  multiRemove: (keys, callback) => {\n    const promises = keys.map(key => AsyncStorage_AsyncStorage.removeItem(key));\n    return createPromiseAll(promises, callback);\n  },\n  /**\n   * Takes an array of key-value array pairs and merges them with existing\n   * values, assuming they are stringified JSON.\n   *\n   *   multiMerge([[\'k1\', \'val1\'], [\'k2\', \'val2\']])\n   */\n  multiMerge: (keyValuePairs, callback) => {\n    const promises = keyValuePairs.map(item => AsyncStorage_AsyncStorage.mergeItem(item[0], item[1]));\n    return createPromiseAll(promises, callback);\n  }\n};\n/* harmony default export */ const module_AsyncStorage = (AsyncStorage_AsyncStorage);\n//# sourceMappingURL=AsyncStorage.js.map\n;// ../../node_modules/@react-native-async-storage/async-storage/lib/module/hooks.js\n\nfunction useAsyncStorage(key) {\n  return {\n    getItem: (...args) => AsyncStorage.getItem(key, ...args),\n    setItem: (...args) => AsyncStorage.setItem(key, ...args),\n    mergeItem: (...args) => AsyncStorage.mergeItem(key, ...args),\n    removeItem: (...args) => AsyncStorage.removeItem(key, ...args)\n  };\n}\n//# sourceMappingURL=hooks.js.map\n;// ../../node_modules/@react-native-async-storage/async-storage/lib/module/index.js\n\n\n/* harmony default export */ const lib_module = (module_AsyncStorage);\n//# sourceMappingURL=index.js.map\n;// ../shared/src/services/TranslationEngine/FrequencyListService.ts\n\n\n\n\n\nfunction FrequencyListService_createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = FrequencyListService_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\nfunction FrequencyListService_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return FrequencyListService_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? FrequencyListService_arrayLikeToArray(r, a) : void 0; } }\nfunction FrequencyListService_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n\n/**\n * Frequency List Service - Manages frequency-ranked word lists\n *\n * Sources:\n * - Bundled: Core vocabulary for common language pairs\n * - Open source word frequency lists from various corpora\n * - User-generated vocabulary from reading\n *\n * Word frequency determines proficiency level:\n * - Beginner (A1-A2): Top 500 most frequent words\n * - Intermediate (B1-B2): Words 501-2000\n * - Advanced (C1-C2): Words 2001-5000+\n */\n\n\n\n// ============================================================================\n// Types\n// ============================================================================\n\n// ============================================================================\n// Open Source Frequency List Sources\n// ============================================================================\n\n/**\n * URLs to open frequency lists (various licenses, mostly CC/public domain)\n * These are word lists from linguistic research and open corpora\n */\nvar FREQUENCY_LIST_SOURCES = {\n  en: \'https://raw.githubusercontent.com/hermitdave/FrequencyWords/master/content/2018/en/en_50k.txt\',\n  es: \'https://raw.githubusercontent.com/hermitdave/FrequencyWords/master/content/2018/es/es_50k.txt\',\n  fr: \'https://raw.githubusercontent.com/hermitdave/FrequencyWords/master/content/2018/fr/fr_50k.txt\',\n  de: \'https://raw.githubusercontent.com/hermitdave/FrequencyWords/master/content/2018/de/de_50k.txt\',\n  it: \'https://raw.githubusercontent.com/hermitdave/FrequencyWords/master/content/2018/it/it_50k.txt\',\n  pt: \'https://raw.githubusercontent.com/hermitdave/FrequencyWords/master/content/2018/pt/pt_50k.txt\',\n  ru: \'https://raw.githubusercontent.com/hermitdave/FrequencyWords/master/content/2018/ru/ru_50k.txt\',\n  el: \'https://raw.githubusercontent.com/hermitdave/FrequencyWords/master/content/2018/el/el_50k.txt\',\n  ja: null,\n  // Japanese requires special handling\n  zh: null,\n  // Chinese requires special handling\n  ko: null,\n  // Korean requires special handling\n  ar: \'https://raw.githubusercontent.com/hermitdave/FrequencyWords/master/content/2018/ar/ar_50k.txt\'\n};\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nvar STORAGE_PREFIX = \'@xenolexia/frequency_\';\nvar MAX_WORDS_TO_STORE = 5000;\nvar PROFICIENCY_THRESHOLDS = {\n  beginner: {\n    min: 1,\n    max: 500\n  },\n  intermediate: {\n    min: 501,\n    max: 2000\n  },\n  advanced: {\n    min: 2001,\n    max: 5000\n  }\n};\n\n// ============================================================================\n// Frequency List Service\n// ============================================================================\n\nvar FrequencyListService = /*#__PURE__*/function () {\n  function FrequencyListService() {\n    (0,classCallCheck/* default */.A)(this, FrequencyListService);\n    (0,defineProperty/* default */.A)(this, "cache", new Map());\n  }\n  return (0,createClass/* default */.A)(FrequencyListService, [{\n    key: "getFrequencyList",\n    value: (\n    /**\n     * Get frequency list for a language\n     */\n    function () {\n      var _getFrequencyList = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee(language) {\n        var stored, fetched;\n        return regenerator_default().wrap(function (_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!this.cache.has(language)) {\n                _context.next = 1;\n                break;\n              }\n              return _context.abrupt("return", this.cache.get(language));\n            case 1:\n              _context.next = 2;\n              return this.loadFromStorage(language);\n            case 2:\n              stored = _context.sent;\n              if (!stored) {\n                _context.next = 3;\n                break;\n              }\n              this.cache.set(language, stored);\n              return _context.abrupt("return", stored);\n            case 3:\n              _context.next = 4;\n              return this.fetchFrequencyList(language);\n            case 4:\n              fetched = _context.sent;\n              if (!fetched) {\n                _context.next = 6;\n                break;\n              }\n              _context.next = 5;\n              return this.saveToStorage(language, fetched);\n            case 5:\n              this.cache.set(language, fetched);\n              return _context.abrupt("return", fetched);\n            case 6:\n              return _context.abrupt("return", null);\n            case 7:\n            case "end":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function getFrequencyList(_x) {\n        return _getFrequencyList.apply(this, arguments);\n      }\n      return getFrequencyList;\n    }()\n    /**\n     * Get words for a specific proficiency level\n     */\n    )\n  }, {\n    key: "getWordsByProficiency",\n    value: (function () {\n      var _getWordsByProficiency = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee2(language, level) {\n        var list, _PROFICIENCY_THRESHOL, min, max;\n        return regenerator_default().wrap(function (_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 1;\n              return this.getFrequencyList(language);\n            case 1:\n              list = _context2.sent;\n              if (list) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt("return", []);\n            case 2:\n              _PROFICIENCY_THRESHOL = PROFICIENCY_THRESHOLDS[level], min = _PROFICIENCY_THRESHOL.min, max = _PROFICIENCY_THRESHOL.max;\n              return _context2.abrupt("return", list.words.filter(function (w) {\n                return w.rank >= min && w.rank <= max;\n              }));\n            case 3:\n            case "end":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function getWordsByProficiency(_x2, _x3) {\n        return _getWordsByProficiency.apply(this, arguments);\n      }\n      return getWordsByProficiency;\n    }()\n    /**\n     * Get proficiency level for a word rank\n     */\n    )\n  }, {\n    key: "getProficiencyLevel",\n    value: function getProficiencyLevel(rank) {\n      if (rank <= PROFICIENCY_THRESHOLDS.beginner.max) return \'beginner\';\n      if (rank <= PROFICIENCY_THRESHOLDS.intermediate.max) return \'intermediate\';\n      return \'advanced\';\n    }\n\n    /**\n     * Check if a word is in the frequency list\n     */\n  }, {\n    key: "getWordRank",\n    value: (function () {\n      var _getWordRank = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee3(language, word) {\n        var list, normalizedWord, found;\n        return regenerator_default().wrap(function (_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 1;\n              return this.getFrequencyList(language);\n            case 1:\n              list = _context3.sent;\n              if (list) {\n                _context3.next = 2;\n                break;\n              }\n              return _context3.abrupt("return", null);\n            case 2:\n              normalizedWord = word.toLowerCase();\n              found = list.words.find(function (w) {\n                return w.word.toLowerCase() === normalizedWord;\n              });\n              return _context3.abrupt("return", (found === null || found === void 0 ? void 0 : found.rank) || null);\n            case 3:\n            case "end":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function getWordRank(_x4, _x5) {\n        return _getWordRank.apply(this, arguments);\n      }\n      return getWordRank;\n    }()\n    /**\n     * Get statistics about a frequency list\n     */\n    )\n  }, {\n    key: "getStats",\n    value: (function () {\n      var _getStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee4(language) {\n        var list, beginner, intermediate, advanced, _iterator, _step, word, level, _t, _t2;\n        return regenerator_default().wrap(function (_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 1;\n              return this.getFrequencyList(language);\n            case 1:\n              list = _context4.sent;\n              if (list) {\n                _context4.next = 2;\n                break;\n              }\n              return _context4.abrupt("return", null);\n            case 2:\n              beginner = 0;\n              intermediate = 0;\n              advanced = 0;\n              _iterator = FrequencyListService_createForOfIteratorHelper(list.words);\n              _context4.prev = 3;\n              _iterator.s();\n            case 4:\n              if ((_step = _iterator.n()).done) {\n                _context4.next = 9;\n                break;\n              }\n              word = _step.value;\n              level = this.getProficiencyLevel(word.rank);\n              _t = level;\n              _context4.next = _t === \'beginner\' ? 5 : _t === \'intermediate\' ? 6 : _t === \'advanced\' ? 7 : 8;\n              break;\n            case 5:\n              beginner++;\n              return _context4.abrupt("continue", 8);\n            case 6:\n              intermediate++;\n              return _context4.abrupt("continue", 8);\n            case 7:\n              advanced++;\n              return _context4.abrupt("continue", 8);\n            case 8:\n              _context4.next = 4;\n              break;\n            case 9:\n              _context4.next = 11;\n              break;\n            case 10:\n              _context4.prev = 10;\n              _t2 = _context4["catch"](3);\n              _iterator.e(_t2);\n            case 11:\n              _context4.prev = 11;\n              _iterator.f();\n              return _context4.finish(11);\n            case 12:\n              return _context4.abrupt("return", {\n                language: language,\n                totalWords: list.wordCount,\n                beginner: beginner,\n                intermediate: intermediate,\n                advanced: advanced,\n                source: list.source\n              });\n            case 13:\n            case "end":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[3, 10, 11, 12]]);\n      }));\n      function getStats(_x6) {\n        return _getStats.apply(this, arguments);\n      }\n      return getStats;\n    }()\n    /**\n     * Check if frequency list is available for a language\n     */\n    )\n  }, {\n    key: "hasFrequencyList",\n    value: (function () {\n      var _hasFrequencyList = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee5(language) {\n        var stored;\n        return regenerator_default().wrap(function (_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!this.cache.has(language)) {\n                _context5.next = 1;\n                break;\n              }\n              return _context5.abrupt("return", true);\n            case 1:\n              _context5.next = 2;\n              return this.loadFromStorage(language);\n            case 2:\n              stored = _context5.sent;\n              if (!stored) {\n                _context5.next = 3;\n                break;\n              }\n              return _context5.abrupt("return", true);\n            case 3:\n              return _context5.abrupt("return", FREQUENCY_LIST_SOURCES[language] !== null);\n            case 4:\n            case "end":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function hasFrequencyList(_x7) {\n        return _hasFrequencyList.apply(this, arguments);\n      }\n      return hasFrequencyList;\n    }()\n    /**\n     * Get list of languages with available frequency data\n     */\n    )\n  }, {\n    key: "getAvailableLanguages",\n    value: function getAvailableLanguages() {\n      return Object.entries(FREQUENCY_LIST_SOURCES).filter(function (_ref) {\n        var _ref2 = (0,slicedToArray/* default */.A)(_ref, 2),\n          url = _ref2[1];\n        return url !== null;\n      }).map(function (_ref3) {\n        var _ref4 = (0,slicedToArray/* default */.A)(_ref3, 1),\n          lang = _ref4[0];\n        return lang;\n      });\n    }\n\n    /**\n     * Refresh frequency list from remote source\n     */\n  }, {\n    key: "refreshFrequencyList",\n    value: (function () {\n      var _refreshFrequencyList = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee6(language) {\n        var fetched;\n        return regenerator_default().wrap(function (_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 1;\n              return this.fetchFrequencyList(language);\n            case 1:\n              fetched = _context6.sent;\n              if (!fetched) {\n                _context6.next = 3;\n                break;\n              }\n              _context6.next = 2;\n              return this.saveToStorage(language, fetched);\n            case 2:\n              this.cache.set(language, fetched);\n              return _context6.abrupt("return", true);\n            case 3:\n              return _context6.abrupt("return", false);\n            case 4:\n            case "end":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function refreshFrequencyList(_x8) {\n        return _refreshFrequencyList.apply(this, arguments);\n      }\n      return refreshFrequencyList;\n    }()\n    /**\n     * Clear cached frequency list\n     */\n    )\n  }, {\n    key: "clearCache",\n    value: (function () {\n      var _clearCache = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee7(language) {\n        var keys, frequencyKeys;\n        return regenerator_default().wrap(function (_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (!language) {\n                _context7.next = 2;\n                break;\n              }\n              this.cache.delete(language);\n              _context7.next = 1;\n              return lib_module.removeItem(STORAGE_PREFIX + language);\n            case 1:\n              _context7.next = 4;\n              break;\n            case 2:\n              this.cache.clear();\n              _context7.next = 3;\n              return lib_module.getAllKeys();\n            case 3:\n              keys = _context7.sent;\n              frequencyKeys = keys.filter(function (k) {\n                return k.startsWith(STORAGE_PREFIX);\n              });\n              _context7.next = 4;\n              return lib_module.multiRemove(frequencyKeys);\n            case 4:\n            case "end":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function clearCache(_x9) {\n        return _clearCache.apply(this, arguments);\n      }\n      return clearCache;\n    }() // ============================================================================\n    // Private Methods\n    // ============================================================================\n    /**\n     * Fetch frequency list from remote source\n     */\n    )\n  }, {\n    key: "fetchFrequencyList",\n    value: function () {\n      var _fetchFrequencyList = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee8(language) {\n        var url, response, text, words, _t3;\n        return regenerator_default().wrap(function (_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              url = FREQUENCY_LIST_SOURCES[language];\n              if (url) {\n                _context8.next = 1;\n                break;\n              }\n              console.log("No frequency list source for ".concat(language));\n              return _context8.abrupt("return", null);\n            case 1:\n              _context8.prev = 1;\n              console.log("Fetching frequency list for ".concat(language, "..."));\n              _context8.next = 2;\n              return fetch(url);\n            case 2:\n              response = _context8.sent;\n              if (response.ok) {\n                _context8.next = 3;\n                break;\n              }\n              throw new Error("HTTP ".concat(response.status));\n            case 3:\n              _context8.next = 4;\n              return response.text();\n            case 4:\n              text = _context8.sent;\n              words = this.parseFrequencyText(text, language);\n              return _context8.abrupt("return", {\n                language: language,\n                source: \'FrequencyWords/hermitdave\',\n                lastUpdated: new Date().toISOString(),\n                wordCount: words.length,\n                words: words.slice(0, MAX_WORDS_TO_STORE)\n              });\n            case 5:\n              _context8.prev = 5;\n              _t3 = _context8["catch"](1);\n              console.error("Failed to fetch frequency list for ".concat(language, ":"), _t3);\n              return _context8.abrupt("return", null);\n            case 6:\n            case "end":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[1, 5]]);\n      }));\n      function fetchFrequencyList(_x0) {\n        return _fetchFrequencyList.apply(this, arguments);\n      }\n      return fetchFrequencyList;\n    }()\n    /**\n     * Parse frequency list text format\n     * Format: word frequency (space-separated, one per line)\n     */\n  }, {\n    key: "parseFrequencyText",\n    value: function parseFrequencyText(text, _language) {\n      var lines = text.trim().split(\'\\n\');\n      var words = [];\n      for (var i = 0; i < lines.length && i < MAX_WORDS_TO_STORE; i++) {\n        var line = lines[i].trim();\n        if (!line) continue;\n        var parts = line.split(/\\s+/);\n        if (parts.length >= 1) {\n          var word = parts[0];\n          var frequency = parts.length > 1 ? parseInt(parts[1], 10) : undefined;\n\n          // Skip very short words, numbers, and special characters\n          if (word.length < 2 || /^\\d+$/.test(word) || /[^a-zA-Z\\u0370-\\u03FF\\u0400-\\u04FF]/.test(word)) {\n            continue;\n          }\n          words.push({\n            word: word.toLowerCase(),\n            rank: words.length + 1,\n            frequency: frequency\n          });\n        }\n      }\n      return words;\n    }\n\n    /**\n     * Load frequency list from persistent storage\n     */\n  }, {\n    key: "loadFromStorage",\n    value: (function () {\n      var _loadFromStorage = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee9(language) {\n        var stored, _t4;\n        return regenerator_default().wrap(function (_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.prev = 0;\n              _context9.next = 1;\n              return lib_module.getItem(STORAGE_PREFIX + language);\n            case 1:\n              stored = _context9.sent;\n              if (!stored) {\n                _context9.next = 2;\n                break;\n              }\n              return _context9.abrupt("return", JSON.parse(stored));\n            case 2:\n              _context9.next = 4;\n              break;\n            case 3:\n              _context9.prev = 3;\n              _t4 = _context9["catch"](0);\n              console.warn("Failed to load frequency list for ".concat(language, ":"), _t4);\n            case 4:\n              return _context9.abrupt("return", null);\n            case 5:\n            case "end":\n              return _context9.stop();\n          }\n        }, _callee9, null, [[0, 3]]);\n      }));\n      function loadFromStorage(_x1) {\n        return _loadFromStorage.apply(this, arguments);\n      }\n      return loadFromStorage;\n    }()\n    /**\n     * Save frequency list to persistent storage\n     */\n    )\n  }, {\n    key: "saveToStorage",\n    value: (function () {\n      var _saveToStorage = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee0(language, list) {\n        var _t5;\n        return regenerator_default().wrap(function (_context0) {\n          while (1) switch (_context0.prev = _context0.next) {\n            case 0:\n              _context0.prev = 0;\n              _context0.next = 1;\n              return lib_module.setItem(STORAGE_PREFIX + language, JSON.stringify(list));\n            case 1:\n              _context0.next = 3;\n              break;\n            case 2:\n              _context0.prev = 2;\n              _t5 = _context0["catch"](0);\n              console.warn("Failed to save frequency list for ".concat(language, ":"), _t5);\n            case 3:\n            case "end":\n              return _context0.stop();\n          }\n        }, _callee0, null, [[0, 2]]);\n      }));\n      function saveToStorage(_x10, _x11) {\n        return _saveToStorage.apply(this, arguments);\n      }\n      return saveToStorage;\n    }())\n  }]);\n}();\n\n// Export singleton instance\nvar frequencyListService = new FrequencyListService();\n;// ../shared/src/services/TranslationEngine/TranslationAPIService.ts\n\n\n\n\n\n\nfunction TranslationAPIService_createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = TranslationAPIService_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\nfunction TranslationAPIService_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return TranslationAPIService_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? TranslationAPIService_arrayLikeToArray(r, a) : void 0; } }\nfunction TranslationAPIService_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction TranslationAPIService_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction TranslationAPIService_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? TranslationAPIService_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : TranslationAPIService_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * Translation API Service - Multi-provider translation support\n *\n * Supports multiple free translation APIs:\n * - LibreTranslate (open source, self-hostable)\n * - MyMemory (free tier: 1000 words/day)\n * - Lingva Translate (open source Google Translate frontend)\n *\n * Features:\n * - Automatic fallback between providers\n * - Response caching\n * - Rate limiting\n * - Offline mode with cached translations\n */\n\n\n\n// ============================================================================\n// Types\n// ============================================================================\n\n// ============================================================================\n// API Provider Configurations\n// ============================================================================\n\nvar DEFAULT_PROVIDERS = [{\n  provider: \'libretranslate\',\n  baseUrl: \'https://libretranslate.com\',\n  rateLimit: 30,\n  enabled: true\n}, {\n  provider: \'mymemory\',\n  baseUrl: \'https://api.mymemory.translated.net\',\n  rateLimit: 100,\n  enabled: true\n}, {\n  provider: \'lingva\',\n  baseUrl: \'https://lingva.ml\',\n  rateLimit: 60,\n  enabled: true\n}];\n\n// Alternative LibreTranslate instances (community-hosted)\nvar LIBRETRANSLATE_MIRRORS = [\'https://libretranslate.com\', \'https://translate.argosopentech.com\', \'https://translate.terraprint.co\'];\n\n// ============================================================================\n// Language Code Mapping\n// ============================================================================\n\n/**\n * Maps our internal language codes to API-specific codes\n */\nvar LANGUAGE_CODES = {\n  en: {\n    iso639_1: \'en\',\n    name: \'English\'\n  },\n  el: {\n    iso639_1: \'el\',\n    name: \'Greek\'\n  },\n  es: {\n    iso639_1: \'es\',\n    name: \'Spanish\'\n  },\n  fr: {\n    iso639_1: \'fr\',\n    name: \'French\'\n  },\n  de: {\n    iso639_1: \'de\',\n    name: \'German\'\n  },\n  it: {\n    iso639_1: \'it\',\n    name: \'Italian\'\n  },\n  pt: {\n    iso639_1: \'pt\',\n    name: \'Portuguese\'\n  },\n  ru: {\n    iso639_1: \'ru\',\n    name: \'Russian\'\n  },\n  ja: {\n    iso639_1: \'ja\',\n    name: \'Japanese\'\n  },\n  zh: {\n    iso639_1: \'zh\',\n    name: \'Chinese\'\n  },\n  ko: {\n    iso639_1: \'ko\',\n    name: \'Korean\'\n  },\n  ar: {\n    iso639_1: \'ar\',\n    name: \'Arabic\'\n  }\n};\n\n// ============================================================================\n// Cache Keys\n// ============================================================================\n\nvar CACHE_PREFIX = \'@xenolexia/translation_cache_\';\nvar RATE_LIMIT_PREFIX = \'@xenolexia/rate_limit_\';\n\n// ============================================================================\n// Translation API Service\n// ============================================================================\n\nvar TranslationAPIService = /*#__PURE__*/function () {\n  function TranslationAPIService(customProviders) {\n    (0,classCallCheck/* default */.A)(this, TranslationAPIService);\n    (0,defineProperty/* default */.A)(this, "cache", new Map());\n    (0,defineProperty/* default */.A)(this, "rateLimitCounters", new Map());\n    (0,defineProperty/* default */.A)(this, "currentMirrorIndex", 0);\n    this.providers = customProviders || [].concat(DEFAULT_PROVIDERS);\n  }\n\n  /**\n   * Translate a single word or phrase\n   */\n  return (0,createClass/* default */.A)(TranslationAPIService, [{\n    key: "translate",\n    value: (function () {\n      var _translate = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee(text, sourceLanguage, targetLanguage) {\n        var cacheKey, cached, _iterator, _step, provider, result, _t, _t2;\n        return regenerator_default().wrap(function (_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              // Check cache first\n              cacheKey = this.getCacheKey(text, sourceLanguage, targetLanguage);\n              _context.next = 1;\n              return this.getFromCache(cacheKey);\n            case 1:\n              cached = _context.sent;\n              if (!cached) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt("return", TranslationAPIService_objectSpread(TranslationAPIService_objectSpread({}, cached), {}, {\n                cached: true\n              }));\n            case 2:\n              // Try each provider in order\n              _iterator = TranslationAPIService_createForOfIteratorHelper(this.providers);\n              _context.prev = 3;\n              _iterator.s();\n            case 4:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 11;\n                break;\n              }\n              provider = _step.value;\n              if (provider.enabled) {\n                _context.next = 5;\n                break;\n              }\n              return _context.abrupt("continue", 10);\n            case 5:\n              if (!this.isRateLimited(provider.provider)) {\n                _context.next = 6;\n                break;\n              }\n              return _context.abrupt("continue", 10);\n            case 6:\n              _context.prev = 6;\n              _context.next = 7;\n              return this.translateWithProvider(text, sourceLanguage, targetLanguage, provider);\n            case 7:\n              result = _context.sent;\n              _context.next = 8;\n              return this.saveToCache(cacheKey, result);\n            case 8:\n              this.incrementRateLimit(provider.provider);\n              return _context.abrupt("return", result);\n            case 9:\n              _context.prev = 9;\n              _t = _context["catch"](6);\n              console.warn("Translation failed with ".concat(provider.provider, ":"), _t);\n              return _context.abrupt("continue", 10);\n            case 10:\n              _context.next = 4;\n              break;\n            case 11:\n              _context.next = 13;\n              break;\n            case 12:\n              _context.prev = 12;\n              _t2 = _context["catch"](3);\n              _iterator.e(_t2);\n            case 13:\n              _context.prev = 13;\n              _iterator.f();\n              return _context.finish(13);\n            case 14:\n              throw new Error(\'All translation providers failed\');\n            case 15:\n            case "end":\n              return _context.stop();\n          }\n        }, _callee, this, [[3, 12, 13, 14], [6, 9]]);\n      }));\n      function translate(_x, _x2, _x3) {\n        return _translate.apply(this, arguments);\n      }\n      return translate;\n    }()\n    /**\n     * Translate multiple words efficiently\n     */\n    )\n  }, {\n    key: "translateBulk",\n    value: (function () {\n      var _translateBulk = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee2(words, sourceLanguage, targetLanguage) {\n        var translations, failed, toTranslate, _iterator2, _step2, _word, cacheKey, cached, batchSize, usedProvider, i, batch, _iterator3, _step3, word, result, _t3, _t4, _t5;\n        return regenerator_default().wrap(function (_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              translations = new Map();\n              failed = [];\n              toTranslate = []; // Check cache first\n              _iterator2 = TranslationAPIService_createForOfIteratorHelper(words);\n              _context2.prev = 1;\n              _iterator2.s();\n            case 2:\n              if ((_step2 = _iterator2.n()).done) {\n                _context2.next = 5;\n                break;\n              }\n              _word = _step2.value;\n              cacheKey = this.getCacheKey(_word, sourceLanguage, targetLanguage);\n              _context2.next = 3;\n              return this.getFromCache(cacheKey);\n            case 3:\n              cached = _context2.sent;\n              if (cached) {\n                translations.set(_word, cached.translatedText);\n              } else {\n                toTranslate.push(_word);\n              }\n            case 4:\n              _context2.next = 2;\n              break;\n            case 5:\n              _context2.next = 7;\n              break;\n            case 6:\n              _context2.prev = 6;\n              _t3 = _context2["catch"](1);\n              _iterator2.e(_t3);\n            case 7:\n              _context2.prev = 7;\n              _iterator2.f();\n              return _context2.finish(7);\n            case 8:\n              // Translate uncached words in batches\n              batchSize = 10;\n              usedProvider = \'libretranslate\';\n              i = 0;\n            case 9:\n              if (!(i < toTranslate.length)) {\n                _context2.next = 21;\n                break;\n              }\n              batch = toTranslate.slice(i, i + batchSize);\n              _iterator3 = TranslationAPIService_createForOfIteratorHelper(batch);\n              _context2.prev = 10;\n              _iterator3.s();\n            case 11:\n              if ((_step3 = _iterator3.n()).done) {\n                _context2.next = 16;\n                break;\n              }\n              word = _step3.value;\n              _context2.prev = 12;\n              _context2.next = 13;\n              return this.translate(word, sourceLanguage, targetLanguage);\n            case 13:\n              result = _context2.sent;\n              translations.set(word, result.translatedText);\n              usedProvider = result.provider;\n              _context2.next = 15;\n              break;\n            case 14:\n              _context2.prev = 14;\n              _t4 = _context2["catch"](12);\n              failed.push(word);\n            case 15:\n              _context2.next = 11;\n              break;\n            case 16:\n              _context2.next = 18;\n              break;\n            case 17:\n              _context2.prev = 17;\n              _t5 = _context2["catch"](10);\n              _iterator3.e(_t5);\n            case 18:\n              _context2.prev = 18;\n              _iterator3.f();\n              return _context2.finish(18);\n            case 19:\n              if (!(i + batchSize < toTranslate.length)) {\n                _context2.next = 20;\n                break;\n              }\n              _context2.next = 20;\n              return this.delay(200);\n            case 20:\n              i += batchSize;\n              _context2.next = 9;\n              break;\n            case 21:\n              return _context2.abrupt("return", {\n                translations: translations,\n                provider: usedProvider,\n                failed: failed\n              });\n            case 22:\n            case "end":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[1, 6, 7, 8], [10, 17, 18, 19], [12, 14]]);\n      }));\n      function translateBulk(_x4, _x5, _x6) {\n        return _translateBulk.apply(this, arguments);\n      }\n      return translateBulk;\n    }()\n    /**\n     * Get supported languages for a provider\n     */\n    )\n  }, {\n    key: "getSupportedLanguages",\n    value: (function () {\n      var _getSupportedLanguages = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee3(provider) {\n        var targetProvider, _t6, _t7;\n        return regenerator_default().wrap(function (_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              targetProvider = provider || this.providers[0].provider;\n              _context3.prev = 1;\n              _t6 = targetProvider;\n              _context3.next = _t6 === \'libretranslate\' ? 2 : _t6 === \'mymemory\' ? 3 : _t6 === \'lingva\' ? 4 : 5;\n              break;\n            case 2:\n              return _context3.abrupt("return", this.getLibreTranslateLanguages());\n            case 3:\n              return _context3.abrupt("return", Object.keys(LANGUAGE_CODES));\n            case 4:\n              return _context3.abrupt("return", this.getLingvaLanguages());\n            case 5:\n              return _context3.abrupt("return", Object.keys(LANGUAGE_CODES));\n            case 6:\n              _context3.next = 8;\n              break;\n            case 7:\n              _context3.prev = 7;\n              _t7 = _context3["catch"](1);\n              console.warn(\'Failed to get supported languages:\', _t7);\n              return _context3.abrupt("return", Object.keys(LANGUAGE_CODES));\n            case 8:\n            case "end":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[1, 7]]);\n      }));\n      function getSupportedLanguages(_x7) {\n        return _getSupportedLanguages.apply(this, arguments);\n      }\n      return getSupportedLanguages;\n    }()\n    /**\n     * Check if a language pair is supported\n     */\n    )\n  }, {\n    key: "isLanguagePairSupported",\n    value: (function () {\n      var _isLanguagePairSupported = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee4(sourceLanguage, targetLanguage) {\n        var supported;\n        return regenerator_default().wrap(function (_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 1;\n              return this.getSupportedLanguages();\n            case 1:\n              supported = _context4.sent;\n              return _context4.abrupt("return", supported.includes(sourceLanguage) && supported.includes(targetLanguage));\n            case 2:\n            case "end":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function isLanguagePairSupported(_x8, _x9) {\n        return _isLanguagePairSupported.apply(this, arguments);\n      }\n      return isLanguagePairSupported;\n    }() // ============================================================================\n    // Provider-Specific Translation Methods\n    // ============================================================================\n    )\n  }, {\n    key: "translateWithProvider",\n    value: function () {\n      var _translateWithProvider = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee5(text, sourceLanguage, targetLanguage, config) {\n        var _t8;\n        return regenerator_default().wrap(function (_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _t8 = config.provider;\n              _context5.next = _t8 === \'libretranslate\' ? 1 : _t8 === \'mymemory\' ? 2 : _t8 === \'lingva\' ? 3 : 4;\n              break;\n            case 1:\n              return _context5.abrupt("return", this.translateWithLibreTranslate(text, sourceLanguage, targetLanguage, config));\n            case 2:\n              return _context5.abrupt("return", this.translateWithMyMemory(text, sourceLanguage, targetLanguage, config));\n            case 3:\n              return _context5.abrupt("return", this.translateWithLingva(text, sourceLanguage, targetLanguage, config));\n            case 4:\n              throw new Error("Unknown provider: ".concat(config.provider));\n            case 5:\n            case "end":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function translateWithProvider(_x0, _x1, _x10, _x11) {\n        return _translateWithProvider.apply(this, arguments);\n      }\n      return translateWithProvider;\n    }()\n    /**\n     * LibreTranslate API\n     * https://github.com/LibreTranslate/LibreTranslate\n     */\n  }, {\n    key: "translateWithLibreTranslate",\n    value: (function () {\n      var _translateWithLibreTranslate = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee6(text, sourceLanguage, targetLanguage, config) {\n        var baseUrl, response, data;\n        return regenerator_default().wrap(function (_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              baseUrl = this.getLibreTranslateMirror(config.baseUrl);\n              _context6.next = 1;\n              return fetch("".concat(baseUrl, "/translate"), {\n                method: \'POST\',\n                headers: {\n                  \'Content-Type\': \'application/json\'\n                },\n                body: JSON.stringify({\n                  q: text,\n                  source: LANGUAGE_CODES[sourceLanguage].iso639_1,\n                  target: LANGUAGE_CODES[targetLanguage].iso639_1,\n                  format: \'text\',\n                  api_key: config.apiKey || \'\'\n                })\n              });\n            case 1:\n              response = _context6.sent;\n              if (response.ok) {\n                _context6.next = 2;\n                break;\n              }\n              // Try next mirror\n              this.currentMirrorIndex = (this.currentMirrorIndex + 1) % LIBRETRANSLATE_MIRRORS.length;\n              throw new Error("LibreTranslate error: ".concat(response.status));\n            case 2:\n              _context6.next = 3;\n              return response.json();\n            case 3:\n              data = _context6.sent;\n              return _context6.abrupt("return", {\n                translatedText: data.translatedText,\n                sourceLanguage: sourceLanguage,\n                targetLanguage: targetLanguage,\n                provider: \'libretranslate\'\n              });\n            case 4:\n            case "end":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function translateWithLibreTranslate(_x12, _x13, _x14, _x15) {\n        return _translateWithLibreTranslate.apply(this, arguments);\n      }\n      return translateWithLibreTranslate;\n    }()\n    /**\n     * MyMemory Translation API\n     * https://mymemory.translated.net/doc/spec.php\n     * Free: 1000 words/day, 10000 with email\n     */\n    )\n  }, {\n    key: "translateWithMyMemory",\n    value: (function () {\n      var _translateWithMyMemory = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee7(text, sourceLanguage, targetLanguage, config) {\n        var langPair, url, response, data;\n        return regenerator_default().wrap(function (_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              langPair = "".concat(LANGUAGE_CODES[sourceLanguage].iso639_1, "|").concat(LANGUAGE_CODES[targetLanguage].iso639_1);\n              url = "".concat(config.baseUrl, "/get?q=").concat(encodeURIComponent(text), "&langpair=").concat(langPair);\n              _context7.next = 1;\n              return fetch(url);\n            case 1:\n              response = _context7.sent;\n              if (response.ok) {\n                _context7.next = 2;\n                break;\n              }\n              throw new Error("MyMemory error: ".concat(response.status));\n            case 2:\n              _context7.next = 3;\n              return response.json();\n            case 3:\n              data = _context7.sent;\n              if (!(data.responseStatus !== 200)) {\n                _context7.next = 4;\n                break;\n              }\n              throw new Error("MyMemory error: ".concat(data.responseDetails));\n            case 4:\n              return _context7.abrupt("return", {\n                translatedText: data.responseData.translatedText,\n                sourceLanguage: sourceLanguage,\n                targetLanguage: targetLanguage,\n                provider: \'mymemory\',\n                confidence: data.responseData.match\n              });\n            case 5:\n            case "end":\n              return _context7.stop();\n          }\n        }, _callee7);\n      }));\n      function translateWithMyMemory(_x16, _x17, _x18, _x19) {\n        return _translateWithMyMemory.apply(this, arguments);\n      }\n      return translateWithMyMemory;\n    }()\n    /**\n     * Lingva Translate API\n     * https://github.com/thedaviddelta/lingva-translate\n     */\n    )\n  }, {\n    key: "translateWithLingva",\n    value: (function () {\n      var _translateWithLingva = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee8(text, sourceLanguage, targetLanguage, config) {\n        var source, target, url, response, data;\n        return regenerator_default().wrap(function (_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              source = LANGUAGE_CODES[sourceLanguage].iso639_1;\n              target = LANGUAGE_CODES[targetLanguage].iso639_1;\n              url = "".concat(config.baseUrl, "/api/v1/").concat(source, "/").concat(target, "/").concat(encodeURIComponent(text));\n              _context8.next = 1;\n              return fetch(url);\n            case 1:\n              response = _context8.sent;\n              if (response.ok) {\n                _context8.next = 2;\n                break;\n              }\n              throw new Error("Lingva error: ".concat(response.status));\n            case 2:\n              _context8.next = 3;\n              return response.json();\n            case 3:\n              data = _context8.sent;\n              return _context8.abrupt("return", {\n                translatedText: data.translation,\n                sourceLanguage: sourceLanguage,\n                targetLanguage: targetLanguage,\n                provider: \'lingva\'\n              });\n            case 4:\n            case "end":\n              return _context8.stop();\n          }\n        }, _callee8);\n      }));\n      function translateWithLingva(_x20, _x21, _x22, _x23) {\n        return _translateWithLingva.apply(this, arguments);\n      }\n      return translateWithLingva;\n    }() // ============================================================================\n    // Language Support Methods\n    // ============================================================================\n    )\n  }, {\n    key: "getLibreTranslateLanguages",\n    value: function () {\n      var _getLibreTranslateLanguages = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee9() {\n        var baseUrl, response, data, supported, _iterator4, _step4, _loop, _t9, _t0;\n        return regenerator_default().wrap(function (_context0) {\n          while (1) switch (_context0.prev = _context0.next) {\n            case 0:\n              _context0.prev = 0;\n              baseUrl = this.getLibreTranslateMirror(DEFAULT_PROVIDERS[0].baseUrl);\n              _context0.next = 1;\n              return fetch("".concat(baseUrl, "/languages"));\n            case 1:\n              response = _context0.sent;\n              _context0.next = 2;\n              return response.json();\n            case 2:\n              data = _context0.sent;\n              supported = [];\n              _iterator4 = TranslationAPIService_createForOfIteratorHelper(data);\n              _context0.prev = 3;\n              _loop = /*#__PURE__*/regenerator_default().mark(function _loop() {\n                var lang, match;\n                return regenerator_default().wrap(function (_context9) {\n                  while (1) switch (_context9.prev = _context9.next) {\n                    case 0:\n                      lang = _step4.value;\n                      match = Object.entries(LANGUAGE_CODES).find(function (_ref) {\n                        var _ref2 = (0,slicedToArray/* default */.A)(_ref, 2),\n                          v = _ref2[1];\n                        return v.iso639_1 === lang.code;\n                      });\n                      if (match) {\n                        supported.push(match[0]);\n                      }\n                    case 1:\n                    case "end":\n                      return _context9.stop();\n                  }\n                }, _loop);\n              });\n              _iterator4.s();\n            case 4:\n              if ((_step4 = _iterator4.n()).done) {\n                _context0.next = 6;\n                break;\n              }\n              return _context0.delegateYield(_loop(), "t0", 5);\n            case 5:\n              _context0.next = 4;\n              break;\n            case 6:\n              _context0.next = 8;\n              break;\n            case 7:\n              _context0.prev = 7;\n              _t9 = _context0["catch"](3);\n              _iterator4.e(_t9);\n            case 8:\n              _context0.prev = 8;\n              _iterator4.f();\n              return _context0.finish(8);\n            case 9:\n              return _context0.abrupt("return", supported);\n            case 10:\n              _context0.prev = 10;\n              _t0 = _context0["catch"](0);\n              return _context0.abrupt("return", Object.keys(LANGUAGE_CODES));\n            case 11:\n            case "end":\n              return _context0.stop();\n          }\n        }, _callee9, this, [[0, 10], [3, 7, 8, 9]]);\n      }));\n      function getLibreTranslateLanguages() {\n        return _getLibreTranslateLanguages.apply(this, arguments);\n      }\n      return getLibreTranslateLanguages;\n    }()\n  }, {\n    key: "getLingvaLanguages",\n    value: function () {\n      var _getLingvaLanguages = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee0() {\n        var response, data, supported, _iterator5, _step5, _loop2, _t1, _t10;\n        return regenerator_default().wrap(function (_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.prev = 0;\n              _context10.next = 1;\n              return fetch("".concat(DEFAULT_PROVIDERS[2].baseUrl, "/api/v1/languages"));\n            case 1:\n              response = _context10.sent;\n              _context10.next = 2;\n              return response.json();\n            case 2:\n              data = _context10.sent;\n              supported = [];\n              _iterator5 = TranslationAPIService_createForOfIteratorHelper(data.languages);\n              _context10.prev = 3;\n              _loop2 = /*#__PURE__*/regenerator_default().mark(function _loop2() {\n                var lang, match;\n                return regenerator_default().wrap(function (_context1) {\n                  while (1) switch (_context1.prev = _context1.next) {\n                    case 0:\n                      lang = _step5.value;\n                      match = Object.entries(LANGUAGE_CODES).find(function (_ref3) {\n                        var _ref4 = (0,slicedToArray/* default */.A)(_ref3, 2),\n                          v = _ref4[1];\n                        return v.iso639_1 === lang.code;\n                      });\n                      if (match) {\n                        supported.push(match[0]);\n                      }\n                    case 1:\n                    case "end":\n                      return _context1.stop();\n                  }\n                }, _loop2);\n              });\n              _iterator5.s();\n            case 4:\n              if ((_step5 = _iterator5.n()).done) {\n                _context10.next = 6;\n                break;\n              }\n              return _context10.delegateYield(_loop2(), "t0", 5);\n            case 5:\n              _context10.next = 4;\n              break;\n            case 6:\n              _context10.next = 8;\n              break;\n            case 7:\n              _context10.prev = 7;\n              _t1 = _context10["catch"](3);\n              _iterator5.e(_t1);\n            case 8:\n              _context10.prev = 8;\n              _iterator5.f();\n              return _context10.finish(8);\n            case 9:\n              return _context10.abrupt("return", supported);\n            case 10:\n              _context10.prev = 10;\n              _t10 = _context10["catch"](0);\n              return _context10.abrupt("return", Object.keys(LANGUAGE_CODES));\n            case 11:\n            case "end":\n              return _context10.stop();\n          }\n        }, _callee0, null, [[0, 10], [3, 7, 8, 9]]);\n      }));\n      function getLingvaLanguages() {\n        return _getLingvaLanguages.apply(this, arguments);\n      }\n      return getLingvaLanguages;\n    }()\n  }, {\n    key: "getLibreTranslateMirror",\n    value: function getLibreTranslateMirror(defaultUrl) {\n      if (LIBRETRANSLATE_MIRRORS.includes(defaultUrl)) {\n        return LIBRETRANSLATE_MIRRORS[this.currentMirrorIndex];\n      }\n      return defaultUrl;\n    }\n\n    // ============================================================================\n    // Cache Methods\n    // ============================================================================\n  }, {\n    key: "getCacheKey",\n    value: function getCacheKey(text, source, target) {\n      return "".concat(source, "_").concat(target, "_").concat(text.toLowerCase());\n    }\n  }, {\n    key: "getFromCache",\n    value: function () {\n      var _getFromCache = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee1(key) {\n        var stored, result, _t11;\n        return regenerator_default().wrap(function (_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              if (!this.cache.has(key)) {\n                _context11.next = 1;\n                break;\n              }\n              return _context11.abrupt("return", this.cache.get(key));\n            case 1:\n              _context11.prev = 1;\n              _context11.next = 2;\n              return lib_module.getItem(CACHE_PREFIX + key);\n            case 2:\n              stored = _context11.sent;\n              if (!stored) {\n                _context11.next = 3;\n                break;\n              }\n              result = JSON.parse(stored);\n              this.cache.set(key, result);\n              return _context11.abrupt("return", result);\n            case 3:\n              _context11.next = 5;\n              break;\n            case 4:\n              _context11.prev = 4;\n              _t11 = _context11["catch"](1);\n            case 5:\n              return _context11.abrupt("return", null);\n            case 6:\n            case "end":\n              return _context11.stop();\n          }\n        }, _callee1, this, [[1, 4]]);\n      }));\n      function getFromCache(_x24) {\n        return _getFromCache.apply(this, arguments);\n      }\n      return getFromCache;\n    }()\n  }, {\n    key: "saveToCache",\n    value: function () {\n      var _saveToCache = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee10(key, result) {\n        var firstKey, _t12;\n        return regenerator_default().wrap(function (_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              // Save to memory cache\n              this.cache.set(key, result);\n\n              // Limit memory cache size\n              if (this.cache.size > 10000) {\n                firstKey = this.cache.keys().next().value;\n                if (firstKey) this.cache.delete(firstKey);\n              }\n\n              // Save to persistent cache\n              _context12.prev = 1;\n              _context12.next = 2;\n              return lib_module.setItem(CACHE_PREFIX + key, JSON.stringify(result));\n            case 2:\n              _context12.next = 4;\n              break;\n            case 3:\n              _context12.prev = 3;\n              _t12 = _context12["catch"](1);\n              console.warn(\'Failed to save to cache:\', _t12);\n            case 4:\n            case "end":\n              return _context12.stop();\n          }\n        }, _callee10, this, [[1, 3]]);\n      }));\n      function saveToCache(_x25, _x26) {\n        return _saveToCache.apply(this, arguments);\n      }\n      return saveToCache;\n    }()\n    /**\n     * Clear all cached translations\n     */\n  }, {\n    key: "clearCache",\n    value: (function () {\n      var _clearCache = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee11() {\n        var keys, cacheKeys, _t13;\n        return regenerator_default().wrap(function (_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              this.cache.clear();\n              _context13.prev = 1;\n              _context13.next = 2;\n              return lib_module.getAllKeys();\n            case 2:\n              keys = _context13.sent;\n              cacheKeys = keys.filter(function (k) {\n                return k.startsWith(CACHE_PREFIX);\n              });\n              _context13.next = 3;\n              return lib_module.multiRemove(cacheKeys);\n            case 3:\n              _context13.next = 5;\n              break;\n            case 4:\n              _context13.prev = 4;\n              _t13 = _context13["catch"](1);\n              console.warn(\'Failed to clear cache:\', _t13);\n            case 5:\n            case "end":\n              return _context13.stop();\n          }\n        }, _callee11, this, [[1, 4]]);\n      }));\n      function clearCache() {\n        return _clearCache.apply(this, arguments);\n      }\n      return clearCache;\n    }()\n    /**\n     * Get cache statistics\n     */\n    )\n  }, {\n    key: "getCacheStats",\n    value: (function () {\n      var _getCacheStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee12() {\n        var persistentSize, keys, _t14;\n        return regenerator_default().wrap(function (_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              persistentSize = 0;\n              _context14.prev = 1;\n              _context14.next = 2;\n              return lib_module.getAllKeys();\n            case 2:\n              keys = _context14.sent;\n              persistentSize = keys.filter(function (k) {\n                return k.startsWith(CACHE_PREFIX);\n              }).length;\n              _context14.next = 4;\n              break;\n            case 3:\n              _context14.prev = 3;\n              _t14 = _context14["catch"](1);\n            case 4:\n              return _context14.abrupt("return", {\n                memorySize: this.cache.size,\n                persistentSize: persistentSize\n              });\n            case 5:\n            case "end":\n              return _context14.stop();\n          }\n        }, _callee12, this, [[1, 3]]);\n      }));\n      function getCacheStats() {\n        return _getCacheStats.apply(this, arguments);\n      }\n      return getCacheStats;\n    }() // ============================================================================\n    // Rate Limiting\n    // ============================================================================\n    )\n  }, {\n    key: "isRateLimited",\n    value: function isRateLimited(provider) {\n      var counter = this.rateLimitCounters.get(provider);\n      if (!counter) return false;\n      if (Date.now() > counter.resetTime) {\n        this.rateLimitCounters.delete(provider);\n        return false;\n      }\n      var config = this.providers.find(function (p) {\n        return p.provider === provider;\n      });\n      return counter.count >= ((config === null || config === void 0 ? void 0 : config.rateLimit) || 60);\n    }\n  }, {\n    key: "incrementRateLimit",\n    value: function incrementRateLimit(provider) {\n      var counter = this.rateLimitCounters.get(provider);\n      var now = Date.now();\n      if (!counter || now > counter.resetTime) {\n        this.rateLimitCounters.set(provider, {\n          count: 1,\n          resetTime: now + 60000 // Reset after 1 minute\n        });\n      } else {\n        counter.count++;\n      }\n    }\n\n    // ============================================================================\n    // Utility Methods\n    // ============================================================================\n  }, {\n    key: "delay",\n    value: function delay(ms) {\n      return new Promise(function (resolve) {\n        return setTimeout(resolve, ms);\n      });\n    }\n\n    /**\n     * Enable or disable a provider\n     */\n  }, {\n    key: "setProviderEnabled",\n    value: function setProviderEnabled(provider, enabled) {\n      var config = this.providers.find(function (p) {\n        return p.provider === provider;\n      });\n      if (config) {\n        config.enabled = enabled;\n      }\n    }\n\n    /**\n     * Set API key for a provider\n     */\n  }, {\n    key: "setApiKey",\n    value: function setApiKey(provider, apiKey) {\n      var config = this.providers.find(function (p) {\n        return p.provider === provider;\n      });\n      if (config) {\n        config.apiKey = apiKey;\n      }\n    }\n\n    /**\n     * Get language display name\n     */\n  }], [{\n    key: "getLanguageName",\n    value: function getLanguageName(code) {\n      var _LANGUAGE_CODES$code;\n      return ((_LANGUAGE_CODES$code = LANGUAGE_CODES[code]) === null || _LANGUAGE_CODES$code === void 0 ? void 0 : _LANGUAGE_CODES$code.name) || code;\n    }\n\n    /**\n     * Get all supported language codes\n     */\n  }, {\n    key: "getAllLanguages",\n    value: function getAllLanguages() {\n      return Object.entries(LANGUAGE_CODES).map(function (_ref5) {\n        var _ref6 = (0,slicedToArray/* default */.A)(_ref5, 2),\n          code = _ref6[0],\n          data = _ref6[1];\n        return {\n          code: code,\n          name: data.name\n        };\n      });\n    }\n  }]);\n}();\n\n// Export singleton instance\nvar translationAPI = new TranslationAPIService();\n;// ../shared/src/services/TranslationEngine/DynamicWordDatabase.ts\n\n\n\n\n\n\nfunction DynamicWordDatabase_createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = DynamicWordDatabase_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\nfunction DynamicWordDatabase_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return DynamicWordDatabase_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? DynamicWordDatabase_arrayLikeToArray(r, a) : void 0; } }\nfunction DynamicWordDatabase_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n\n/**\n * Dynamic Word Database - Language-agnostic word translation database\n *\n * Combines:\n * - TranslationAPIService for real-time translations\n * - FrequencyListService for proficiency-based word selection\n * - SQLite for caching and offline support\n *\n * Features:\n * - Supports any language pair\n * - Builds vocabulary dynamically using translation APIs\n * - Uses frequency lists to determine word difficulty\n * - Caches translations for offline use\n */\n\n\n\n\n\n\n// ============================================================================\n// Types\n// ============================================================================\n\n// ============================================================================\n// Dynamic Word Database\n// ============================================================================\n\nvar DynamicWordDatabase = /*#__PURE__*/function () {\n  function DynamicWordDatabase() {\n    (0,classCallCheck/* default */.A)(this, DynamicWordDatabase);\n    (0,defineProperty/* default */.A)(this, "memoryCache", new Map());\n    (0,defineProperty/* default */.A)(this, "initialized", false);\n    this.db = DatabaseService/* databaseService */.v;\n    this.translationAPI = translationAPI;\n    this.frequencyService = frequencyListService;\n  }\n\n  /**\n   * Initialize the database\n   */\n  return (0,createClass/* default */.A)(DynamicWordDatabase, [{\n    key: "initialize",\n    value: (function () {\n      var _initialize = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee() {\n        return regenerator_default().wrap(function (_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!this.initialized) {\n                _context.next = 1;\n                break;\n              }\n              return _context.abrupt("return");\n            case 1:\n              _context.next = 2;\n              return this.db.initialize();\n            case 2:\n              this.initialized = true;\n            case 3:\n            case "end":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function initialize() {\n        return _initialize.apply(this, arguments);\n      }\n      return initialize;\n    }()\n    /**\n     * Look up a word translation\n     * Checks: memory cache  database  translation API\n     */\n    )\n  }, {\n    key: "lookupWord",\n    value: (function () {\n      var _lookupWord = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee2(word, sourceLanguage, targetLanguage) {\n        var normalizedWord, cacheKey, dbEntry, translated, _t;\n        return regenerator_default().wrap(function (_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 1;\n              return this.initialize();\n            case 1:\n              normalizedWord = word.toLowerCase().trim();\n              cacheKey = this.getCacheKey(normalizedWord, sourceLanguage, targetLanguage); // 1. Check memory cache\n              if (!this.memoryCache.has(cacheKey)) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt("return", {\n                entry: this.memoryCache.get(cacheKey),\n                source: \'cache\'\n              });\n            case 2:\n              _context2.next = 3;\n              return this.lookupFromDatabase(normalizedWord, sourceLanguage, targetLanguage);\n            case 3:\n              dbEntry = _context2.sent;\n              if (!dbEntry) {\n                _context2.next = 4;\n                break;\n              }\n              this.memoryCache.set(cacheKey, dbEntry);\n              return _context2.abrupt("return", {\n                entry: dbEntry,\n                source: \'database\'\n              });\n            case 4:\n              _context2.prev = 4;\n              _context2.next = 5;\n              return this.translateAndCache(normalizedWord, sourceLanguage, targetLanguage);\n            case 5:\n              translated = _context2.sent;\n              if (!translated) {\n                _context2.next = 6;\n                break;\n              }\n              this.memoryCache.set(cacheKey, translated);\n              return _context2.abrupt("return", {\n                entry: translated,\n                source: \'api\'\n              });\n            case 6:\n              _context2.next = 8;\n              break;\n            case 7:\n              _context2.prev = 7;\n              _t = _context2["catch"](4);\n              console.warn("Translation failed for \\"".concat(word, "\\":"), _t);\n            case 8:\n              return _context2.abrupt("return", {\n                entry: null,\n                source: \'none\'\n              });\n            case 9:\n            case "end":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[4, 7]]);\n      }));\n      function lookupWord(_x, _x2, _x3) {\n        return _lookupWord.apply(this, arguments);\n      }\n      return lookupWord;\n    }()\n    /**\n     * Look up multiple words efficiently\n     */\n    )\n  }, {\n    key: "lookupWords",\n    value: (function () {\n      var _lookupWords = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee3(words, sourceLanguage, targetLanguage) {\n        var results, toTranslate, _iterator, _step, _word2, normalizedWord, cacheKey, dbEntry, bulkResult, _iterator2, _step2, _step2$value, word, translation, entry, _iterator3, _step3, _word, _t2, _t3;\n        return regenerator_default().wrap(function (_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              results = new Map();\n              toTranslate = []; // First pass: check cache and database\n              _iterator = DynamicWordDatabase_createForOfIteratorHelper(words);\n              _context3.prev = 1;\n              _iterator.s();\n            case 2:\n              if ((_step = _iterator.n()).done) {\n                _context3.next = 6;\n                break;\n              }\n              _word2 = _step.value;\n              normalizedWord = _word2.toLowerCase().trim();\n              cacheKey = this.getCacheKey(normalizedWord, sourceLanguage, targetLanguage);\n              if (!this.memoryCache.has(cacheKey)) {\n                _context3.next = 3;\n                break;\n              }\n              results.set(_word2, {\n                entry: this.memoryCache.get(cacheKey),\n                source: \'cache\'\n              });\n              _context3.next = 5;\n              break;\n            case 3:\n              _context3.next = 4;\n              return this.lookupFromDatabase(normalizedWord, sourceLanguage, targetLanguage);\n            case 4:\n              dbEntry = _context3.sent;\n              if (dbEntry) {\n                this.memoryCache.set(cacheKey, dbEntry);\n                results.set(_word2, {\n                  entry: dbEntry,\n                  source: \'database\'\n                });\n              } else {\n                toTranslate.push(_word2);\n              }\n            case 5:\n              _context3.next = 2;\n              break;\n            case 6:\n              _context3.next = 8;\n              break;\n            case 7:\n              _context3.prev = 7;\n              _t2 = _context3["catch"](1);\n              _iterator.e(_t2);\n            case 8:\n              _context3.prev = 8;\n              _iterator.f();\n              return _context3.finish(8);\n            case 9:\n              if (!(toTranslate.length > 0)) {\n                _context3.next = 19;\n                break;\n              }\n              _context3.next = 10;\n              return this.translationAPI.translateBulk(toTranslate, sourceLanguage, targetLanguage);\n            case 10:\n              bulkResult = _context3.sent;\n              _iterator2 = DynamicWordDatabase_createForOfIteratorHelper(bulkResult.translations);\n              _context3.prev = 11;\n              _iterator2.s();\n            case 12:\n              if ((_step2 = _iterator2.n()).done) {\n                _context3.next = 15;\n                break;\n              }\n              _step2$value = (0,slicedToArray/* default */.A)(_step2.value, 2), word = _step2$value[0], translation = _step2$value[1];\n              _context3.next = 13;\n              return this.createAndCacheEntry(word, translation, sourceLanguage, targetLanguage, bulkResult.provider);\n            case 13:\n              entry = _context3.sent;\n              results.set(word, {\n                entry: entry,\n                source: \'api\'\n              });\n            case 14:\n              _context3.next = 12;\n              break;\n            case 15:\n              _context3.next = 17;\n              break;\n            case 16:\n              _context3.prev = 16;\n              _t3 = _context3["catch"](11);\n              _iterator2.e(_t3);\n            case 17:\n              _context3.prev = 17;\n              _iterator2.f();\n              return _context3.finish(17);\n            case 18:\n              _iterator3 = DynamicWordDatabase_createForOfIteratorHelper(bulkResult.failed);\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  _word = _step3.value;\n                  results.set(_word, {\n                    entry: null,\n                    source: \'none\'\n                  });\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            case 19:\n              return _context3.abrupt("return", results);\n            case 20:\n            case "end":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[1, 7, 8, 9], [11, 16, 17, 18]]);\n      }));\n      function lookupWords(_x4, _x5, _x6) {\n        return _lookupWords.apply(this, arguments);\n      }\n      return lookupWords;\n    }()\n    /**\n     * Get words by proficiency level for a language\n     * Uses frequency list to select appropriate words\n     */\n    )\n  }, {\n    key: "getWordsByProficiency",\n    value: (function () {\n      var _getWordsByProficiency = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee4(sourceLanguage, targetLanguage, level) {\n        var limit,\n          frequencyWords,\n          shuffled,\n          selected,\n          entries,\n          _iterator4,\n          _step4,\n          freqWord,\n          result,\n          _args4 = arguments,\n          _t4;\n        return regenerator_default().wrap(function (_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              limit = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : 50;\n              _context4.next = 1;\n              return this.initialize();\n            case 1:\n              _context4.next = 2;\n              return this.frequencyService.getWordsByProficiency(sourceLanguage, level);\n            case 2:\n              frequencyWords = _context4.sent;\n              if (!(frequencyWords.length === 0)) {\n                _context4.next = 3;\n                break;\n              }\n              return _context4.abrupt("return", this.getCachedWordsByLevel(sourceLanguage, targetLanguage, level, limit));\n            case 3:\n              // Select random subset\n              shuffled = (0,toConsumableArray/* default */.A)(frequencyWords).sort(function () {\n                return Math.random() - 0.5;\n              });\n              selected = shuffled.slice(0, limit); // Look up translations for selected words\n              entries = [];\n              _iterator4 = DynamicWordDatabase_createForOfIteratorHelper(selected);\n              _context4.prev = 4;\n              _iterator4.s();\n            case 5:\n              if ((_step4 = _iterator4.n()).done) {\n                _context4.next = 8;\n                break;\n              }\n              freqWord = _step4.value;\n              _context4.next = 6;\n              return this.lookupWord(freqWord.word, sourceLanguage, targetLanguage);\n            case 6:\n              result = _context4.sent;\n              if (result.entry) {\n                entries.push(result.entry);\n              }\n            case 7:\n              _context4.next = 5;\n              break;\n            case 8:\n              _context4.next = 10;\n              break;\n            case 9:\n              _context4.prev = 9;\n              _t4 = _context4["catch"](4);\n              _iterator4.e(_t4);\n            case 10:\n              _context4.prev = 10;\n              _iterator4.f();\n              return _context4.finish(10);\n            case 11:\n              return _context4.abrupt("return", entries);\n            case 12:\n            case "end":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[4, 9, 10, 11]]);\n      }));\n      function getWordsByProficiency(_x7, _x8, _x9) {\n        return _getWordsByProficiency.apply(this, arguments);\n      }\n      return getWordsByProficiency;\n    }()\n    /**\n     * Get random words for vocabulary practice\n     */\n    )\n  }, {\n    key: "getRandomWords",\n    value: (function () {\n      var _getRandomWords = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee5(sourceLanguage, targetLanguage, level, count) {\n        return regenerator_default().wrap(function (_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              return _context5.abrupt("return", this.getWordsByProficiency(sourceLanguage, targetLanguage, level, count));\n            case 1:\n            case "end":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function getRandomWords(_x0, _x1, _x10, _x11) {\n        return _getRandomWords.apply(this, arguments);\n      }\n      return getRandomWords;\n    }()\n    /**\n     * Check if a language pair is supported\n     */\n    )\n  }, {\n    key: "isLanguagePairSupported",\n    value: (function () {\n      var _isLanguagePairSupported = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee6(sourceLanguage, targetLanguage) {\n        return regenerator_default().wrap(function (_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt("return", this.translationAPI.isLanguagePairSupported(sourceLanguage, targetLanguage));\n            case 1:\n            case "end":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function isLanguagePairSupported(_x12, _x13) {\n        return _isLanguagePairSupported.apply(this, arguments);\n      }\n      return isLanguagePairSupported;\n    }()\n    /**\n     * Get database statistics\n     */\n    )\n  }, {\n    key: "getStats",\n    value: (function () {\n      var _getStats = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee7() {\n        var totalResult, pairsResult, languagePairs;\n        return regenerator_default().wrap(function (_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.next = 1;\n              return this.initialize();\n            case 1:\n              _context7.next = 2;\n              return this.db.getOne(\'SELECT COUNT(*) as count FROM word_list\');\n            case 2:\n              totalResult = _context7.sent;\n              _context7.next = 3;\n              return this.db.getAll("SELECT source_lang, target_lang, COUNT(*) as count \\n       FROM word_list \\n       GROUP BY source_lang, target_lang");\n            case 3:\n              pairsResult = _context7.sent;\n              languagePairs = pairsResult.map(function (row) {\n                return {\n                  source: row.source_lang,\n                  target: row.target_lang,\n                  count: row.count\n                };\n              });\n              return _context7.abrupt("return", {\n                totalCachedWords: (totalResult === null || totalResult === void 0 ? void 0 : totalResult.count) || 0,\n                languagePairs: languagePairs,\n                lastUpdated: new Date().toISOString()\n              });\n            case 4:\n            case "end":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function getStats() {\n        return _getStats.apply(this, arguments);\n      }\n      return getStats;\n    }()\n    /**\n     * Clear cached translations for a language pair\n     */\n    )\n  }, {\n    key: "clearCache",\n    value: (function () {\n      var _clearCache = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee8(sourceLanguage, targetLanguage) {\n        var prefix, _iterator5, _step5, key;\n        return regenerator_default().wrap(function (_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (!(sourceLanguage && targetLanguage)) {\n                _context8.next = 2;\n                break;\n              }\n              _context8.next = 1;\n              return this.db.execute(\'DELETE FROM word_list WHERE source_lang = ? AND target_lang = ?\', [sourceLanguage, targetLanguage]);\n            case 1:\n              // Clear memory cache for this pair\n              prefix = "".concat(sourceLanguage, "_").concat(targetLanguage, "_");\n              _iterator5 = DynamicWordDatabase_createForOfIteratorHelper(this.memoryCache.keys());\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  key = _step5.value;\n                  if (key.startsWith(prefix)) {\n                    this.memoryCache.delete(key);\n                  }\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n              _context8.next = 4;\n              break;\n            case 2:\n              _context8.next = 3;\n              return this.db.execute(\'DELETE FROM word_list\');\n            case 3:\n              this.memoryCache.clear();\n            case 4:\n            case "end":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function clearCache(_x14, _x15) {\n        return _clearCache.apply(this, arguments);\n      }\n      return clearCache;\n    }()\n    /**\n     * Pre-cache common words for a language pair\n     */\n    )\n  }, {\n    key: "preCacheCommonWords",\n    value: (function () {\n      var _preCacheCommonWords = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee9(sourceLanguage, targetLanguage) {\n        var count,\n          frequencyWords,\n          words,\n          results,\n          cached,\n          failed,\n          _iterator6,\n          _step6,\n          result,\n          _args9 = arguments;\n        return regenerator_default().wrap(function (_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              count = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : 500;\n              _context9.next = 1;\n              return this.frequencyService.getWordsByProficiency(sourceLanguage, \'beginner\');\n            case 1:\n              frequencyWords = _context9.sent;\n              words = frequencyWords.slice(0, count).map(function (w) {\n                return w.word;\n              });\n              if (!(words.length === 0)) {\n                _context9.next = 2;\n                break;\n              }\n              return _context9.abrupt("return", {\n                cached: 0,\n                failed: 0\n              });\n            case 2:\n              _context9.next = 3;\n              return this.lookupWords(words, sourceLanguage, targetLanguage);\n            case 3:\n              results = _context9.sent;\n              cached = 0;\n              failed = 0;\n              _iterator6 = DynamicWordDatabase_createForOfIteratorHelper(results.values());\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  result = _step6.value;\n                  if (result.entry) {\n                    cached++;\n                  } else {\n                    failed++;\n                  }\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n              return _context9.abrupt("return", {\n                cached: cached,\n                failed: failed\n              });\n            case 4:\n            case "end":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function preCacheCommonWords(_x16, _x17) {\n        return _preCacheCommonWords.apply(this, arguments);\n      }\n      return preCacheCommonWords;\n    }() // ============================================================================\n    // Private Methods\n    // ============================================================================\n    )\n  }, {\n    key: "getCacheKey",\n    value: function getCacheKey(word, source, target) {\n      return "".concat(source, "_").concat(target, "_").concat(word);\n    }\n  }, {\n    key: "lookupFromDatabase",\n    value: function () {\n      var _lookupFromDatabase = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee0(word, sourceLanguage, targetLanguage) {\n        var row;\n        return regenerator_default().wrap(function (_context0) {\n          while (1) switch (_context0.prev = _context0.next) {\n            case 0:\n              _context0.next = 1;\n              return this.db.getOne(DatabaseSchema.wordList.getByWord, [word, sourceLanguage, targetLanguage]);\n            case 1:\n              row = _context0.sent;\n              if (row) {\n                _context0.next = 2;\n                break;\n              }\n              return _context0.abrupt("return", null);\n            case 2:\n              return _context0.abrupt("return", this.rowToEntry(row));\n            case 3:\n            case "end":\n              return _context0.stop();\n          }\n        }, _callee0, this);\n      }));\n      function lookupFromDatabase(_x18, _x19, _x20) {\n        return _lookupFromDatabase.apply(this, arguments);\n      }\n      return lookupFromDatabase;\n    }()\n  }, {\n    key: "translateAndCache",\n    value: function () {\n      var _translateAndCache = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee1(word, sourceLanguage, targetLanguage) {\n        var result;\n        return regenerator_default().wrap(function (_context1) {\n          while (1) switch (_context1.prev = _context1.next) {\n            case 0:\n              _context1.next = 1;\n              return this.translationAPI.translate(word, sourceLanguage, targetLanguage);\n            case 1:\n              result = _context1.sent;\n              if (!result.translatedText) {\n                _context1.next = 2;\n                break;\n              }\n              return _context1.abrupt("return", this.createAndCacheEntry(word, result.translatedText, sourceLanguage, targetLanguage, result.provider));\n            case 2:\n              return _context1.abrupt("return", null);\n            case 3:\n            case "end":\n              return _context1.stop();\n          }\n        }, _callee1, this);\n      }));\n      function translateAndCache(_x21, _x22, _x23) {\n        return _translateAndCache.apply(this, arguments);\n      }\n      return translateAndCache;\n    }()\n  }, {\n    key: "createAndCacheEntry",\n    value: function () {\n      var _createAndCacheEntry = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee10(sourceWord, targetWord, sourceLanguage, targetLanguage, provider) {\n        var rank, proficiencyLevel, entry, _t5;\n        return regenerator_default().wrap(function (_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 1;\n              return this.frequencyService.getWordRank(sourceLanguage, sourceWord);\n            case 1:\n              rank = _context10.sent;\n              proficiencyLevel = rank ? this.frequencyService.getProficiencyLevel(rank) : \'intermediate\'; // Default to intermediate if no frequency data\n              entry = {\n                id: "".concat(sourceLanguage, "_").concat(targetLanguage, "_").concat(sourceWord),\n                sourceWord: sourceWord,\n                targetWord: targetWord,\n                sourceLanguage: sourceLanguage,\n                targetLanguage: targetLanguage,\n                proficiencyLevel: proficiencyLevel,\n                frequencyRank: rank || 1000,\n                // Default rank\n                partOfSpeech: \'other\',\n                variants: [],\n                isTranslated: true,\n                translationProvider: provider,\n                cachedAt: new Date().toISOString()\n              }; // Save to database\n              _context10.prev = 2;\n              _context10.next = 3;\n              return this.db.execute(DatabaseSchema.wordList.insert, [entry.id, entry.sourceWord, entry.targetWord, entry.sourceLanguage, entry.targetLanguage, entry.proficiencyLevel, entry.frequencyRank, entry.partOfSpeech, null,\n              // variants\n              null // pronunciation\n              ]);\n            case 3:\n              _context10.next = 5;\n              break;\n            case 4:\n              _context10.prev = 4;\n              _t5 = _context10["catch"](2);\n              // Entry might already exist, ignore duplicate error\n              if (!(_t5 instanceof Error && _t5.message.includes(\'UNIQUE\'))) {\n                console.warn(\'Failed to cache translation:\', _t5);\n              }\n            case 5:\n              return _context10.abrupt("return", entry);\n            case 6:\n            case "end":\n              return _context10.stop();\n          }\n        }, _callee10, this, [[2, 4]]);\n      }));\n      function createAndCacheEntry(_x24, _x25, _x26, _x27, _x28) {\n        return _createAndCacheEntry.apply(this, arguments);\n      }\n      return createAndCacheEntry;\n    }()\n  }, {\n    key: "getCachedWordsByLevel",\n    value: function () {\n      var _getCachedWordsByLevel = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee11(sourceLanguage, targetLanguage, level, limit) {\n        var _this = this;\n        var rows;\n        return regenerator_default().wrap(function (_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              _context11.next = 1;\n              return this.db.getAll("SELECT * FROM word_list \\n       WHERE source_lang = ? AND target_lang = ? AND proficiency = ?\\n       ORDER BY RANDOM() LIMIT ?", [sourceLanguage, targetLanguage, level, limit]);\n            case 1:\n              rows = _context11.sent;\n              return _context11.abrupt("return", rows.map(function (row) {\n                return _this.rowToEntry(row);\n              }));\n            case 2:\n            case "end":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function getCachedWordsByLevel(_x29, _x30, _x31, _x32) {\n        return _getCachedWordsByLevel.apply(this, arguments);\n      }\n      return getCachedWordsByLevel;\n    }()\n  }, {\n    key: "rowToEntry",\n    value: function rowToEntry(row) {\n      return {\n        id: row.id,\n        sourceWord: row.source_word,\n        targetWord: row.target_word,\n        sourceLanguage: row.source_lang,\n        targetLanguage: row.target_lang,\n        proficiencyLevel: row.proficiency,\n        frequencyRank: row.frequency_rank || 0,\n        partOfSpeech: row.part_of_speech || \'other\',\n        variants: row.variants ? JSON.parse(row.variants) : [],\n        pronunciation: row.pronunciation,\n        isTranslated: true\n      };\n    }\n  }]);\n}();\n\n// Export singleton instance\nvar dynamicWordDatabase = new DynamicWordDatabase();\n;// ../shared/src/services/BookParser/TextProcessingService.ts\n\n\n\n\n\nfunction TextProcessingService_createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = TextProcessingService_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\nfunction TextProcessingService_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return TextProcessingService_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? TextProcessingService_arrayLikeToArray(r, a) : void 0; } }\nfunction TextProcessingService_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n\nfunction TextProcessingService_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction TextProcessingService_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? TextProcessingService_ownKeys(Object(t), !0).forEach(function (r) { (0,defineProperty/* default */.A)(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : TextProcessingService_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/**\n * Text Processing Service\n *\n * Integrates tokenization, word matching, and replacement for EPUB content.\n * This is the main entry point for processing chapter text for foreign word display.\n *\n * Features:\n * - Extracts clean content from EPUB HTML\n * - Tokenizes text while preserving HTML structure\n * - Handles embedded CSS styles\n * - Processes images to base64\n * - Applies word replacements\n * - Maintains word positions for tap detection\n */\n\n\n\n\n\n// ============================================================================\n// Types\n// ============================================================================\n\n// ============================================================================\n// Text Processing Service Class\n// ============================================================================\n\nvar TextProcessingService = /*#__PURE__*/function () {\n  function TextProcessingService() {\n    (0,classCallCheck/* default */.A)(this, TextProcessingService);\n    (0,defineProperty/* default */.A)(this, "wordCache", new Map());\n    this.tokenizer = new Tokenizer();\n    this.wordReplacer = new WordReplacer();\n  }\n\n  /**\n   * Process chapter content and replace words with foreign equivalents\n   */\n  return (0,createClass/* default */.A)(TextProcessingService, [{\n    key: "processChapter",\n    value: (function () {\n      var _processChapter = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee(chapter, options) {\n        var _options$skipQuotes, _options$skipNames, _options$minWordSpaci, _options$selectionStr;\n        var startTime, extracted, tokens, uniqueWords, _yield$this$lookupWor, wordEntries, lookups, hits, result, processingTimeMs;\n        return regenerator_default().wrap(function (_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              startTime = Date.now(); // Extract clean HTML from chapter content\n              extracted = this.extractContent(chapter.content); // Update tokenizer options\n              this.tokenizer.updateOptions({\n                skipQuotes: (_options$skipQuotes = options.skipQuotes) !== null && _options$skipQuotes !== void 0 ? _options$skipQuotes : true,\n                skipNames: (_options$skipNames = options.skipNames) !== null && _options$skipNames !== void 0 ? _options$skipNames : true,\n                skipWords: new Set(options.excludeWords)\n              });\n\n              // Tokenize the content\n              tokens = this.tokenizer.tokenize(extracted.body); // Get unique words for database lookup\n              uniqueWords = Tokenizer.getUniqueWords(tokens); // Look up words in database\n              _context.next = 1;\n              return this.lookupWords(uniqueWords, options.sourceLanguage, options.targetLanguage);\n            case 1:\n              _yield$this$lookupWor = _context.sent;\n              wordEntries = _yield$this$lookupWor.wordEntries;\n              lookups = _yield$this$lookupWor.lookups;\n              hits = _yield$this$lookupWor.hits;\n              // Update replacer options\n              this.wordReplacer.updateOptions({\n                density: options.density,\n                maxProficiency: options.proficiencyLevel,\n                minWordSpacing: (_options$minWordSpaci = options.minWordSpacing) !== null && _options$minWordSpaci !== void 0 ? _options$minWordSpaci : 3,\n                selectionStrategy: (_options$selectionStr = options.selectionStrategy) !== null && _options$selectionStr !== void 0 ? _options$selectionStr : \'distributed\',\n                excludeWords: new Set(options.excludeWords)\n              });\n\n              // Perform word replacement\n              result = this.wordReplacer.replace(extracted.body, tokens, wordEntries);\n              processingTimeMs = Date.now() - startTime;\n              return _context.abrupt("return", {\n                html: result.html,\n                foreignWords: result.foreignWords,\n                tokens: tokens,\n                uniqueWords: uniqueWords,\n                stats: TextProcessingService_objectSpread(TextProcessingService_objectSpread({}, result.stats), {}, {\n                  processingTimeMs: processingTimeMs,\n                  uniqueWordCount: uniqueWords.length,\n                  databaseLookups: lookups,\n                  databaseHits: hits\n                })\n              });\n            case 2:\n            case "end":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function processChapter(_x, _x2) {\n        return _processChapter.apply(this, arguments);\n      }\n      return processChapter;\n    }()\n    /**\n     * Extract clean content from EPUB HTML\n     */\n    )\n  }, {\n    key: "extractContent",\n    value: function extractContent(html) {\n      var result = {\n        body: \'\',\n        styles: []\n      };\n\n      // Extract title\n      var titleMatch = html.match(/<title[^>]*>([\\s\\S]*?)<\\/title>/i);\n      if (titleMatch) {\n        result.title = this.decodeHtmlEntities(titleMatch[1].trim());\n      }\n\n      // Extract language\n      var langMatch = html.match(/<html[^>]*\\slang=["\']([^"\']+)["\']/i);\n      if (langMatch) {\n        result.language = langMatch[1];\n      }\n\n      // Extract styles from <style> tags\n      var styleRegex = /<style[^>]*>([\\s\\S]*?)<\\/style>/gi;\n      var styleMatch;\n      while ((styleMatch = styleRegex.exec(html)) !== null) {\n        result.styles.push(styleMatch[1]);\n      }\n\n      // Extract linked stylesheets (just the references, actual content handled elsewhere)\n      var linkRegex = /<link[^>]*rel=["\']stylesheet["\'][^>]*href=["\']([^"\']+)["\'][^>]*>/gi;\n      // Note: We\'d need the EPUB context to resolve these, skipping for now\n\n      // Extract body content\n      var bodyMatch = html.match(/<body[^>]*>([\\s\\S]*?)<\\/body>/i);\n      if (bodyMatch) {\n        result.body = bodyMatch[1];\n      } else {\n        // If no body tag, try to extract content after </head> or use entire content\n        var afterHeadMatch = html.match(/<\\/head>\\s*([\\s\\S]*?)$/i);\n        if (afterHeadMatch) {\n          // Remove closing tags\n          result.body = afterHeadMatch[1].replace(/<\\/html>\\s*$/i, \'\').trim();\n        } else {\n          // No head either, strip doctype and html wrapper\n          result.body = html.replace(/<!DOCTYPE[^>]*>/i, \'\').replace(/<\\/?html[^>]*>/gi, \'\').replace(/<head[^>]*>[\\s\\S]*?<\\/head>/i, \'\').trim();\n        }\n      }\n\n      // Clean up the body content\n      result.body = this.cleanBodyContent(result.body);\n      return result;\n    }\n\n    /**\n     * Clean up body content for processing\n     */\n  }, {\n    key: "cleanBodyContent",\n    value: function cleanBodyContent(html) {\n      return html\n      // Remove XML processing instructions\n      .replace(/<\\?xml[^?]*\\?>/gi, \'\')\n      // Normalize whitespace in text nodes (but preserve structure)\n      .replace(/>\\s+</g, \'> <\')\n      // Remove empty paragraphs\n      .replace(/<p[^>]*>\\s*<\\/p>/gi, \'\')\n      // Normalize line breaks\n      .replace(/\\r\\n/g, \'\\n\').replace(/\\r/g, \'\\n\')\n      // Remove excessive blank lines\n      .replace(/\\n{3,}/g, \'\\n\\n\').trim();\n    }\n\n    /**\n     * Decode HTML entities\n     */\n  }, {\n    key: "decodeHtmlEntities",\n    value: function decodeHtmlEntities(text) {\n      var entities = {\n        \'&amp;\': \'&\',\n        \'&lt;\': \'<\',\n        \'&gt;\': \'>\',\n        \'&quot;\': \'"\',\n        \'&#39;\': "\'",\n        \'&apos;\': "\'",\n        \'&nbsp;\': \' \',\n        \'&mdash;\': \'\',\n        \'&ndash;\': \'\',\n        \'&hellip;\': \'\',\n        \'&lsquo;\': "\\u2018",\n        \'&rsquo;\': "\\u2019",\n        \'&ldquo;\': "\\u201C",\n        \'&rdquo;\': "\\u201D"\n      };\n      var decoded = text;\n      for (var _i = 0, _Object$entries = Object.entries(entities); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = (0,slicedToArray/* default */.A)(_Object$entries[_i], 2),\n          entity = _Object$entries$_i[0],\n          char = _Object$entries$_i[1];\n        decoded = decoded.replace(new RegExp(entity, \'g\'), char);\n      }\n\n      // Handle numeric entities\n      decoded = decoded.replace(/&#(\\d+);/g, function (_, code) {\n        return String.fromCharCode(parseInt(code, 10));\n      });\n      decoded = decoded.replace(/&#x([0-9a-f]+);/gi, function (_, code) {\n        return String.fromCharCode(parseInt(code, 16));\n      });\n      return decoded;\n    }\n\n    /**\n     * Look up words in the dynamic word database\n     */\n  }, {\n    key: "lookupWords",\n    value: (function () {\n      var _lookupWords = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee2(words, sourceLanguage, targetLanguage) {\n        var wordEntries, lookups, hits, _iterator, _step, word, cacheKey, cached, result, entry, _t, _t2;\n        return regenerator_default().wrap(function (_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              wordEntries = new Map();\n              lookups = 0;\n              hits = 0;\n              _iterator = TextProcessingService_createForOfIteratorHelper(words);\n              _context2.prev = 1;\n              _iterator.s();\n            case 2:\n              if ((_step = _iterator.n()).done) {\n                _context2.next = 8;\n                break;\n              }\n              word = _step.value;\n              // Check cache first\n              cacheKey = "".concat(sourceLanguage, ":").concat(targetLanguage, ":").concat(word);\n              if (!this.wordCache.has(cacheKey)) {\n                _context2.next = 3;\n                break;\n              }\n              cached = this.wordCache.get(cacheKey);\n              wordEntries.set(word, cached !== null && cached !== void 0 ? cached : null);\n              if (cached) hits++;\n              return _context2.abrupt("continue", 7);\n            case 3:\n              lookups++;\n              _context2.prev = 4;\n              _context2.next = 5;\n              return dynamicWordDatabase.lookupWord(word, sourceLanguage, targetLanguage);\n            case 5:\n              result = _context2.sent;\n              if (result) {\n                entry = {\n                  id: result.id,\n                  sourceWord: result.sourceWord,\n                  targetWord: result.targetWord,\n                  sourceLanguage: sourceLanguage,\n                  targetLanguage: targetLanguage,\n                  proficiencyLevel: result.proficiencyLevel,\n                  frequencyRank: result.frequencyRank,\n                  partOfSpeech: result.partOfSpeech || \'unknown\',\n                  pronunciation: result.pronunciation,\n                  variants: result.variants\n                };\n                wordEntries.set(word, entry);\n                this.wordCache.set(cacheKey, entry);\n                hits++;\n              } else {\n                wordEntries.set(word, null);\n                this.wordCache.set(cacheKey, null);\n              }\n              _context2.next = 7;\n              break;\n            case 6:\n              _context2.prev = 6;\n              _t = _context2["catch"](4);\n              console.warn("Failed to lookup word \\"".concat(word, "\\":"), _t);\n              wordEntries.set(word, null);\n            case 7:\n              _context2.next = 2;\n              break;\n            case 8:\n              _context2.next = 10;\n              break;\n            case 9:\n              _context2.prev = 9;\n              _t2 = _context2["catch"](1);\n              _iterator.e(_t2);\n            case 10:\n              _context2.prev = 10;\n              _iterator.f();\n              return _context2.finish(10);\n            case 11:\n              return _context2.abrupt("return", {\n                wordEntries: wordEntries,\n                lookups: lookups,\n                hits: hits\n              });\n            case 12:\n            case "end":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[1, 9, 10, 11], [4, 6]]);\n      }));\n      function lookupWords(_x3, _x4, _x5) {\n        return _lookupWords.apply(this, arguments);\n      }\n      return lookupWords;\n    }()\n    /**\n     * Get word at a specific position in the original content\n     */\n    )\n  }, {\n    key: "getWordAtPosition",\n    value: function getWordAtPosition(tokens, position) {\n      var _iterator2 = TextProcessingService_createForOfIteratorHelper(tokens),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var token = _step2.value;\n          if (position >= token.startIndex && position <= token.endIndex) {\n            return token;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return null;\n    }\n\n    /**\n     * Get words in a range of positions\n     */\n  }, {\n    key: "getWordsInRange",\n    value: function getWordsInRange(tokens, start, end) {\n      return tokens.filter(function (token) {\n        return token.startIndex >= start && token.endIndex <= end;\n      });\n    }\n\n    /**\n     * Get context around a word (surrounding sentence)\n     */\n  }, {\n    key: "getWordContext",\n    value: function getWordContext(html, token) {\n      var contextLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n      var plainText = this.stripHtml(html);\n\n      // Find approximate position in plain text\n      // This is a simplification; in practice you\'d need proper position mapping\n      var wordPos = plainText.toLowerCase().indexOf(token.word.toLowerCase());\n      if (wordPos === -1) {\n        return \'\';\n      }\n      var start = Math.max(0, wordPos - contextLength);\n      var end = Math.min(plainText.length, wordPos + token.word.length + contextLength);\n      var context = plainText.substring(start, end);\n\n      // Try to extend to sentence boundaries\n      var sentenceStart = context.lastIndexOf(\'.\', wordPos - start);\n      var sentenceEnd = context.indexOf(\'.\', wordPos - start + token.word.length);\n      if (sentenceStart !== -1 && sentenceEnd !== -1) {\n        context = context.substring(sentenceStart + 1, sentenceEnd + 1).trim();\n      }\n      return (start > 0 ? \'...\' : \'\') + context + (end < plainText.length ? \'...\' : \'\');\n    }\n\n    /**\n     * Strip HTML tags from content\n     */\n  }, {\n    key: "stripHtml",\n    value: function stripHtml(html) {\n      return html.replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, \'\').replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, \'\').replace(/<[^>]+>/g, \' \').replace(/\\s+/g, \' \').trim();\n    }\n\n    /**\n     * Clear the word cache\n     */\n  }, {\n    key: "clearCache",\n    value: function clearCache() {\n      this.wordCache.clear();\n    }\n\n    /**\n     * Get cache statistics\n     */\n  }, {\n    key: "getCacheStats",\n    value: function getCacheStats() {\n      var size = this.wordCache.size;\n      // Rough estimate: ~200 bytes per entry\n      var memoryEstimate = size * 200;\n      return {\n        size: size,\n        memoryEstimate: memoryEstimate\n      };\n    }\n  }]);\n}();\n\n// ============================================================================\n// Export singleton instance\n// ============================================================================\n\nvar textProcessingService = new TextProcessingService();\n// EXTERNAL MODULE: ../shared/src/services/BookParser/EPUBExtractor.ts\nvar EPUBExtractor = __webpack_require__(2611);\n// EXTERNAL MODULE: ../shared/src/services/BookParser/TOCParser.ts\nvar TOCParser = __webpack_require__(9592);\n// EXTERNAL MODULE: ./src/mocks/react-native-fs.electron.ts\nvar react_native_fs_electron = __webpack_require__(4978);\n;// ../shared/src/services/BookParser/MetadataExtractor.ts\n\n\n\n\nfunction MetadataExtractor_createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = MetadataExtractor_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\nfunction MetadataExtractor_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return MetadataExtractor_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? MetadataExtractor_arrayLikeToArray(r, a) : void 0; } }\nfunction MetadataExtractor_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n\n/**\n * Metadata Extractor\n *\n * High-level utility for extracting complete metadata from EPUB files.\n * Combines EPUBExtractor with TOC parsing to provide a unified API.\n */\n\n\n\n\n\n// ============================================================================\n// Types\n// ============================================================================\n\n// ============================================================================\n// Metadata Extractor Class\n// ============================================================================\n\nvar MetadataExtractor = /*#__PURE__*/function () {\n  function MetadataExtractor() {\n    (0,classCallCheck/* default */.A)(this, MetadataExtractor);\n    (0,defineProperty/* default */.A)(this, "epubPackage", null);\n    (0,defineProperty/* default */.A)(this, "filePath", \'\');\n    this.extractor = new EPUBExtractor/* EPUBExtractor */.D();\n  }\n\n  /**\n   * Extract complete metadata from an EPUB file\n   */\n  return (0,createClass/* default */.A)(MetadataExtractor, [{\n    key: "extractFromFile",\n    value: (function () {\n      var _extractFromFile = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee(filePath) {\n        var container, tocResult, metadata, chapterCount;\n        return regenerator_default().wrap(function (_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              this.filePath = filePath;\n\n              // Load the EPUB\n              _context.next = 1;\n              return this.extractor.load(filePath);\n            case 1:\n              _context.next = 2;\n              return this.extractor.parseContainer();\n            case 2:\n              container = _context.sent;\n              _context.next = 3;\n              return this.extractor.parsePackage(container.rootFilePath);\n            case 3:\n              this.epubPackage = _context.sent;\n              _context.next = 4;\n              return this.extractTableOfContents();\n            case 4:\n              tocResult = _context.sent;\n              // Build metadata object\n              metadata = {\n                title: this.epubPackage.metadata.title,\n                author: this.epubPackage.metadata.creator,\n                description: this.epubPackage.metadata.description,\n                publisher: this.epubPackage.metadata.publisher,\n                publishDate: this.epubPackage.metadata.date,\n                isbn: this.extractISBN(this.epubPackage.metadata.identifier),\n                subjects: this.epubPackage.metadata.subject\n              }; // Count chapters (spine items)\n              chapterCount = this.epubPackage.spine.filter(function (item) {\n                return item.linear;\n              }).length;\n              return _context.abrupt("return", {\n                metadata: metadata,\n                tableOfContents: tocResult.items,\n                chapterCount: chapterCount,\n                epubVersion: this.epubPackage.version,\n                language: this.epubPackage.metadata.language\n              });\n            case 5:\n            case "end":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function extractFromFile(_x) {\n        return _extractFromFile.apply(this, arguments);\n      }\n      return extractFromFile;\n    }()\n    /**\n     * Extract and save cover image\n     */\n    )\n  }, {\n    key: "extractCover",\n    value: (function () {\n      var _extractCover = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee2(outputDir) {\n        var coverId, coverItem, base64Data, extension, fileName, outputPath, _t;\n        return regenerator_default().wrap(function (_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (this.epubPackage) {\n                _context2.next = 1;\n                break;\n              }\n              throw new Error(\'EPUB not loaded. Call extractFromFile first.\');\n            case 1:\n              coverId = this.epubPackage.coverImageId;\n              if (coverId) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt("return", null);\n            case 2:\n              coverItem = this.epubPackage.manifest.get(coverId);\n              if (coverItem) {\n                _context2.next = 3;\n                break;\n              }\n              return _context2.abrupt("return", null);\n            case 3:\n              _context2.prev = 3;\n              _context2.next = 4;\n              return this.extractor.getBase64File(coverItem.href);\n            case 4:\n              base64Data = _context2.sent;\n              // Determine file extension\n              extension = this.getImageExtension(coverItem.mediaType);\n              fileName = "cover.".concat(extension);\n              outputPath = "".concat(outputDir, "/").concat(fileName); // Ensure output directory exists\n              _context2.next = 5;\n              return react_native_fs_electron["default"].mkdir(outputDir);\n            case 5:\n              _context2.next = 6;\n              return react_native_fs_electron["default"].writeFile(outputPath, base64Data, \'base64\');\n            case 6:\n              return _context2.abrupt("return", outputPath);\n            case 7:\n              _context2.prev = 7;\n              _t = _context2["catch"](3);\n              console.warn(\'Failed to extract cover image:\', _t);\n              return _context2.abrupt("return", null);\n            case 8:\n            case "end":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[3, 7]]);\n      }));\n      function extractCover(_x2) {\n        return _extractCover.apply(this, arguments);\n      }\n      return extractCover;\n    }()\n    /**\n     * Get cover image as base64 (for preview without saving)\n     */\n    )\n  }, {\n    key: "getCoverBase64",\n    value: (function () {\n      var _getCoverBase = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee3() {\n        var coverId, coverItem, base64Data, extension, _t2;\n        return regenerator_default().wrap(function (_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (this.epubPackage) {\n                _context3.next = 1;\n                break;\n              }\n              throw new Error(\'EPUB not loaded. Call extractFromFile first.\');\n            case 1:\n              coverId = this.epubPackage.coverImageId;\n              if (coverId) {\n                _context3.next = 2;\n                break;\n              }\n              return _context3.abrupt("return", null);\n            case 2:\n              coverItem = this.epubPackage.manifest.get(coverId);\n              if (coverItem) {\n                _context3.next = 3;\n                break;\n              }\n              return _context3.abrupt("return", null);\n            case 3:\n              _context3.prev = 3;\n              _context3.next = 4;\n              return this.extractor.getBase64File(coverItem.href);\n            case 4:\n              base64Data = _context3.sent;\n              extension = this.getImageExtension(coverItem.mediaType);\n              return _context3.abrupt("return", {\n                base64Data: base64Data,\n                mimeType: coverItem.mediaType,\n                fileName: "cover.".concat(extension)\n              });\n            case 5:\n              _context3.prev = 5;\n              _t2 = _context3["catch"](3);\n              console.warn(\'Failed to get cover image:\', _t2);\n              return _context3.abrupt("return", null);\n            case 6:\n            case "end":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[3, 5]]);\n      }));\n      function getCoverBase64() {\n        return _getCoverBase.apply(this, arguments);\n      }\n      return getCoverBase64;\n    }()\n    /**\n     * Extract table of contents\n     */\n    )\n  }, {\n    key: "extractTableOfContents",\n    value: (function () {\n      var _extractTableOfContents = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee4() {\n        var tocId, tocItem, tocContent, _t3;\n        return regenerator_default().wrap(function (_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (this.epubPackage) {\n                _context4.next = 1;\n                break;\n              }\n              return _context4.abrupt("return", {\n                items: []\n              });\n            case 1:\n              tocId = this.epubPackage.tocId;\n              if (tocId) {\n                _context4.next = 2;\n                break;\n              }\n              return _context4.abrupt("return", this.generateTOCFromSpine());\n            case 2:\n              tocItem = this.epubPackage.manifest.get(tocId);\n              if (tocItem) {\n                _context4.next = 3;\n                break;\n              }\n              return _context4.abrupt("return", this.generateTOCFromSpine());\n            case 3:\n              _context4.prev = 3;\n              _context4.next = 4;\n              return this.extractor.getFile(tocItem.href);\n            case 4:\n              tocContent = _context4.sent;\n              if (!(tocItem.mediaType === \'application/x-dtbncx+xml\' || tocItem.href.endsWith(\'.ncx\'))) {\n                _context4.next = 5;\n                break;\n              }\n              return _context4.abrupt("return", (0,TOCParser/* parseNCX */.rD)(tocContent));\n            case 5:\n              return _context4.abrupt("return", (0,TOCParser/* parseNAV */.LH)(tocContent));\n            case 6:\n              _context4.next = 8;\n              break;\n            case 7:\n              _context4.prev = 7;\n              _t3 = _context4["catch"](3);\n              console.warn(\'Failed to parse TOC, generating from spine:\', _t3);\n              return _context4.abrupt("return", this.generateTOCFromSpine());\n            case 8:\n            case "end":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[3, 7]]);\n      }));\n      function extractTableOfContents() {\n        return _extractTableOfContents.apply(this, arguments);\n      }\n      return extractTableOfContents;\n    }()\n    /**\n     * Generate a basic TOC from the spine when no proper TOC exists\n     */\n    )\n  }, {\n    key: "generateTOCFromSpine",\n    value: function generateTOCFromSpine() {\n      var _this = this;\n      if (!this.epubPackage) {\n        return {\n          items: []\n        };\n      }\n      var items = [];\n      this.epubPackage.spine.forEach(function (spineItem, index) {\n        if (!spineItem.linear) return;\n        var manifestItem = _this.epubPackage.manifest.get(spineItem.idref);\n        if (manifestItem) {\n          items.push({\n            id: spineItem.idref,\n            title: "Chapter ".concat(index + 1),\n            href: manifestItem.href,\n            level: 0\n          });\n        }\n      });\n      return {\n        items: items\n      };\n    }\n\n    /**\n     * Get ordered list of content files from spine\n     */\n  }, {\n    key: "getSpineItems",\n    value: function getSpineItems() {\n      if (!this.epubPackage) {\n        return [];\n      }\n      var items = [];\n      var _iterator = MetadataExtractor_createForOfIteratorHelper(this.epubPackage.spine),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var spineItem = _step.value;\n          var manifestItem = this.epubPackage.manifest.get(spineItem.idref);\n          if (manifestItem) {\n            items.push(manifestItem);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return items;\n    }\n\n    /**\n     * Get content of a chapter by href\n     */\n  }, {\n    key: "getChapterContent",\n    value: (function () {\n      var _getChapterContent = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee5(href) {\n        return regenerator_default().wrap(function (_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              return _context5.abrupt("return", this.extractor.getFile(href));\n            case 1:\n            case "end":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function getChapterContent(_x3) {\n        return _getChapterContent.apply(this, arguments);\n      }\n      return getChapterContent;\n    }()\n    /**\n     * Extract ISBN from identifier if present\n     */\n    )\n  }, {\n    key: "extractISBN",\n    value: function extractISBN(identifier) {\n      if (!identifier) return undefined;\n\n      // Try to extract ISBN-10 or ISBN-13\n      var isbn13Match = identifier.match(/(?:ISBN[:\\s-]?)?(\\d{13})/i);\n      if (isbn13Match) return isbn13Match[1];\n      var isbn10Match = identifier.match(/(?:ISBN[:\\s-]?)?(\\d{9}[\\dXx])/i);\n      if (isbn10Match) return isbn10Match[1];\n\n      // If it looks like a URN, try to extract ISBN\n      var urnMatch = identifier.match(/urn:isbn:(\\d{10}|\\d{13})/i);\n      if (urnMatch) return urnMatch[1];\n      return undefined;\n    }\n\n    /**\n     * Get image file extension from MIME type\n     */\n  }, {\n    key: "getImageExtension",\n    value: function getImageExtension(mimeType) {\n      var mimeToExt = {\n        \'image/jpeg\': \'jpg\',\n        \'image/jpg\': \'jpg\',\n        \'image/png\': \'png\',\n        \'image/gif\': \'gif\',\n        \'image/svg+xml\': \'svg\',\n        \'image/webp\': \'webp\'\n      };\n      return mimeToExt[mimeType.toLowerCase()] || \'jpg\';\n    }\n\n    /**\n     * Clean up resources\n     */\n  }, {\n    key: "dispose",\n    value: function dispose() {\n      this.extractor.dispose();\n      this.epubPackage = null;\n      this.filePath = \'\';\n    }\n  }]);\n}();\n\n// ============================================================================\n// Quick Extraction Functions\n// ============================================================================\n\n/**\n * Quick function to extract just the basic metadata\n */\nfunction extractEPUBMetadata(_x4) {\n  return _extractEPUBMetadata.apply(this, arguments);\n}\n\n/**\n * Quick function to extract metadata and TOC\n */\nfunction _extractEPUBMetadata() {\n  _extractEPUBMetadata = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee6(filePath) {\n    var extractor, result;\n    return regenerator_default().wrap(function (_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          extractor = new MetadataExtractor();\n          _context6.prev = 1;\n          _context6.next = 2;\n          return extractor.extractFromFile(filePath);\n        case 2:\n          result = _context6.sent;\n          return _context6.abrupt("return", result.metadata);\n        case 3:\n          _context6.prev = 3;\n          extractor.dispose();\n          return _context6.finish(3);\n        case 4:\n        case "end":\n          return _context6.stop();\n      }\n    }, _callee6, null, [[1,, 3, 4]]);\n  }));\n  return _extractEPUBMetadata.apply(this, arguments);\n}\nfunction extractEPUBInfo(_x5) {\n  return _extractEPUBInfo.apply(this, arguments);\n}\n\n/**\n * Quick function to extract cover image\n */\nfunction _extractEPUBInfo() {\n  _extractEPUBInfo = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee7(filePath) {\n    var extractor;\n    return regenerator_default().wrap(function (_context7) {\n      while (1) switch (_context7.prev = _context7.next) {\n        case 0:\n          extractor = new MetadataExtractor();\n          _context7.prev = 1;\n          _context7.next = 2;\n          return extractor.extractFromFile(filePath);\n        case 2:\n          return _context7.abrupt("return", _context7.sent);\n        case 3:\n          _context7.prev = 3;\n          extractor.dispose();\n          return _context7.finish(3);\n        case 4:\n        case "end":\n          return _context7.stop();\n      }\n    }, _callee7, null, [[1,, 3, 4]]);\n  }));\n  return _extractEPUBInfo.apply(this, arguments);\n}\nfunction extractEPUBCover(_x6, _x7) {\n  return _extractEPUBCover.apply(this, arguments);\n}\nfunction _extractEPUBCover() {\n  _extractEPUBCover = (0,asyncToGenerator/* default */.A)(/*#__PURE__*/regenerator_default().mark(function _callee8(filePath, outputDir) {\n    var extractor;\n    return regenerator_default().wrap(function (_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          extractor = new MetadataExtractor();\n          _context8.prev = 1;\n          _context8.next = 2;\n          return extractor.extractFromFile(filePath);\n        case 2:\n          _context8.next = 3;\n          return extractor.extractCover(outputDir);\n        case 3:\n          return _context8.abrupt("return", _context8.sent);\n        case 4:\n          _context8.prev = 4;\n          extractor.dispose();\n          return _context8.finish(4);\n        case 5:\n        case "end":\n          return _context8.stop();\n      }\n    }, _callee8, null, [[1,, 4, 5]]);\n  }));\n  return _extractEPUBCover.apply(this, arguments);\n}\n;// ../shared/src/services/BookParser/index.ts\n/**\n * Book Parser Service - Parses various e-book formats\n */\n\n// Main service and parser\n\n\n\n\n\n\n// Chapter content service\n\n// Text processing service (tokenization, word replacement)\n\n// Low-level utilities\n\n// TOC parsing\n\n// Metadata extraction\n\n\n// Types//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsMEJBQUEsQ0FYTSxTQUFBa0YsU0FDTHlULFFBQWdCLEVBQ2hCK0IsU0FBaUI7SUFBQSxJQUFBakMsU0FBQTtJQUFBLE9BQUF6WSwwQkFBQSxXQUFBcUYsU0FBQTtNQUFBLGtCQUFBQSxTQUFBLENBQUE3RSxJQUFBLEdBQUE2RSxTQUFBLENBQUE1RSxJQUFBO1FBQUE7VUFFWGdZLFNBQVMsR0FBRyxJQUFJRCxpQkFBaUIsQ0FBQyxDQUFDO1VBQUFuVCxTQUFBLENBQUE3RSxJQUFBO1VBQUE2RSxTQUFBLENBQUE1RSxJQUFBO1VBQUEsT0FFakNnWSxTQUFTLENBQUMrQixlQUFlLENBQUM3QixRQUFRLENBQUM7UUFBQTtVQUFBdFQsU0FBQSxDQUFBNUUsSUFBQTtVQUFBLE9BQzVCZ1ksU0FBUyxDQUFDZ0QsWUFBWSxDQUFDZixTQUFTLENBQUM7UUFBQTtVQUFBLE9BQUFyVixTQUFBLENBQUExRSxNQUFBLFdBQUEwRSxTQUFBLENBQUF4RSxJQUFBO1FBQUE7VUFBQXdFLFNBQUEsQ0FBQTdFLElBQUE7VUFFOUNpWSxTQUFTLENBQUNxRSxPQUFPLENBQUMsQ0FBQztVQUFDLE9BQUF6WCxTQUFBLENBQUF6QyxNQUFBO1FBQUE7UUFBQTtVQUFBLE9BQUF5QyxTQUFBLENBQUFyRSxJQUFBO01BQUE7SUFBQSxHQUFBa0UsUUFBQTtFQUFBLENBRXZCO0VBQUEsT0FBQWtZLGlCQUFBLENBQUFqcUIsS0FBQSxPQUFBL0IsU0FBQTtBQUFBLEM7O0FDaldEO0FBQ0E7QUFDQTs7QUFFQTtBQUNzRDtBQUNkO0FBQ0Y7QUFDQTtBQUNFOztBQUV4QztBQUNxRjtBQUdyRjtBQUNxRjtBQVFyRjtBQUM4QztBQVM5QztBQUM2RjtBQUc3RjtBQU02Qjs7QUFHN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly94ZW5vbGV4aWEtZGVza3RvcC8uLi9zaGFyZWQvc3JjL3NlcnZpY2VzL1RyYW5zbGF0aW9uRW5naW5lL1Rva2VuaXplci50cz83OTI5Iiwid2VicGFjazovL3hlbm9sZXhpYS1kZXNrdG9wLy4uL3NoYXJlZC9zcmMvc2VydmljZXMvVHJhbnNsYXRpb25FbmdpbmUvV29yZFJlcGxhY2VyLnRzPzcxYjkiLCJ3ZWJwYWNrOi8veGVub2xleGlhLWRlc2t0b3AvLi4vc2hhcmVkL3NyYy9zZXJ2aWNlcy9TdG9yYWdlU2VydmljZS9EYXRhYmFzZVNjaGVtYS50cz84OGY3Iiwid2VicGFjazovL3hlbm9sZXhpYS1kZXNrdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9tZXJnZS1vcHRpb25zL2luZGV4Lm1qcz81OGY1Iiwid2VicGFjazovL3hlbm9sZXhpYS1kZXNrdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9AcmVhY3QtbmF0aXZlLWFzeW5jLXN0b3JhZ2UvYXN5bmMtc3RvcmFnZS9saWIvbW9kdWxlL0FzeW5jU3RvcmFnZS5qcz9lNWI0Iiwid2VicGFjazovL3hlbm9sZXhpYS1kZXNrdG9wLy4uLy4uL25vZGVfbW9kdWxlcy9AcmVhY3QtbmF0aXZlLWFzeW5jLXN0b3JhZ2UvYXN5bmMtc3RvcmFnZS9saWIvbW9kdWxlL2hvb2tzLmpzPzc0OTQiLCJ3ZWJwYWNrOi8veGVub2xleGlhLWRlc2t0b3AvLi4vLi4vbm9kZV9tb2R1bGVzL0ByZWFjdC1uYXRpdmUtYXN5bmMtc3RvcmFnZS9hc3luYy1zdG9yYWdlL2xpYi9tb2R1bGUvaW5kZXguanM/MzA0OSIsIndlYnBhY2s6Ly94ZW5vbGV4aWEtZGVza3RvcC8uLi9zaGFyZWQvc3JjL3NlcnZpY2VzL1RyYW5zbGF0aW9uRW5naW5lL0ZyZXF1ZW5jeUxpc3RTZXJ2aWNlLnRzPzZiNzAiLCJ3ZWJwYWNrOi8veGVub2xleGlhLWRlc2t0b3AvLi4vc2hhcmVkL3NyYy9zZXJ2aWNlcy9UcmFuc2xhdGlvbkVuZ2luZS9UcmFuc2xhdGlvbkFQSVNlcnZpY2UudHM/ZWM4NyIsIndlYnBhY2s6Ly94ZW5vbGV4aWEtZGVza3RvcC8uLi9zaGFyZWQvc3JjL3NlcnZpY2VzL1RyYW5zbGF0aW9uRW5naW5lL0R5bmFtaWNXb3JkRGF0YWJhc2UudHM/N2JiYiIsIndlYnBhY2s6Ly94ZW5vbGV4aWEtZGVza3RvcC8uLi9zaGFyZWQvc3JjL3NlcnZpY2VzL0Jvb2tQYXJzZXIvVGV4dFByb2Nlc3NpbmdTZXJ2aWNlLnRzPzM3MjQiLCJ3ZWJwYWNrOi8veGVub2xleGlhLWRlc2t0b3AvLi4vc2hhcmVkL3NyYy9zZXJ2aWNlcy9Cb29rUGFyc2VyL01ldGFkYXRhRXh0cmFjdG9yLnRzP2E0YTgiLCJ3ZWJwYWNrOi8veGVub2xleGlhLWRlc2t0b3AvLi4vc2hhcmVkL3NyYy9zZXJ2aWNlcy9Cb29rUGFyc2VyL2luZGV4LnRzP2RhN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUb2tlbml6ZXIgLSBFeHRyYWN0cyB3b3JkcyBmcm9tIEhUTUwgd2hpbGUgcHJlc2VydmluZyBzdHJ1Y3R1cmVcbiAqXG4gKiBGZWF0dXJlczpcbiAqIC0gUHJlc2VydmVzIEhUTUwgdGFncyBhbmQgc3RydWN0dXJlXG4gKiAtIEhhbmRsZXMgcHVuY3R1YXRpb24gYXR0YWNoZWQgdG8gd29yZHNcbiAqIC0gSWRlbnRpZmllcyB3b3JkIGJvdW5kYXJpZXMgY29ycmVjdGx5XG4gKiAtIFN1cHBvcnRzIFVuaWNvZGUgY2hhcmFjdGVycyBmb3Igbm9uLUxhdGluIHNjcmlwdHNcbiAqIC0gU2tpcHMgY29udGVudCB0aGF0IHNob3VsZG4ndCBiZSB0cmFuc2xhdGVkIChjb2RlLCBzY3JpcHRzLCBzdHlsZXMpXG4gKi9cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVHlwZXNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBUb2tlbiB7XG4gIC8qKiBUaGUgZXh0cmFjdGVkIHdvcmQgKGxvd2VyY2FzZSwgbm9ybWFsaXplZCkgKi9cbiAgd29yZDogc3RyaW5nO1xuICAvKiogT3JpZ2luYWwgdGV4dCBhcyBmb3VuZCBpbiBzb3VyY2UgKi9cbiAgb3JpZ2luYWw6IHN0cmluZztcbiAgLyoqIFN0YXJ0IHBvc2l0aW9uIGluIHRoZSBvcmlnaW5hbCBIVE1MICovXG4gIHN0YXJ0SW5kZXg6IG51bWJlcjtcbiAgLyoqIEVuZCBwb3NpdGlvbiBpbiB0aGUgb3JpZ2luYWwgSFRNTCAqL1xuICBlbmRJbmRleDogbnVtYmVyO1xuICAvKiogTGVhZGluZyBwdW5jdHVhdGlvbi93aGl0ZXNwYWNlICovXG4gIHByZWZpeDogc3RyaW5nO1xuICAvKiogVHJhaWxpbmcgcHVuY3R1YXRpb24vd2hpdGVzcGFjZSAqL1xuICBzdWZmaXg6IHN0cmluZztcbiAgLyoqIFdoZXRoZXIgdGhpcyB0b2tlbiBpcyBpbnNpZGUgYSBwcm90ZWN0ZWQgY29udGV4dCAqL1xuICBpc1Byb3RlY3RlZDogYm9vbGVhbjtcbiAgLyoqIFR5cGUgb2YgcHJvdGVjdGlvbiBpZiBhbnkgKi9cbiAgcHJvdGVjdGlvblR5cGU/OiAncXVvdGUnIHwgJ2NvZGUnIHwgJ25hbWUnIHwgJ3RhZycgfCAnc2NyaXB0JyB8ICdzdHlsZSc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dFNlZ21lbnQge1xuICAvKiogVGV4dCBjb250ZW50ICovXG4gIHRleHQ6IHN0cmluZztcbiAgLyoqIFN0YXJ0IHBvc2l0aW9uIGluIG9yaWdpbmFsIEhUTUwgKi9cbiAgc3RhcnRJbmRleDogbnVtYmVyO1xuICAvKiogRW5kIHBvc2l0aW9uIGluIG9yaWdpbmFsIEhUTUwgKi9cbiAgZW5kSW5kZXg6IG51bWJlcjtcbiAgLyoqIFdoZXRoZXIgdGhpcyBzZWdtZW50IGlzIGluc2lkZSBhIHByb3RlY3RlZCBjb250ZXh0ICovXG4gIGlzUHJvdGVjdGVkOiBib29sZWFuO1xuICAvKiogVHlwZSBvZiBwcm90ZWN0aW9uICovXG4gIHByb3RlY3Rpb25UeXBlPzogVG9rZW5bJ3Byb3RlY3Rpb25UeXBlJ107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW5pemVyT3B0aW9ucyB7XG4gIC8qKiBTa2lwIHdvcmRzIGluc2lkZSBxdW90YXRpb24gbWFya3MgKi9cbiAgc2tpcFF1b3Rlcz86IGJvb2xlYW47XG4gIC8qKiBTa2lwIHdvcmRzIHRoYXQgbG9vayBsaWtlIHByb3BlciBuYW1lcyAoY2FwaXRhbGl6ZWQpICovXG4gIHNraXBOYW1lcz86IGJvb2xlYW47XG4gIC8qKiBTa2lwIHdvcmRzIGluc2lkZSBjb2RlIGJsb2NrcyAqL1xuICBza2lwQ29kZT86IGJvb2xlYW47XG4gIC8qKiBNaW5pbXVtIHdvcmQgbGVuZ3RoIHRvIHRva2VuaXplICovXG4gIG1pbldvcmRMZW5ndGg/OiBudW1iZXI7XG4gIC8qKiBNYXhpbXVtIHdvcmQgbGVuZ3RoIHRvIHRva2VuaXplICovXG4gIG1heFdvcmRMZW5ndGg/OiBudW1iZXI7XG4gIC8qKiBDdXN0b20gd29yZHMgdG8gYWx3YXlzIHNraXAgKi9cbiAgc2tpcFdvcmRzPzogU2V0PHN0cmluZz47XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENvbnN0YW50c1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKiogVGFncyB3aG9zZSBjb250ZW50IHNob3VsZCBub3QgYmUgcHJvY2Vzc2VkICovXG5jb25zdCBTS0lQX1RBR1MgPSBuZXcgU2V0KFtcbiAgJ3NjcmlwdCcsXG4gICdzdHlsZScsXG4gICdjb2RlJyxcbiAgJ3ByZScsXG4gICdrYmQnLFxuICAnc2FtcCcsXG4gICd2YXInLFxuICAnbm9zY3JpcHQnLFxuICAnc3ZnJyxcbiAgJ21hdGgnLFxuXSk7XG5cbi8qKiBDb21tb24gRW5nbGlzaCBjb250cmFjdGlvbnMgdG8gaGFuZGxlICovXG5jb25zdCBDT05UUkFDVElPTlMgPSBuZXcgU2V0KFtcbiAgXCJuJ3RcIixcbiAgXCInc1wiLFxuICBcIidyZVwiLFxuICBcIid2ZVwiLFxuICBcIidsbFwiLFxuICBcIidkXCIsXG4gIFwiJ21cIixcbl0pO1xuXG4vKiogQ29tbW9uIHByb3BlciBuYW1lIHByZWZpeGVzICovXG5jb25zdCBOQU1FX1BSRUZJWEVTID0gbmV3IFNldChbXG4gICdtcicsXG4gICdtcnMnLFxuICAnbXMnLFxuICAnZHInLFxuICAncHJvZicsXG4gICdzaXInLFxuICAnbG9yZCcsXG4gICdsYWR5Jyxcbl0pO1xuXG4vKiogQ29tbW9uIGFiYnJldmlhdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgdHJhbnNsYXRlZCAqL1xuY29uc3QgQUJCUkVWSUFUSU9OUyA9IG5ldyBTZXQoW1xuICAnZXRjJyxcbiAgJ2VnJyxcbiAgJ2llJyxcbiAgJ3ZzJyxcbiAgJ21yJyxcbiAgJ21ycycsXG4gICdtcycsXG4gICdkcicsXG4gICdqcicsXG4gICdzcicsXG4gICdpbmMnLFxuICAnbHRkJyxcbiAgJ2NvJyxcbiAgJ2NvcnAnLFxuXSk7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFRva2VuaXplciBDbGFzc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgY2xhc3MgVG9rZW5pemVyIHtcbiAgcHJpdmF0ZSBvcHRpb25zOiBSZXF1aXJlZDxUb2tlbml6ZXJPcHRpb25zPjtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBUb2tlbml6ZXJPcHRpb25zID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBza2lwUXVvdGVzOiBvcHRpb25zLnNraXBRdW90ZXMgPz8gdHJ1ZSxcbiAgICAgIHNraXBOYW1lczogb3B0aW9ucy5za2lwTmFtZXMgPz8gdHJ1ZSxcbiAgICAgIHNraXBDb2RlOiBvcHRpb25zLnNraXBDb2RlID8/IHRydWUsXG4gICAgICBtaW5Xb3JkTGVuZ3RoOiBvcHRpb25zLm1pbldvcmRMZW5ndGggPz8gMixcbiAgICAgIG1heFdvcmRMZW5ndGg6IG9wdGlvbnMubWF4V29yZExlbmd0aCA/PyAzMCxcbiAgICAgIHNraXBXb3Jkczogb3B0aW9ucy5za2lwV29yZHMgPz8gbmV3IFNldCgpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVG9rZW5pemUgSFRNTCBjb250ZW50IGludG8gd29yZHMgd2hpbGUgcHJlc2VydmluZyBzdHJ1Y3R1cmVcbiAgICovXG4gIHRva2VuaXplKGh0bWw6IHN0cmluZyk6IFRva2VuW10ge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5leHRyYWN0VGV4dFNlZ21lbnRzKGh0bWwpO1xuICAgIGNvbnN0IHRva2VuczogVG9rZW5bXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICBpZiAoc2VnbWVudC5pc1Byb3RlY3RlZCAmJiB0aGlzLnNob3VsZFNraXBQcm90ZWN0ZWQoc2VnbWVudC5wcm90ZWN0aW9uVHlwZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlZ21lbnRUb2tlbnMgPSB0aGlzLnRva2VuaXplU2VnbWVudChzZWdtZW50KTtcbiAgICAgIHRva2Vucy5wdXNoKC4uLnNlZ21lbnRUb2tlbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCB0ZXh0IHNlZ21lbnRzIGZyb20gSFRNTCwgbWFya2luZyBwcm90ZWN0ZWQgcmVnaW9uc1xuICAgKi9cbiAgZXh0cmFjdFRleHRTZWdtZW50cyhodG1sOiBzdHJpbmcpOiBUZXh0U2VnbWVudFtdIHtcbiAgICBjb25zdCBzZWdtZW50czogVGV4dFNlZ21lbnRbXSA9IFtdO1xuICAgIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICAgIGxldCBpbnNpZGVTa2lwVGFnID0gZmFsc2U7XG4gICAgbGV0IHNraXBUYWdOYW1lID0gJyc7XG4gICAgbGV0IHF1b3RlRGVwdGggPSAwO1xuXG4gICAgLy8gUmVnZXggdG8gbWF0Y2ggSFRNTCB0YWdzXG4gICAgY29uc3QgdGFnUmVnZXggPSAvPFxcLz8oW2EtekEtWl1bYS16QS1aMC05XSopW14+XSo+L2c7XG4gICAgbGV0IG1hdGNoO1xuXG4gICAgd2hpbGUgKChtYXRjaCA9IHRhZ1JlZ2V4LmV4ZWMoaHRtbCkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB0YWdTdGFydCA9IG1hdGNoLmluZGV4O1xuICAgICAgY29uc3QgdGFnRW5kID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICBjb25zdCB0YWdOYW1lID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IGlzQ2xvc2luZyA9IG1hdGNoWzBdLnN0YXJ0c1dpdGgoJzwvJyk7XG5cbiAgICAgIC8vIEV4dHJhY3QgdGV4dCBiZWZvcmUgdGhpcyB0YWdcbiAgICAgIGlmICh0YWdTdGFydCA+IGN1cnJlbnRJbmRleCkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCB0YWdTdGFydCk7XG4gICAgICAgIGlmICh0ZXh0LnRyaW0oKSkge1xuICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIHN0YXJ0SW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgIGVuZEluZGV4OiB0YWdTdGFydCxcbiAgICAgICAgICAgIGlzUHJvdGVjdGVkOiBpbnNpZGVTa2lwVGFnIHx8IHF1b3RlRGVwdGggPiAwLFxuICAgICAgICAgICAgcHJvdGVjdGlvblR5cGU6IGluc2lkZVNraXBUYWdcbiAgICAgICAgICAgICAgPyAoc2tpcFRhZ05hbWUgPT09ICdjb2RlJyB8fCBza2lwVGFnTmFtZSA9PT0gJ3ByZScgPyAnY29kZScgOiAnc2NyaXB0JylcbiAgICAgICAgICAgICAgOiBxdW90ZURlcHRoID4gMFxuICAgICAgICAgICAgICAgID8gJ3F1b3RlJ1xuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRyYWNrIHNraXAgdGFnc1xuICAgICAgaWYgKFNLSVBfVEFHUy5oYXModGFnTmFtZSkpIHtcbiAgICAgICAgaWYgKCFpc0Nsb3NpbmcpIHtcbiAgICAgICAgICBpbnNpZGVTa2lwVGFnID0gdHJ1ZTtcbiAgICAgICAgICBza2lwVGFnTmFtZSA9IHRhZ05hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gc2tpcFRhZ05hbWUpIHtcbiAgICAgICAgICBpbnNpZGVTa2lwVGFnID0gZmFsc2U7XG4gICAgICAgICAgc2tpcFRhZ05hbWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdXJyZW50SW5kZXggPSB0YWdFbmQ7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHJlbWFpbmluZyB0ZXh0IGFmdGVyIGxhc3QgdGFnXG4gICAgaWYgKGN1cnJlbnRJbmRleCA8IGh0bWwubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoY3VycmVudEluZGV4KTtcbiAgICAgIGlmICh0ZXh0LnRyaW0oKSkge1xuICAgICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIHN0YXJ0SW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICBlbmRJbmRleDogaHRtbC5sZW5ndGgsXG4gICAgICAgICAgaXNQcm90ZWN0ZWQ6IGluc2lkZVNraXBUYWcsXG4gICAgICAgICAgcHJvdGVjdGlvblR5cGU6IGluc2lkZVNraXBUYWcgPyAnc2NyaXB0JyA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlZ21lbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRva2VuaXplIGEgc2luZ2xlIHRleHQgc2VnbWVudCBpbnRvIHdvcmRzXG4gICAqL1xuICBwcml2YXRlIHRva2VuaXplU2VnbWVudChzZWdtZW50OiBUZXh0U2VnbWVudCk6IFRva2VuW10ge1xuICAgIGNvbnN0IHRva2VuczogVG9rZW5bXSA9IFtdO1xuICAgIGNvbnN0IHRleHQgPSBzZWdtZW50LnRleHQ7XG5cbiAgICAvLyBXb3JkIHBhdHRlcm46IHN1cHBvcnRzIExhdGluIGFuZCBjb21tb24gVW5pY29kZSBsZXR0ZXJzXG4gICAgLy8gSGFuZGxlcyBjb250cmFjdGlvbnMgYW5kIGh5cGhlbmF0ZWQgd29yZHNcbiAgICBjb25zdCB3b3JkUGF0dGVybiA9IC8oW15cXHdcXHUwMEMwLVxcdTAyNEZcXHUxRTAwLVxcdTFFRkZdKikoW1xcd1xcdTAwQzAtXFx1MDI0RlxcdTFFMDAtXFx1MUVGRl0rKD86WycnXVtcXHdcXHUwMEMwLVxcdTAyNEZcXHUxRTAwLVxcdTFFRkZdKyk/KD86LVtcXHdcXHUwMEMwLVxcdTAyNEZcXHUxRTAwLVxcdTFFRkZdKykqKShbXlxcd1xcdTAwQzAtXFx1MDI0RlxcdTFFMDAtXFx1MUVGRl0qKS9nO1xuXG4gICAgbGV0IG1hdGNoO1xuICAgIGxldCBpblF1b3RlID0gZmFsc2U7XG4gICAgbGV0IGxhc3RRdW90ZUNoYXIgPSAnJztcblxuICAgIHdoaWxlICgobWF0Y2ggPSB3b3JkUGF0dGVybi5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgWywgcHJlZml4LCB3b3JkLCBzdWZmaXhdID0gbWF0Y2g7XG4gICAgICBjb25zdCBzdGFydEluU2VnbWVudCA9IG1hdGNoLmluZGV4ICsgcHJlZml4Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGVuZEluU2VnbWVudCA9IHN0YXJ0SW5TZWdtZW50ICsgd29yZC5sZW5ndGg7XG5cbiAgICAgIC8vIFRyYWNrIHF1b3RlcyBpbiBwcmVmaXhcbiAgICAgIGZvciAoY29uc3QgY2hhciBvZiBwcmVmaXgpIHtcbiAgICAgICAgaWYgKGNoYXIgPT09ICdcIicgfHwgY2hhciA9PT0gJ1xcdTIwMUMnIHx8IGNoYXIgPT09ICdcXHUyMDFEJyB8fCBjaGFyID09PSBcIidcIiB8fCBjaGFyID09PSAnXFx1MjAxOCcgfHwgY2hhciA9PT0gJ1xcdTIwMTknKSB7XG4gICAgICAgICAgaWYgKCFpblF1b3RlKSB7XG4gICAgICAgICAgICBpblF1b3RlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxhc3RRdW90ZUNoYXIgPSBjaGFyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc01hdGNoaW5nUXVvdGUobGFzdFF1b3RlQ2hhciwgY2hhcikpIHtcbiAgICAgICAgICAgIGluUXVvdGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdvcmQgaXMgcHJvdGVjdGVkXG4gICAgICBsZXQgaXNQcm90ZWN0ZWQgPSBzZWdtZW50LmlzUHJvdGVjdGVkIHx8IChpblF1b3RlICYmIHRoaXMub3B0aW9ucy5za2lwUXVvdGVzKTtcbiAgICAgIGxldCBwcm90ZWN0aW9uVHlwZSA9IHNlZ21lbnQucHJvdGVjdGlvblR5cGU7XG5cbiAgICAgIC8vIENoZWNrIGZvciBwcm9wZXIgbmFtZXMgKGNhcGl0YWxpemVkIHdvcmRzIG5vdCBhdCBzZW50ZW5jZSBzdGFydClcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2tpcE5hbWVzICYmIHRoaXMubG9va3NMaWtlTmFtZSh3b3JkLCBwcmVmaXgsIHRleHQsIHN0YXJ0SW5TZWdtZW50KSkge1xuICAgICAgICBpc1Byb3RlY3RlZCA9IHRydWU7XG4gICAgICAgIHByb3RlY3Rpb25UeXBlID0gJ25hbWUnO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgYWJicmV2aWF0aW9uc1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IHdvcmQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4vZywgJycpO1xuICAgICAgaWYgKEFCQlJFVklBVElPTlMuaGFzKG5vcm1hbGl6ZWQpKSB7XG4gICAgICAgIGlzUHJvdGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvdGVjdGlvblR5cGUgPSAnbmFtZSc7XG4gICAgICB9XG5cbiAgICAgIC8vIFNraXAgaWYgd29yZCBkb2Vzbid0IG1lZXQgbGVuZ3RoIHJlcXVpcmVtZW50c1xuICAgICAgaWYgKHdvcmQubGVuZ3RoIDwgdGhpcy5vcHRpb25zLm1pbldvcmRMZW5ndGggfHwgd29yZC5sZW5ndGggPiB0aGlzLm9wdGlvbnMubWF4V29yZExlbmd0aCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBpZiBpbiBjdXN0b20gc2tpcCBsaXN0XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNraXBXb3Jkcy5oYXMobm9ybWFsaXplZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgd29yZDogbm9ybWFsaXplZCxcbiAgICAgICAgb3JpZ2luYWw6IHdvcmQsXG4gICAgICAgIHN0YXJ0SW5kZXg6IHNlZ21lbnQuc3RhcnRJbmRleCArIHN0YXJ0SW5TZWdtZW50LFxuICAgICAgICBlbmRJbmRleDogc2VnbWVudC5zdGFydEluZGV4ICsgZW5kSW5TZWdtZW50LFxuICAgICAgICBwcmVmaXgsXG4gICAgICAgIHN1ZmZpeCxcbiAgICAgICAgaXNQcm90ZWN0ZWQsXG4gICAgICAgIHByb3RlY3Rpb25UeXBlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRyYWNrIHF1b3RlcyBpbiBzdWZmaXhcbiAgICAgIGZvciAoY29uc3QgY2hhciBvZiBzdWZmaXgpIHtcbiAgICAgICAgaWYgKGNoYXIgPT09ICdcIicgfHwgY2hhciA9PT0gJ1xcdTIwMUMnIHx8IGNoYXIgPT09ICdcXHUyMDFEJyB8fCBjaGFyID09PSBcIidcIiB8fCBjaGFyID09PSAnXFx1MjAxOCcgfHwgY2hhciA9PT0gJ1xcdTIwMTknKSB7XG4gICAgICAgICAgaWYgKGluUXVvdGUgJiYgdGhpcy5pc01hdGNoaW5nUXVvdGUobGFzdFF1b3RlQ2hhciwgY2hhcikpIHtcbiAgICAgICAgICAgIGluUXVvdGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgd29yZCBsb29rcyBsaWtlIGEgcHJvcGVyIG5hbWVcbiAgICovXG4gIHByaXZhdGUgbG9va3NMaWtlTmFtZShcbiAgICB3b3JkOiBzdHJpbmcsXG4gICAgcHJlZml4OiBzdHJpbmcsXG4gICAgZnVsbFRleHQ6IHN0cmluZyxcbiAgICBwb3NpdGlvbkluVGV4dDogbnVtYmVyXG4gICk6IGJvb2xlYW4ge1xuICAgIC8vIE11c3Qgc3RhcnQgd2l0aCBjYXBpdGFsIGxldHRlclxuICAgIGlmICghL15bQS1aXS8udGVzdCh3b3JkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGl0J3MgYXQgdGhlIHN0YXJ0IG9mIGEgc2VudGVuY2VcbiAgICBjb25zdCB0cmltbWVkUHJlZml4ID0gcHJlZml4LnRyaW1FbmQoKTtcbiAgICBpZiAoXG4gICAgICBwb3NpdGlvbkluVGV4dCA9PT0gMCB8fFxuICAgICAgdHJpbW1lZFByZWZpeC5lbmRzV2l0aCgnLicpIHx8XG4gICAgICB0cmltbWVkUHJlZml4LmVuZHNXaXRoKCchJykgfHxcbiAgICAgIHRyaW1tZWRQcmVmaXguZW5kc1dpdGgoJz8nKSB8fFxuICAgICAgdHJpbW1lZFByZWZpeC5lbmRzV2l0aCgnOicpXG4gICAgKSB7XG4gICAgICAvLyBDb3VsZCBiZSBzZW50ZW5jZSBzdGFydCwgbm90IG5lY2Vzc2FyaWx5IGEgbmFtZVxuICAgICAgLy8gQnV0IGlmIEFMTCBDQVBTIG9yIGhhcyBpbnRlcm5hbCBjYXBpdGFscywgbGlrZWx5IGEgbmFtZVxuICAgICAgaWYgKHdvcmQgPT09IHdvcmQudG9VcHBlckNhc2UoKSB8fCAvW0EtWl0vLnRlc3Qod29yZC5zbGljZSgxKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIG5hbWUgcHJlZml4ZXMgKE1yLiwgRHIuLCBldGMuKVxuICAgIGNvbnN0IHByZXZXb3JkID0gdGhpcy5nZXRQcmV2aW91c1dvcmQoZnVsbFRleHQsIHBvc2l0aW9uSW5UZXh0KTtcbiAgICBpZiAocHJldldvcmQgJiYgTkFNRV9QUkVGSVhFUy5oYXMocHJldldvcmQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCcuJywgJycpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTWlkLXNlbnRlbmNlIGNhcGl0YWxpemF0aW9uIGlzIGxpa2VseSBhIG5hbWVcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZXZpb3VzIHdvcmQgaW4gdGhlIHRleHRcbiAgICovXG4gIHByaXZhdGUgZ2V0UHJldmlvdXNXb3JkKHRleHQ6IHN0cmluZywgcG9zaXRpb246IG51bWJlcik6IHN0cmluZyB8IG51bGwge1xuICAgIGNvbnN0IGJlZm9yZSA9IHRleHQuc3Vic3RyaW5nKDAsIHBvc2l0aW9uKS50cmltRW5kKCk7XG4gICAgY29uc3QgbWF0Y2ggPSBiZWZvcmUubWF0Y2goLyhcXHcrXFwuPykkLyk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHR3byBxdW90ZSBjaGFyYWN0ZXJzIG1hdGNoXG4gICAqL1xuICBwcml2YXRlIGlzTWF0Y2hpbmdRdW90ZShvcGVuOiBzdHJpbmcsIGNsb3NlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBwYWlyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICdcIic6ICdcIicsXG4gICAgICAnXFx1MjAxQyc6ICdcXHUyMDFEJyxcbiAgICAgIFwiJ1wiOiBcIidcIixcbiAgICAgICdcXHUyMDE4JzogJ1xcdTIwMTknLFxuICAgIH07XG4gICAgcmV0dXJuIHBhaXJzW29wZW5dID09PSBjbG9zZSB8fCBvcGVuID09PSBjbG9zZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB3ZSBzaG91bGQgc2tpcCBwcm90ZWN0ZWQgY29udGVudFxuICAgKi9cbiAgcHJpdmF0ZSBzaG91bGRTa2lwUHJvdGVjdGVkKHR5cGU/OiBUb2tlblsncHJvdGVjdGlvblR5cGUnXSk6IGJvb2xlYW4ge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnY29kZSc6XG4gICAgICBjYXNlICdzY3JpcHQnOlxuICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNraXBDb2RlO1xuICAgICAgY2FzZSAncXVvdGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNraXBRdW90ZXM7XG4gICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5za2lwTmFtZXM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0b2tlbml6ZXIgb3B0aW9uc1xuICAgKi9cbiAgdXBkYXRlT3B0aW9ucyhvcHRpb25zOiBQYXJ0aWFsPFRva2VuaXplck9wdGlvbnM+KTogdm9pZCB7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdW5pcXVlIHdvcmRzIGZyb20gdG9rZW5zXG4gICAqL1xuICBzdGF0aWMgZ2V0VW5pcXVlV29yZHModG9rZW5zOiBUb2tlbltdKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHdvcmRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgIGlmICghdG9rZW4uaXNQcm90ZWN0ZWQpIHtcbiAgICAgICAgd29yZHMuYWRkKHRva2VuLndvcmQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh3b3Jkcyk7XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiB3aXRoIGRlZmF1bHQgb3B0aW9uc1xuZXhwb3J0IGNvbnN0IHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoKTtcbiIsIi8qKlxuICogV29yZCBSZXBsYWNlciAtIEhhbmRsZXMgd29yZCByZXBsYWNlbWVudCBsb2dpYyB3aXRoIGNvbnRleHQgYXdhcmVuZXNzXG4gKlxuICogRmVhdHVyZXM6XG4gKiAtIFJlc3BlY3RzIHdvcmQgZGVuc2l0eSBzZXR0aW5nc1xuICogLSBQcmVzZXJ2ZXMgb3JpZ2luYWwgY2FzZVxuICogLSBDcmVhdGVzIHByb3Blcmx5IGZvcm1hdHRlZCBmb3JlaWduIHdvcmQgbWFya2Vyc1xuICogLSBIYW5kbGVzIHJlcGxhY2VtZW50IGluIEhUTUwgd2l0aG91dCBicmVha2luZyBzdHJ1Y3R1cmVcbiAqIC0gU3VwcG9ydHMgY29uZmlndXJhYmxlIHJlcGxhY2VtZW50IHN0cmF0ZWdpZXNcbiAqL1xuXG5pbXBvcnQgdHlwZSB7IFdvcmRFbnRyeSwgUHJvZmljaWVuY3lMZXZlbCwgRm9yZWlnbldvcmREYXRhIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBUb2tlbiB9IGZyb20gJy4vVG9rZW5pemVyJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVHlwZXNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBSZXBsYWNlbWVudENhbmRpZGF0ZSB7XG4gIHRva2VuOiBUb2tlbjtcbiAgZW50cnk6IFdvcmRFbnRyeTtcbiAgc2NvcmU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXBsYWNlbWVudFJlc3VsdCB7XG4gIC8qKiBUaGUgbW9kaWZpZWQgSFRNTCBjb250ZW50ICovXG4gIGh0bWw6IHN0cmluZztcbiAgLyoqIEFycmF5IG9mIGZvcmVpZ24gd29yZHMgdGhhdCB3ZXJlIGluc2VydGVkICovXG4gIGZvcmVpZ25Xb3JkczogRm9yZWlnbldvcmREYXRhW107XG4gIC8qKiBTdGF0aXN0aWNzIGFib3V0IHRoZSByZXBsYWNlbWVudCAqL1xuICBzdGF0czogUmVwbGFjZW1lbnRTdGF0cztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXBsYWNlbWVudFN0YXRzIHtcbiAgLyoqIFRvdGFsIHRva2VucyBwcm9jZXNzZWQgKi9cbiAgdG90YWxUb2tlbnM6IG51bWJlcjtcbiAgLyoqIFRva2VucyBlbGlnaWJsZSBmb3IgcmVwbGFjZW1lbnQgKi9cbiAgZWxpZ2libGVUb2tlbnM6IG51bWJlcjtcbiAgLyoqIFRva2VucyBhY3R1YWxseSByZXBsYWNlZCAqL1xuICByZXBsYWNlZFRva2VuczogbnVtYmVyO1xuICAvKiogVG9rZW5zIHNraXBwZWQgZHVlIHRvIHByb3RlY3Rpb24gKi9cbiAgcHJvdGVjdGVkVG9rZW5zOiBudW1iZXI7XG4gIC8qKiBUb2tlbnMgc2tpcHBlZCBkdWUgdG8gZGVuc2l0eSBsaW1pdCAqL1xuICBkZW5zaXR5U2tpcHBlZDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlcGxhY2VyT3B0aW9ucyB7XG4gIC8qKiBUYXJnZXQgd29yZCBkZW5zaXR5ICgwLjAgLSAxLjApICovXG4gIGRlbnNpdHk6IG51bWJlcjtcbiAgLyoqIE1heGltdW0gcHJvZmljaWVuY3kgbGV2ZWwgdG8gaW5jbHVkZSAqL1xuICBtYXhQcm9maWNpZW5jeTogUHJvZmljaWVuY3lMZXZlbDtcbiAgLyoqIFByZWZlciByZXBsYWNpbmcgY2VydGFpbiBwYXJ0cyBvZiBzcGVlY2ggKi9cbiAgcHJlZmVycmVkUGFydHNPZlNwZWVjaD86IHN0cmluZ1tdO1xuICAvKiogV29yZHMgdG8gbmV2ZXIgcmVwbGFjZSAqL1xuICBleGNsdWRlV29yZHM/OiBTZXQ8c3RyaW5nPjtcbiAgLyoqIE1pbmltdW0gc3BhY2luZyBiZXR3ZWVuIHJlcGxhY2VkIHdvcmRzICovXG4gIG1pbldvcmRTcGFjaW5nPzogbnVtYmVyO1xuICAvKiogU3RyYXRlZ3kgZm9yIHNlbGVjdGluZyB3aGljaCB3b3JkcyB0byByZXBsYWNlICovXG4gIHNlbGVjdGlvblN0cmF0ZWd5PzogJ3JhbmRvbScgfCAnZnJlcXVlbmN5JyB8ICdkaXN0cmlidXRlZCc7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENvbnN0YW50c1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBQUk9GSUNJRU5DWV9PUkRFUjogUHJvZmljaWVuY3lMZXZlbFtdID0gWydiZWdpbm5lcicsICdpbnRlcm1lZGlhdGUnLCAnYWR2YW5jZWQnXTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gV29yZCBSZXBsYWNlciBDbGFzc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgY2xhc3MgV29yZFJlcGxhY2VyIHtcbiAgcHJpdmF0ZSBvcHRpb25zOiBSZXF1aXJlZDxSZXBsYWNlck9wdGlvbnM+O1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFBhcnRpYWw8UmVwbGFjZXJPcHRpb25zPiA9IHt9KSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgZGVuc2l0eTogb3B0aW9ucy5kZW5zaXR5ID8/IDAuMTUsXG4gICAgICBtYXhQcm9maWNpZW5jeTogb3B0aW9ucy5tYXhQcm9maWNpZW5jeSA/PyAnYmVnaW5uZXInLFxuICAgICAgcHJlZmVycmVkUGFydHNPZlNwZWVjaDogb3B0aW9ucy5wcmVmZXJyZWRQYXJ0c09mU3BlZWNoID8/IFtdLFxuICAgICAgZXhjbHVkZVdvcmRzOiBvcHRpb25zLmV4Y2x1ZGVXb3JkcyA/PyBuZXcgU2V0KCksXG4gICAgICBtaW5Xb3JkU3BhY2luZzogb3B0aW9ucy5taW5Xb3JkU3BhY2luZyA/PyAzLFxuICAgICAgc2VsZWN0aW9uU3RyYXRlZ3k6IG9wdGlvbnMuc2VsZWN0aW9uU3RyYXRlZ3kgPz8gJ2Rpc3RyaWJ1dGVkJyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2Ugd29yZHMgaW4gSFRNTCBjb250ZW50IHdpdGggZm9yZWlnbiBlcXVpdmFsZW50c1xuICAgKi9cbiAgcmVwbGFjZShcbiAgICBodG1sOiBzdHJpbmcsXG4gICAgdG9rZW5zOiBUb2tlbltdLFxuICAgIHdvcmRFbnRyaWVzOiBNYXA8c3RyaW5nLCBXb3JkRW50cnkgfCBudWxsPlxuICApOiBSZXBsYWNlbWVudFJlc3VsdCB7XG4gICAgLy8gQnVpbGQgbGlzdCBvZiByZXBsYWNlbWVudCBjYW5kaWRhdGVzXG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IHRoaXMuYnVpbGRDYW5kaWRhdGVzKHRva2Vucywgd29yZEVudHJpZXMpO1xuXG4gICAgLy8gU2VsZWN0IHdoaWNoIHdvcmRzIHRvIHJlcGxhY2UgYmFzZWQgb24gZGVuc2l0eSBhbmQgc3RyYXRlZ3lcbiAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0UmVwbGFjZW1lbnRzKGNhbmRpZGF0ZXMsIHRva2Vucy5sZW5ndGgpO1xuXG4gICAgLy8gU29ydCBieSBwb3NpdGlvbiBkZXNjZW5kaW5nIHRvIHJlcGxhY2UgZnJvbSBlbmQgdG8gc3RhcnRcbiAgICAvLyBUaGlzIHByZXZlbnRzIHBvc2l0aW9uIHNoaWZ0cyBmcm9tIGFmZmVjdGluZyBzdWJzZXF1ZW50IHJlcGxhY2VtZW50c1xuICAgIHNlbGVjdGVkLnNvcnQoKGEsIGIpID0+IGIudG9rZW4uc3RhcnRJbmRleCAtIGEudG9rZW4uc3RhcnRJbmRleCk7XG5cbiAgICAvLyBQZXJmb3JtIHJlcGxhY2VtZW50c1xuICAgIGxldCBtb2RpZmllZEh0bWwgPSBodG1sO1xuICAgIGNvbnN0IGZvcmVpZ25Xb3JkczogRm9yZWlnbldvcmREYXRhW10gPSBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHNlbGVjdGVkKSB7XG4gICAgICBjb25zdCB7IHRva2VuLCBlbnRyeSB9ID0gY2FuZGlkYXRlO1xuXG4gICAgICAvLyBQcmVzZXJ2ZSBvcmlnaW5hbCBjYXNlXG4gICAgICBjb25zdCBmb3JlaWduV29yZCA9IHRoaXMucHJlc2VydmVDYXNlKHRva2VuLm9yaWdpbmFsLCBlbnRyeS50YXJnZXRXb3JkKTtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBmb3JlaWduIHdvcmQgbWFya2VyIEhUTUxcbiAgICAgIGNvbnN0IG1hcmtlciA9IHRoaXMuY3JlYXRlTWFya2VyKGZvcmVpZ25Xb3JkLCBlbnRyeSwgdG9rZW4pO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb25zXG4gICAgICBjb25zdCBzdGFydCA9IHRva2VuLnN0YXJ0SW5kZXg7XG4gICAgICBjb25zdCBlbmQgPSB0b2tlbi5lbmRJbmRleDtcblxuICAgICAgLy8gUmVwbGFjZSBpbiBIVE1MXG4gICAgICBtb2RpZmllZEh0bWwgPVxuICAgICAgICBtb2RpZmllZEh0bWwuc3Vic3RyaW5nKDAsIHN0YXJ0KSArXG4gICAgICAgIG1hcmtlciArXG4gICAgICAgIG1vZGlmaWVkSHRtbC5zdWJzdHJpbmcoZW5kKTtcblxuICAgICAgLy8gVHJhY2sgZm9yZWlnbiB3b3JkIGRhdGFcbiAgICAgIGZvcmVpZ25Xb3Jkcy5wdXNoKHtcbiAgICAgICAgb3JpZ2luYWxXb3JkOiB0b2tlbi5vcmlnaW5hbCxcbiAgICAgICAgZm9yZWlnbldvcmQsXG4gICAgICAgIHN0YXJ0SW5kZXg6IHN0YXJ0LFxuICAgICAgICBlbmRJbmRleDogc3RhcnQgKyBtYXJrZXIubGVuZ3RoLFxuICAgICAgICB3b3JkRW50cnk6IGVudHJ5LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmV2ZXJzZSBmb3JlaWduV29yZHMgdG8gbWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcbiAgICBmb3JlaWduV29yZHMucmV2ZXJzZSgpO1xuXG4gICAgY29uc3Qgc3RhdHM6IFJlcGxhY2VtZW50U3RhdHMgPSB7XG4gICAgICB0b3RhbFRva2VuczogdG9rZW5zLmxlbmd0aCxcbiAgICAgIGVsaWdpYmxlVG9rZW5zOiBjYW5kaWRhdGVzLmxlbmd0aCxcbiAgICAgIHJlcGxhY2VkVG9rZW5zOiBzZWxlY3RlZC5sZW5ndGgsXG4gICAgICBwcm90ZWN0ZWRUb2tlbnM6IHRva2Vucy5maWx0ZXIodCA9PiB0LmlzUHJvdGVjdGVkKS5sZW5ndGgsXG4gICAgICBkZW5zaXR5U2tpcHBlZDogY2FuZGlkYXRlcy5sZW5ndGggLSBzZWxlY3RlZC5sZW5ndGgsXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBodG1sOiBtb2RpZmllZEh0bWwsXG4gICAgICBmb3JlaWduV29yZHMsXG4gICAgICBzdGF0cyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGxpc3Qgb2YgcmVwbGFjZW1lbnQgY2FuZGlkYXRlcyBmcm9tIHRva2Vuc1xuICAgKi9cbiAgcHJpdmF0ZSBidWlsZENhbmRpZGF0ZXMoXG4gICAgdG9rZW5zOiBUb2tlbltdLFxuICAgIHdvcmRFbnRyaWVzOiBNYXA8c3RyaW5nLCBXb3JkRW50cnkgfCBudWxsPlxuICApOiBSZXBsYWNlbWVudENhbmRpZGF0ZVtdIHtcbiAgICBjb25zdCBjYW5kaWRhdGVzOiBSZXBsYWNlbWVudENhbmRpZGF0ZVtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgLy8gU2tpcCBwcm90ZWN0ZWQgdG9rZW5zXG4gICAgICBpZiAodG9rZW4uaXNQcm90ZWN0ZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFNraXAgZXhjbHVkZWQgd29yZHNcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXhjbHVkZVdvcmRzLmhhcyh0b2tlbi53b3JkKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHdvcmQgZW50cnlcbiAgICAgIGNvbnN0IGVudHJ5ID0gd29yZEVudHJpZXMuZ2V0KHRva2VuLndvcmQpO1xuICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgcHJvZmljaWVuY3kgbGV2ZWxcbiAgICAgIGlmICghdGhpcy5pc1dpdGhpblByb2ZpY2llbmN5KGVudHJ5LnByb2ZpY2llbmN5TGV2ZWwpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgcmVwbGFjZW1lbnQgc2NvcmVcbiAgICAgIGNvbnN0IHNjb3JlID0gdGhpcy5jYWxjdWxhdGVTY29yZSh0b2tlbiwgZW50cnkpO1xuXG4gICAgICBjYW5kaWRhdGVzLnB1c2goeyB0b2tlbiwgZW50cnksIHNjb3JlIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjYW5kaWRhdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB3aGljaCBjYW5kaWRhdGVzIHRvIHJlcGxhY2UgYmFzZWQgb24gZGVuc2l0eSBhbmQgc3RyYXRlZ3lcbiAgICovXG4gIHByaXZhdGUgc2VsZWN0UmVwbGFjZW1lbnRzKFxuICAgIGNhbmRpZGF0ZXM6IFJlcGxhY2VtZW50Q2FuZGlkYXRlW10sXG4gICAgdG90YWxUb2tlbnM6IG51bWJlclxuICApOiBSZXBsYWNlbWVudENhbmRpZGF0ZVtdIHtcbiAgICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdGFyZ2V0IGNvdW50IGJhc2VkIG9uIGRlbnNpdHlcbiAgICBjb25zdCB0YXJnZXRDb3VudCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IodG90YWxUb2tlbnMgKiB0aGlzLm9wdGlvbnMuZGVuc2l0eSkpO1xuXG4gICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuc2VsZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICAgIGNhc2UgJ2ZyZXF1ZW5jeSc6XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdEJ5RnJlcXVlbmN5KGNhbmRpZGF0ZXMsIHRhcmdldENvdW50KTtcbiAgICAgIGNhc2UgJ2Rpc3RyaWJ1dGVkJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0RGlzdHJpYnV0ZWQoY2FuZGlkYXRlcywgdGFyZ2V0Q291bnQpO1xuICAgICAgY2FzZSAncmFuZG9tJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdFJhbmRvbShjYW5kaWRhdGVzLCB0YXJnZXRDb3VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB3b3JkcyByYW5kb21seVxuICAgKi9cbiAgcHJpdmF0ZSBzZWxlY3RSYW5kb20oXG4gICAgY2FuZGlkYXRlczogUmVwbGFjZW1lbnRDYW5kaWRhdGVbXSxcbiAgICB0YXJnZXRDb3VudDogbnVtYmVyXG4gICk6IFJlcGxhY2VtZW50Q2FuZGlkYXRlW10ge1xuICAgIGNvbnN0IHNodWZmbGVkID0gWy4uLmNhbmRpZGF0ZXNdLnNvcnQoKCkgPT4gTWF0aC5yYW5kb20oKSAtIDAuNSk7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlTcGFjaW5nQ29uc3RyYWludChzaHVmZmxlZCwgdGFyZ2V0Q291bnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB3b3JkcyBieSBmcmVxdWVuY3kgKHByZWZlciBtb3JlIGNvbW1vbiB3b3JkcylcbiAgICovXG4gIHByaXZhdGUgc2VsZWN0QnlGcmVxdWVuY3koXG4gICAgY2FuZGlkYXRlczogUmVwbGFjZW1lbnRDYW5kaWRhdGVbXSxcbiAgICB0YXJnZXRDb3VudDogbnVtYmVyXG4gICk6IFJlcGxhY2VtZW50Q2FuZGlkYXRlW10ge1xuICAgIC8vIFNvcnQgYnkgZnJlcXVlbmN5IHJhbmsgKGxvd2VyID0gbW9yZSBjb21tb24pXG4gICAgY29uc3Qgc29ydGVkID0gWy4uLmNhbmRpZGF0ZXNdLnNvcnQoXG4gICAgICAoYSwgYikgPT4gYS5lbnRyeS5mcmVxdWVuY3lSYW5rIC0gYi5lbnRyeS5mcmVxdWVuY3lSYW5rXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5hcHBseVNwYWNpbmdDb25zdHJhaW50KHNvcnRlZCwgdGFyZ2V0Q291bnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB3b3JkcyBkaXN0cmlidXRlZCBldmVubHkgdGhyb3VnaG91dCB0aGUgdGV4dFxuICAgKi9cbiAgcHJpdmF0ZSBzZWxlY3REaXN0cmlidXRlZChcbiAgICBjYW5kaWRhdGVzOiBSZXBsYWNlbWVudENhbmRpZGF0ZVtdLFxuICAgIHRhcmdldENvdW50OiBudW1iZXJcbiAgKTogUmVwbGFjZW1lbnRDYW5kaWRhdGVbXSB7XG4gICAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoIDw9IHRhcmdldENvdW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseVNwYWNpbmdDb25zdHJhaW50KGNhbmRpZGF0ZXMsIHRhcmdldENvdW50KTtcbiAgICB9XG5cbiAgICAvLyBTb3J0IGJ5IHBvc2l0aW9uXG4gICAgY29uc3Qgc29ydGVkID0gWy4uLmNhbmRpZGF0ZXNdLnNvcnQoXG4gICAgICAoYSwgYikgPT4gYS50b2tlbi5zdGFydEluZGV4IC0gYi50b2tlbi5zdGFydEluZGV4XG4gICAgKTtcblxuICAgIC8vIFNlbGVjdCBldmVubHkgZGlzdHJpYnV0ZWQgaW5kaWNlc1xuICAgIGNvbnN0IHN0ZXAgPSBzb3J0ZWQubGVuZ3RoIC8gdGFyZ2V0Q291bnQ7XG4gICAgY29uc3Qgc2VsZWN0ZWQ6IFJlcGxhY2VtZW50Q2FuZGlkYXRlW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKGkgKiBzdGVwICsgTWF0aC5yYW5kb20oKSAqIHN0ZXAgKiAwLjUpO1xuICAgICAgaWYgKGluZGV4IDwgc29ydGVkLmxlbmd0aCkge1xuICAgICAgICBzZWxlY3RlZC5wdXNoKHNvcnRlZFtpbmRleF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFwcGx5U3BhY2luZ0NvbnN0cmFpbnQoc2VsZWN0ZWQsIHRhcmdldENvdW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBtaW5pbXVtIHdvcmQgc3BhY2luZyBjb25zdHJhaW50XG4gICAqL1xuICBwcml2YXRlIGFwcGx5U3BhY2luZ0NvbnN0cmFpbnQoXG4gICAgY2FuZGlkYXRlczogUmVwbGFjZW1lbnRDYW5kaWRhdGVbXSxcbiAgICBtYXhDb3VudDogbnVtYmVyXG4gICk6IFJlcGxhY2VtZW50Q2FuZGlkYXRlW10ge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubWluV29yZFNwYWNpbmcgPD0gMCkge1xuICAgICAgcmV0dXJuIGNhbmRpZGF0ZXMuc2xpY2UoMCwgbWF4Q291bnQpO1xuICAgIH1cblxuICAgIC8vIFNvcnQgYnkgcG9zaXRpb25cbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4uY2FuZGlkYXRlc10uc29ydChcbiAgICAgIChhLCBiKSA9PiBhLnRva2VuLnN0YXJ0SW5kZXggLSBiLnRva2VuLnN0YXJ0SW5kZXhcbiAgICApO1xuXG4gICAgY29uc3Qgc2VsZWN0ZWQ6IFJlcGxhY2VtZW50Q2FuZGlkYXRlW10gPSBbXTtcbiAgICBsZXQgbGFzdFBvc2l0aW9uID0gLUluZmluaXR5O1xuXG4gICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2Ygc29ydGVkKSB7XG4gICAgICBpZiAoc2VsZWN0ZWQubGVuZ3RoID49IG1heENvdW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBzcGFjaW5nIGZyb20gbGFzdCBzZWxlY3RlZCB3b3JkXG4gICAgICAvLyBVc2UgYSByb3VnaCBlc3RpbWF0ZSBvZiB3b3JkIHBvc2l0aW9uc1xuICAgICAgY29uc3Qgd29yZHNCZXR3ZWVuID0gTWF0aC5mbG9vcihcbiAgICAgICAgKGNhbmRpZGF0ZS50b2tlbi5zdGFydEluZGV4IC0gbGFzdFBvc2l0aW9uKSAvIDYgLy8gUm91Z2ggYXZlcmFnZSB3b3JkIGxlbmd0aFxuICAgICAgKTtcblxuICAgICAgaWYgKHdvcmRzQmV0d2VlbiA+PSB0aGlzLm9wdGlvbnMubWluV29yZFNwYWNpbmcpIHtcbiAgICAgICAgc2VsZWN0ZWQucHVzaChjYW5kaWRhdGUpO1xuICAgICAgICBsYXN0UG9zaXRpb24gPSBjYW5kaWRhdGUudG9rZW4uZW5kSW5kZXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBhIHNjb3JlIGZvciByZXBsYWNlbWVudCBwcmlvcml0eVxuICAgKi9cbiAgcHJpdmF0ZSBjYWxjdWxhdGVTY29yZSh0b2tlbjogVG9rZW4sIGVudHJ5OiBXb3JkRW50cnkpOiBudW1iZXIge1xuICAgIGxldCBzY29yZSA9IDEwMDtcblxuICAgIC8vIFByZWZlciBsb3dlciBmcmVxdWVuY3kgcmFuayAobW9yZSBjb21tb24gd29yZHMpXG4gICAgc2NvcmUgLT0gTWF0aC5taW4oNTAsIGVudHJ5LmZyZXF1ZW5jeVJhbmsgLyAxMDApO1xuXG4gICAgLy8gUHJlZmVyIGNlcnRhaW4gcGFydHMgb2Ygc3BlZWNoXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnByZWZlcnJlZFBhcnRzT2ZTcGVlY2gubGVuZ3RoID4gMCAmJlxuICAgICAgdGhpcy5vcHRpb25zLnByZWZlcnJlZFBhcnRzT2ZTcGVlY2guaW5jbHVkZXMoZW50cnkucGFydE9mU3BlZWNoKVxuICAgICkge1xuICAgICAgc2NvcmUgKz0gMjA7XG4gICAgfVxuXG4gICAgLy8gUHJlZmVyIHdvcmRzIHRoYXQgYXJlIG5vdCBhdCBzZW50ZW5jZSBib3VuZGFyaWVzXG4gICAgaWYgKCF0b2tlbi5wcmVmaXgubWF0Y2goL1suIT9dXFxzKiQvKSkge1xuICAgICAgc2NvcmUgKz0gMTA7XG4gICAgfVxuXG4gICAgLy8gUHJlZmVyIHNob3J0ZXIgd29yZHMgKGVhc2llciB0byB1bmRlcnN0YW5kIGZyb20gY29udGV4dClcbiAgICBpZiAodG9rZW4ud29yZC5sZW5ndGggPD0gNikge1xuICAgICAgc2NvcmUgKz0gNTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NvcmU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgcHJvZmljaWVuY3kgbGV2ZWwgaXMgd2l0aGluIG1heCBhbGxvd2VkXG4gICAqL1xuICBwcml2YXRlIGlzV2l0aGluUHJvZmljaWVuY3kobGV2ZWw6IFByb2ZpY2llbmN5TGV2ZWwpOiBib29sZWFuIHtcbiAgICBjb25zdCBtYXhJbmRleCA9IFBST0ZJQ0lFTkNZX09SREVSLmluZGV4T2YodGhpcy5vcHRpb25zLm1heFByb2ZpY2llbmN5KTtcbiAgICBjb25zdCBsZXZlbEluZGV4ID0gUFJPRklDSUVOQ1lfT1JERVIuaW5kZXhPZihsZXZlbCk7XG4gICAgcmV0dXJuIGxldmVsSW5kZXggPD0gbWF4SW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogUHJlc2VydmUgdGhlIG9yaWdpbmFsIHdvcmQncyBjYXNlIHBhdHRlcm5cbiAgICovXG4gIHByaXZhdGUgcHJlc2VydmVDYXNlKG9yaWdpbmFsOiBzdHJpbmcsIHJlcGxhY2VtZW50OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghb3JpZ2luYWwgfHwgIXJlcGxhY2VtZW50KSB7XG4gICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gQWxsIHVwcGVyY2FzZVxuICAgIGlmIChvcmlnaW5hbCA9PT0gb3JpZ2luYWwudG9VcHBlckNhc2UoKSAmJiBvcmlnaW5hbC5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gcmVwbGFjZW1lbnQudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvLyBUaXRsZSBjYXNlIChmaXJzdCBsZXR0ZXIgdXBwZXJjYXNlKVxuICAgIGlmIChcbiAgICAgIG9yaWdpbmFsWzBdID09PSBvcmlnaW5hbFswXS50b1VwcGVyQ2FzZSgpICYmXG4gICAgICBvcmlnaW5hbC5zbGljZSgxKSA9PT0gb3JpZ2luYWwuc2xpY2UoMSkudG9Mb3dlckNhc2UoKVxuICAgICkge1xuICAgICAgcmV0dXJuIHJlcGxhY2VtZW50WzBdLnRvVXBwZXJDYXNlKCkgKyByZXBsYWNlbWVudC5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEFsbCBsb3dlcmNhc2VcbiAgICByZXR1cm4gcmVwbGFjZW1lbnQudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgSFRNTCBtYXJrZXIgZm9yIGEgZm9yZWlnbiB3b3JkXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZU1hcmtlcihcbiAgICBmb3JlaWduV29yZDogc3RyaW5nLFxuICAgIGVudHJ5OiBXb3JkRW50cnksXG4gICAgdG9rZW46IFRva2VuXG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgYXR0cnMgPSBbXG4gICAgICBgY2xhc3M9XCJmb3JlaWduLXdvcmRcImAsXG4gICAgICBgZGF0YS1vcmlnaW5hbD1cIiR7dGhpcy5lc2NhcGVIdG1sKGVudHJ5LnNvdXJjZVdvcmQpfVwiYCxcbiAgICAgIGBkYXRhLXdvcmQtaWQ9XCIke3RoaXMuZXNjYXBlSHRtbChlbnRyeS5pZCl9XCJgLFxuICAgICAgYGRhdGEtcG9zPVwiJHt0aGlzLmVzY2FwZUh0bWwoZW50cnkucGFydE9mU3BlZWNoKX1cImAsXG4gICAgXTtcblxuICAgIGlmIChlbnRyeS5wcm9udW5jaWF0aW9uKSB7XG4gICAgICBhdHRycy5wdXNoKGBkYXRhLXByb251bmNpYXRpb249XCIke3RoaXMuZXNjYXBlSHRtbChlbnRyeS5wcm9udW5jaWF0aW9uKX1cImApO1xuICAgIH1cblxuICAgIHJldHVybiBgPHNwYW4gJHthdHRycy5qb2luKCcgJyl9PiR7dGhpcy5lc2NhcGVIdG1sKGZvcmVpZ25Xb3JkKX08L3NwYW4+YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc2NhcGUgSFRNTCBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICovXG4gIHByaXZhdGUgZXNjYXBlSHRtbCh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0ZXh0XG4gICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgICAgLnJlcGxhY2UoLycvZywgJyYjMDM5OycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSByZXBsYWNlciBvcHRpb25zXG4gICAqL1xuICB1cGRhdGVPcHRpb25zKG9wdGlvbnM6IFBhcnRpYWw8UmVwbGFjZXJPcHRpb25zPik6IHZvaWQge1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zLCAuLi5vcHRpb25zIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgb3B0aW9uc1xuICAgKi9cbiAgZ2V0T3B0aW9ucygpOiBSZXF1aXJlZDxSZXBsYWNlck9wdGlvbnM+IHtcbiAgICByZXR1cm4geyAuLi50aGlzLm9wdGlvbnMgfTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgZmFjdG9yeSBmdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVdvcmRSZXBsYWNlcihvcHRpb25zPzogUGFydGlhbDxSZXBsYWNlck9wdGlvbnM+KTogV29yZFJlcGxhY2VyIHtcbiAgcmV0dXJuIG5ldyBXb3JkUmVwbGFjZXIob3B0aW9ucyk7XG59XG4iLCIvKipcbiAqIERhdGFiYXNlIFNjaGVtYSAtIFNRTCBkZWZpbml0aW9ucyBmb3IgU1FMaXRlIGRhdGFiYXNlXG4gKi9cblxuZXhwb3J0IGNvbnN0IERhdGFiYXNlU2NoZW1hID0ge1xuICAvKipcbiAgICogQ3JlYXRlIGFsbCB0YWJsZXNcbiAgICovXG4gIGNyZWF0ZVRhYmxlczogYFxuICAgIC0tIEJvb2tzIHRhYmxlXG4gICAgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgYm9va3MgKFxuICAgICAgaWQgVEVYVCBQUklNQVJZIEtFWSxcbiAgICAgIHRpdGxlIFRFWFQgTk9UIE5VTEwsXG4gICAgICBhdXRob3IgVEVYVCxcbiAgICAgIGNvdmVyX3BhdGggVEVYVCxcbiAgICAgIGZpbGVfcGF0aCBURVhUIE5PVCBOVUxMLFxuICAgICAgZm9ybWF0IFRFWFQgTk9UIE5VTEwsXG4gICAgICBhZGRlZF9hdCBJTlRFR0VSIE5PVCBOVUxMLFxuICAgICAgbGFzdF9yZWFkX2F0IElOVEVHRVIsXG4gICAgICBwcm9ncmVzcyBSRUFMIERFRkFVTFQgMCxcbiAgICAgIGN1cnJlbnRfbG9jYXRpb24gVEVYVCxcbiAgICAgIHNvdXJjZV9sYW5nIFRFWFQgTk9UIE5VTEwsXG4gICAgICB0YXJnZXRfbGFuZyBURVhUIE5PVCBOVUxMLFxuICAgICAgcHJvZmljaWVuY3kgVEVYVCBOT1QgTlVMTCxcbiAgICAgIGRlbnNpdHkgUkVBTCBERUZBVUxUIDAuM1xuICAgICk7XG5cbiAgICAtLSBWb2NhYnVsYXJ5IHRhYmxlXG4gICAgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgdm9jYWJ1bGFyeSAoXG4gICAgICBpZCBURVhUIFBSSU1BUlkgS0VZLFxuICAgICAgc291cmNlX3dvcmQgVEVYVCBOT1QgTlVMTCxcbiAgICAgIHRhcmdldF93b3JkIFRFWFQgTk9UIE5VTEwsXG4gICAgICBzb3VyY2VfbGFuZyBURVhUIE5PVCBOVUxMLFxuICAgICAgdGFyZ2V0X2xhbmcgVEVYVCBOT1QgTlVMTCxcbiAgICAgIGNvbnRleHRfc2VudGVuY2UgVEVYVCxcbiAgICAgIGJvb2tfaWQgVEVYVCxcbiAgICAgIGFkZGVkX2F0IElOVEVHRVIgTk9UIE5VTEwsXG4gICAgICBsYXN0X3Jldmlld2VkX2F0IElOVEVHRVIsXG4gICAgICByZXZpZXdfY291bnQgSU5URUdFUiBERUZBVUxUIDAsXG4gICAgICBlYXNlX2ZhY3RvciBSRUFMIERFRkFVTFQgMi41LFxuICAgICAgaW50ZXJ2YWwgSU5URUdFUiBERUZBVUxUIDAsXG4gICAgICBzdGF0dXMgVEVYVCBERUZBVUxUICduZXcnLFxuICAgICAgRk9SRUlHTiBLRVkgKGJvb2tfaWQpIFJFRkVSRU5DRVMgYm9va3MoaWQpIE9OIERFTEVURSBTRVQgTlVMTFxuICAgICk7XG5cbiAgICAtLSBSZWFkaW5nIHNlc3Npb25zIHRhYmxlXG4gICAgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgcmVhZGluZ19zZXNzaW9ucyAoXG4gICAgICBpZCBURVhUIFBSSU1BUlkgS0VZLFxuICAgICAgYm9va19pZCBURVhUIE5PVCBOVUxMLFxuICAgICAgc3RhcnRlZF9hdCBJTlRFR0VSIE5PVCBOVUxMLFxuICAgICAgZW5kZWRfYXQgSU5URUdFUixcbiAgICAgIHBhZ2VzX3JlYWQgSU5URUdFUiBERUZBVUxUIDAsXG4gICAgICB3b3Jkc19yZXZlYWxlZCBJTlRFR0VSIERFRkFVTFQgMCxcbiAgICAgIHdvcmRzX3NhdmVkIElOVEVHRVIgREVGQVVMVCAwLFxuICAgICAgRk9SRUlHTiBLRVkgKGJvb2tfaWQpIFJFRkVSRU5DRVMgYm9va3MoaWQpIE9OIERFTEVURSBDQVNDQURFXG4gICAgKTtcblxuICAgIC0tIFVzZXIgcHJlZmVyZW5jZXMgdGFibGVcbiAgICBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyBwcmVmZXJlbmNlcyAoXG4gICAgICBrZXkgVEVYVCBQUklNQVJZIEtFWSxcbiAgICAgIHZhbHVlIFRFWFQgTk9UIE5VTExcbiAgICApO1xuXG4gICAgLS0gV29yZCBsaXN0IHRhYmxlIChwb3B1bGF0ZWQgZnJvbSBidW5kbGVkIGFzc2V0cylcbiAgICBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyB3b3JkX2xpc3QgKFxuICAgICAgaWQgVEVYVCBQUklNQVJZIEtFWSxcbiAgICAgIHNvdXJjZV93b3JkIFRFWFQgTk9UIE5VTEwsXG4gICAgICB0YXJnZXRfd29yZCBURVhUIE5PVCBOVUxMLFxuICAgICAgc291cmNlX2xhbmcgVEVYVCBOT1QgTlVMTCxcbiAgICAgIHRhcmdldF9sYW5nIFRFWFQgTk9UIE5VTEwsXG4gICAgICBwcm9maWNpZW5jeSBURVhUIE5PVCBOVUxMLFxuICAgICAgZnJlcXVlbmN5X3JhbmsgSU5URUdFUixcbiAgICAgIHBhcnRfb2Zfc3BlZWNoIFRFWFQsXG4gICAgICB2YXJpYW50cyBURVhULFxuICAgICAgcHJvbnVuY2lhdGlvbiBURVhUXG4gICAgKTtcblxuICAgIC0tIENyZWF0ZSBpbmRleGVzIGZvciBmYXN0ZXIgcXVlcmllc1xuICAgIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIGlkeF92b2NhYnVsYXJ5X2Jvb2sgT04gdm9jYWJ1bGFyeShib29rX2lkKTtcbiAgICBDUkVBVEUgSU5ERVggSUYgTk9UIEVYSVNUUyBpZHhfdm9jYWJ1bGFyeV9zdGF0dXMgT04gdm9jYWJ1bGFyeShzdGF0dXMpO1xuICAgIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIGlkeF92b2NhYnVsYXJ5X3NvdXJjZSBPTiB2b2NhYnVsYXJ5KHNvdXJjZV93b3JkKTtcbiAgICBDUkVBVEUgSU5ERVggSUYgTk9UIEVYSVNUUyBpZHhfd29yZF9saXN0X3NvdXJjZSBPTiB3b3JkX2xpc3Qoc291cmNlX3dvcmQpO1xuICAgIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIGlkeF93b3JkX2xpc3RfbGFuZ3MgT04gd29yZF9saXN0KHNvdXJjZV9sYW5nLCB0YXJnZXRfbGFuZyk7XG4gICAgQ1JFQVRFIElOREVYIElGIE5PVCBFWElTVFMgaWR4X3dvcmRfbGlzdF9wcm9maWNpZW5jeSBPTiB3b3JkX2xpc3QocHJvZmljaWVuY3kpO1xuICAgIENSRUFURSBJTkRFWCBJRiBOT1QgRVhJU1RTIGlkeF9yZWFkaW5nX3Nlc3Npb25zX2Jvb2sgT04gcmVhZGluZ19zZXNzaW9ucyhib29rX2lkKTtcbiAgYCxcblxuICAvKipcbiAgICogUXVlcmllcyBmb3IgYm9va3NcbiAgICovXG4gIGJvb2tzOiB7XG4gICAgaW5zZXJ0OiBgXG4gICAgICBJTlNFUlQgSU5UTyBib29rcyAoaWQsIHRpdGxlLCBhdXRob3IsIGNvdmVyX3BhdGgsIGZpbGVfcGF0aCwgZm9ybWF0LCBhZGRlZF9hdCwgc291cmNlX2xhbmcsIHRhcmdldF9sYW5nLCBwcm9maWNpZW5jeSwgZGVuc2l0eSlcbiAgICAgIFZBTFVFUyAoPywgPywgPywgPywgPywgPywgPywgPywgPywgPywgPylcbiAgICBgLFxuICAgIHVwZGF0ZTogYFxuICAgICAgVVBEQVRFIGJvb2tzIFNFVFxuICAgICAgICB0aXRsZSA9IENPQUxFU0NFKD8sIHRpdGxlKSxcbiAgICAgICAgYXV0aG9yID0gQ09BTEVTQ0UoPywgYXV0aG9yKSxcbiAgICAgICAgY292ZXJfcGF0aCA9IENPQUxFU0NFKD8sIGNvdmVyX3BhdGgpLFxuICAgICAgICBsYXN0X3JlYWRfYXQgPSBDT0FMRVNDRSg/LCBsYXN0X3JlYWRfYXQpLFxuICAgICAgICBwcm9ncmVzcyA9IENPQUxFU0NFKD8sIHByb2dyZXNzKSxcbiAgICAgICAgY3VycmVudF9sb2NhdGlvbiA9IENPQUxFU0NFKD8sIGN1cnJlbnRfbG9jYXRpb24pLFxuICAgICAgICBwcm9maWNpZW5jeSA9IENPQUxFU0NFKD8sIHByb2ZpY2llbmN5KSxcbiAgICAgICAgZGVuc2l0eSA9IENPQUxFU0NFKD8sIGRlbnNpdHkpXG4gICAgICBXSEVSRSBpZCA9ID9cbiAgICBgLFxuICAgIGRlbGV0ZTogJ0RFTEVURSBGUk9NIGJvb2tzIFdIRVJFIGlkID0gPycsXG4gICAgZ2V0QnlJZDogJ1NFTEVDVCAqIEZST00gYm9va3MgV0hFUkUgaWQgPSA/JyxcbiAgICBnZXRBbGw6ICdTRUxFQ1QgKiBGUk9NIGJvb2tzIE9SREVSIEJZIGxhc3RfcmVhZF9hdCBERVNDLCBhZGRlZF9hdCBERVNDJyxcbiAgICBzZWFyY2g6IGBcbiAgICAgIFNFTEVDVCAqIEZST00gYm9va3NcbiAgICAgIFdIRVJFIHRpdGxlIExJS0UgPyBPUiBhdXRob3IgTElLRSA/XG4gICAgICBPUkRFUiBCWSBsYXN0X3JlYWRfYXQgREVTQ1xuICAgIGAsXG4gIH0sXG5cbiAgLyoqXG4gICAqIFF1ZXJpZXMgZm9yIHZvY2FidWxhcnlcbiAgICovXG4gIHZvY2FidWxhcnk6IHtcbiAgICBpbnNlcnQ6IGBcbiAgICAgIElOU0VSVCBJTlRPIHZvY2FidWxhcnkgKGlkLCBzb3VyY2Vfd29yZCwgdGFyZ2V0X3dvcmQsIHNvdXJjZV9sYW5nLCB0YXJnZXRfbGFuZywgY29udGV4dF9zZW50ZW5jZSwgYm9va19pZCwgYWRkZWRfYXQsIHN0YXR1cylcbiAgICAgIFZBTFVFUyAoPywgPywgPywgPywgPywgPywgPywgPywgJ25ldycpXG4gICAgYCxcbiAgICB1cGRhdGU6IGBcbiAgICAgIFVQREFURSB2b2NhYnVsYXJ5IFNFVFxuICAgICAgICBsYXN0X3Jldmlld2VkX2F0ID0gQ09BTEVTQ0UoPywgbGFzdF9yZXZpZXdlZF9hdCksXG4gICAgICAgIHJldmlld19jb3VudCA9IENPQUxFU0NFKD8sIHJldmlld19jb3VudCksXG4gICAgICAgIGVhc2VfZmFjdG9yID0gQ09BTEVTQ0UoPywgZWFzZV9mYWN0b3IpLFxuICAgICAgICBpbnRlcnZhbCA9IENPQUxFU0NFKD8sIGludGVydmFsKSxcbiAgICAgICAgc3RhdHVzID0gQ09BTEVTQ0UoPywgc3RhdHVzKVxuICAgICAgV0hFUkUgaWQgPSA/XG4gICAgYCxcbiAgICBkZWxldGU6ICdERUxFVEUgRlJPTSB2b2NhYnVsYXJ5IFdIRVJFIGlkID0gPycsXG4gICAgZ2V0QnlJZDogJ1NFTEVDVCAqIEZST00gdm9jYWJ1bGFyeSBXSEVSRSBpZCA9ID8nLFxuICAgIGdldEFsbDogJ1NFTEVDVCAqIEZST00gdm9jYWJ1bGFyeSBPUkRFUiBCWSBhZGRlZF9hdCBERVNDJyxcbiAgICBnZXRCeVN0YXR1czogJ1NFTEVDVCAqIEZST00gdm9jYWJ1bGFyeSBXSEVSRSBzdGF0dXMgPSA/IE9SREVSIEJZIGFkZGVkX2F0IERFU0MnLFxuICAgIGdldEJ5Qm9vazogJ1NFTEVDVCAqIEZST00gdm9jYWJ1bGFyeSBXSEVSRSBib29rX2lkID0gPyBPUkRFUiBCWSBhZGRlZF9hdCBERVNDJyxcbiAgICBnZXREdWVGb3JSZXZpZXc6IGBcbiAgICAgIFNFTEVDVCAqIEZST00gdm9jYWJ1bGFyeVxuICAgICAgV0hFUkUgc3RhdHVzICE9ICdsZWFybmVkJ1xuICAgICAgQU5EIChsYXN0X3Jldmlld2VkX2F0IElTIE5VTEwgT1IgKGxhc3RfcmV2aWV3ZWRfYXQgKyBpbnRlcnZhbCAqIDg2NDAwMDAwKSA8PSA/KVxuICAgICAgT1JERVIgQlkgbGFzdF9yZXZpZXdlZF9hdCBBU0NcbiAgICBgLFxuICAgIHNlYXJjaDogYFxuICAgICAgU0VMRUNUICogRlJPTSB2b2NhYnVsYXJ5XG4gICAgICBXSEVSRSBzb3VyY2Vfd29yZCBMSUtFID8gT1IgdGFyZ2V0X3dvcmQgTElLRSA/XG4gICAgICBPUkRFUiBCWSBhZGRlZF9hdCBERVNDXG4gICAgYCxcbiAgfSxcblxuICAvKipcbiAgICogUXVlcmllcyBmb3IgcmVhZGluZyBzZXNzaW9uc1xuICAgKi9cbiAgc2Vzc2lvbnM6IHtcbiAgICBpbnNlcnQ6IGBcbiAgICAgIElOU0VSVCBJTlRPIHJlYWRpbmdfc2Vzc2lvbnMgKGlkLCBib29rX2lkLCBzdGFydGVkX2F0KVxuICAgICAgVkFMVUVTICg/LCA/LCA/KVxuICAgIGAsXG4gICAgZW5kOiBgXG4gICAgICBVUERBVEUgcmVhZGluZ19zZXNzaW9ucyBTRVRcbiAgICAgICAgZW5kZWRfYXQgPSA/LFxuICAgICAgICBwYWdlc19yZWFkID0gPyxcbiAgICAgICAgd29yZHNfcmV2ZWFsZWQgPSA/LFxuICAgICAgICB3b3Jkc19zYXZlZCA9ID9cbiAgICAgIFdIRVJFIGlkID0gP1xuICAgIGAsXG4gICAgZ2V0QnlCb29rOiAnU0VMRUNUICogRlJPTSByZWFkaW5nX3Nlc3Npb25zIFdIRVJFIGJvb2tfaWQgPSA/IE9SREVSIEJZIHN0YXJ0ZWRfYXQgREVTQycsXG4gICAgZ2V0UmVjZW50OiAnU0VMRUNUICogRlJPTSByZWFkaW5nX3Nlc3Npb25zIE9SREVSIEJZIHN0YXJ0ZWRfYXQgREVTQyBMSU1JVCA/JyxcbiAgICBnZXRTdGF0czogYFxuICAgICAgU0VMRUNUXG4gICAgICAgIENPVU5UKERJU1RJTkNUIGJvb2tfaWQpIGFzIGJvb2tzX3JlYWQsXG4gICAgICAgIFNVTShlbmRlZF9hdCAtIHN0YXJ0ZWRfYXQpIGFzIHRvdGFsX3RpbWUsXG4gICAgICAgIFNVTSh3b3Jkc19zYXZlZCkgYXMgd29yZHNfc2F2ZWQsXG4gICAgICAgIEFWRyhlbmRlZF9hdCAtIHN0YXJ0ZWRfYXQpIGFzIGF2Z19zZXNzaW9uXG4gICAgICBGUk9NIHJlYWRpbmdfc2Vzc2lvbnNcbiAgICAgIFdIRVJFIGVuZGVkX2F0IElTIE5PVCBOVUxMXG4gICAgYCxcbiAgfSxcblxuICAvKipcbiAgICogUXVlcmllcyBmb3IgcHJlZmVyZW5jZXNcbiAgICovXG4gIHByZWZlcmVuY2VzOiB7XG4gICAgc2V0OiAnSU5TRVJUIE9SIFJFUExBQ0UgSU5UTyBwcmVmZXJlbmNlcyAoa2V5LCB2YWx1ZSkgVkFMVUVTICg/LCA/KScsXG4gICAgZ2V0OiAnU0VMRUNUIHZhbHVlIEZST00gcHJlZmVyZW5jZXMgV0hFUkUga2V5ID0gPycsXG4gICAgZ2V0QWxsOiAnU0VMRUNUICogRlJPTSBwcmVmZXJlbmNlcycsXG4gICAgZGVsZXRlOiAnREVMRVRFIEZST00gcHJlZmVyZW5jZXMgV0hFUkUga2V5ID0gPycsXG4gIH0sXG5cbiAgLyoqXG4gICAqIFF1ZXJpZXMgZm9yIHdvcmQgbGlzdFxuICAgKi9cbiAgd29yZExpc3Q6IHtcbiAgICBpbnNlcnQ6IGBcbiAgICAgIElOU0VSVCBJTlRPIHdvcmRfbGlzdCAoaWQsIHNvdXJjZV93b3JkLCB0YXJnZXRfd29yZCwgc291cmNlX2xhbmcsIHRhcmdldF9sYW5nLCBwcm9maWNpZW5jeSwgZnJlcXVlbmN5X3JhbmssIHBhcnRfb2Zfc3BlZWNoLCB2YXJpYW50cywgcHJvbnVuY2lhdGlvbilcbiAgICAgIFZBTFVFUyAoPywgPywgPywgPywgPywgPywgPywgPywgPywgPylcbiAgICBgLFxuICAgIGdldEJ5V29yZDogYFxuICAgICAgU0VMRUNUICogRlJPTSB3b3JkX2xpc3RcbiAgICAgIFdIRVJFIHNvdXJjZV93b3JkID0gPyBBTkQgc291cmNlX2xhbmcgPSA/IEFORCB0YXJnZXRfbGFuZyA9ID9cbiAgICBgLFxuICAgIGdldEJ5TGV2ZWw6IGBcbiAgICAgIFNFTEVDVCAqIEZST00gd29yZF9saXN0XG4gICAgICBXSEVSRSBzb3VyY2VfbGFuZyA9ID8gQU5EIHRhcmdldF9sYW5nID0gPyBBTkQgcHJvZmljaWVuY3kgPSA/XG4gICAgICBPUkRFUiBCWSBmcmVxdWVuY3lfcmFua1xuICAgIGAsXG4gICAgY291bnQ6IGBcbiAgICAgIFNFTEVDVCBDT1VOVCgqKSBhcyBjb3VudCBGUk9NIHdvcmRfbGlzdFxuICAgICAgV0hFUkUgc291cmNlX2xhbmcgPSA/IEFORCB0YXJnZXRfbGFuZyA9ID9cbiAgICBgLFxuICB9LFxufTtcbiIsIi8qKlxuICogVGhpbiBFU00gd3JhcHBlciBmb3IgQ0pTIG5hbWVkIGV4cG9ydHMuXG4gKlxuICogUmVmOiBodHRwczovL3JlZGZpbi5lbmdpbmVlcmluZy9ub2RlLW1vZHVsZXMtYXQtd2FyLXdoeS1jb21tb25qcy1hbmQtZXMtbW9kdWxlcy1jYW50LWdldC1hbG9uZy05NjE3MTM1ZWVjYTFcbiAqL1xuXG5pbXBvcnQgbWVyZ2VPcHRpb25zIGZyb20gJy4vaW5kZXguanMnO1xuZXhwb3J0IGRlZmF1bHQgbWVyZ2VPcHRpb25zO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE5pY29sYXMgR2FsbGFnaGVyLlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaW1wb3J0IG1lcmdlT3B0aW9ucyBmcm9tIFwibWVyZ2Utb3B0aW9uc1wiO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuXG5jb25zdCBtZXJnZSA9IG1lcmdlT3B0aW9ucy5iaW5kKHtcbiAgY29uY2F0QXJyYXlzOiB0cnVlLFxuICBpZ25vcmVVbmRlZmluZWQ6IHRydWVcbn0pO1xuZnVuY3Rpb24gbWVyZ2VMb2NhbFN0b3JhZ2VJdGVtKGtleSwgdmFsdWUpIHtcbiAgY29uc3Qgb2xkVmFsdWUgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgaWYgKG9sZFZhbHVlKSB7XG4gICAgY29uc3Qgb2xkT2JqZWN0ID0gSlNPTi5wYXJzZShvbGRWYWx1ZSk7XG4gICAgY29uc3QgbmV3T2JqZWN0ID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgY29uc3QgbmV4dFZhbHVlID0gSlNPTi5zdHJpbmdpZnkobWVyZ2Uob2xkT2JqZWN0LCBuZXdPYmplY3QpKTtcbiAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBuZXh0VmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJvbWlzZShnZXRWYWx1ZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZSgpO1xuICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKG51bGwsIHZhbHVlKTtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKGVycik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvbWlzZUFsbChwcm9taXNlcywgY2FsbGJhY2ssIHByb2Nlc3NSZXN1bHQpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSAocHJvY2Vzc1Jlc3VsdCA9PT0gbnVsbCB8fCBwcm9jZXNzUmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzUmVzdWx0KHJlc3VsdCkpID8/IG51bGw7XG4gICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKG51bGwsIHZhbHVlKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbiAgfSwgZXJyb3JzID0+IHtcbiAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soZXJyb3JzKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JzKTtcbiAgfSk7XG59XG5jb25zdCBBc3luY1N0b3JhZ2UgPSB7XG4gIC8qKlxuICAgKiBGZXRjaGVzIGBrZXlgIHZhbHVlLlxuICAgKi9cbiAgZ2V0SXRlbTogKGtleSwgY2FsbGJhY2spID0+IHtcbiAgICByZXR1cm4gY3JlYXRlUHJvbWlzZSgoKSA9PiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSwgY2FsbGJhY2spO1xuICB9LFxuICAvKipcbiAgICogU2V0cyBgdmFsdWVgIGZvciBga2V5YC5cbiAgICovXG4gIHNldEl0ZW06IChrZXksIHZhbHVlLCBjYWxsYmFjaykgPT4ge1xuICAgIHJldHVybiBjcmVhdGVQcm9taXNlKCgpID0+IHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKSwgY2FsbGJhY2spO1xuICB9LFxuICAvKipcbiAgICogUmVtb3ZlcyBhIGBrZXlgXG4gICAqL1xuICByZW1vdmVJdGVtOiAoa2V5LCBjYWxsYmFjaykgPT4ge1xuICAgIHJldHVybiBjcmVhdGVQcm9taXNlKCgpID0+IHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpLCBjYWxsYmFjayk7XG4gIH0sXG4gIC8qKlxuICAgKiBNZXJnZXMgZXhpc3RpbmcgdmFsdWUgd2l0aCBpbnB1dCB2YWx1ZSwgYXNzdW1pbmcgdGhleSBhcmUgc3RyaW5naWZpZWQgSlNPTi5cbiAgICovXG4gIG1lcmdlSXRlbTogKGtleSwgdmFsdWUsIGNhbGxiYWNrKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZVByb21pc2UoKCkgPT4gbWVyZ2VMb2NhbFN0b3JhZ2VJdGVtKGtleSwgdmFsdWUpLCBjYWxsYmFjayk7XG4gIH0sXG4gIC8qKlxuICAgKiBFcmFzZXMgKmFsbCogQXN5bmNTdG9yYWdlIGZvciB0aGUgZG9tYWluLlxuICAgKi9cbiAgY2xlYXI6IGNhbGxiYWNrID0+IHtcbiAgICByZXR1cm4gY3JlYXRlUHJvbWlzZSgoKSA9PiB3aW5kb3cubG9jYWxTdG9yYWdlLmNsZWFyKCksIGNhbGxiYWNrKTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldHMgKmFsbCoga2V5cyBrbm93biB0byB0aGUgYXBwLCBmb3IgYWxsIGNhbGxlcnMsIGxpYnJhcmllcywgZXRjLlxuICAgKi9cbiAgZ2V0QWxsS2V5czogY2FsbGJhY2sgPT4ge1xuICAgIHJldHVybiBjcmVhdGVQcm9taXNlKCgpID0+IHtcbiAgICAgIGNvbnN0IG51bWJlck9mS2V5cyA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UubGVuZ3RoO1xuICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZktleXM7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBrZXkgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmtleShpKSB8fCBcIlwiO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH0sIGNhbGxiYWNrKTtcbiAgfSxcbiAgLyoqXG4gICAqIChzdHViKSBGbHVzaGVzIGFueSBwZW5kaW5nIHJlcXVlc3RzIHVzaW5nIGEgc2luZ2xlIGJhdGNoIGNhbGwgdG8gZ2V0IHRoZSBkYXRhLlxuICAgKi9cbiAgZmx1c2hHZXRSZXF1ZXN0czogKCkgPT4gdW5kZWZpbmVkLFxuICAvKipcbiAgICogbXVsdGlHZXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2Yga2V5LXZhbHVlIHBhaXIgYXJyYXlzIHRoYXQgbWF0Y2hlcyB0aGVcbiAgICogaW5wdXQgZm9ybWF0IG9mIG11bHRpU2V0LlxuICAgKlxuICAgKiAgIG11bHRpR2V0KFsnazEnLCAnazInXSkgLT4gW1snazEnLCAndmFsMSddLCBbJ2syJywgJ3ZhbDInXV1cbiAgICovXG4gIG11bHRpR2V0OiAoa2V5cywgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCBwcm9taXNlcyA9IGtleXMubWFwKGtleSA9PiBBc3luY1N0b3JhZ2UuZ2V0SXRlbShrZXkpKTtcbiAgICBjb25zdCBwcm9jZXNzUmVzdWx0ID0gcmVzdWx0ID0+IHJlc3VsdC5tYXAoKHZhbHVlLCBpKSA9PiBba2V5c1tpXSwgdmFsdWVdKTtcbiAgICByZXR1cm4gY3JlYXRlUHJvbWlzZUFsbChwcm9taXNlcywgY2FsbGJhY2ssIHByb2Nlc3NSZXN1bHQpO1xuICB9LFxuICAvKipcbiAgICogVGFrZXMgYW4gYXJyYXkgb2Yga2V5LXZhbHVlIGFycmF5IHBhaXJzLlxuICAgKiAgIG11bHRpU2V0KFtbJ2sxJywgJ3ZhbDEnXSwgWydrMicsICd2YWwyJ11dKVxuICAgKi9cbiAgbXVsdGlTZXQ6IChrZXlWYWx1ZVBhaXJzLCBjYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IHByb21pc2VzID0ga2V5VmFsdWVQYWlycy5tYXAoaXRlbSA9PiBBc3luY1N0b3JhZ2Uuc2V0SXRlbShpdGVtWzBdLCBpdGVtWzFdKSk7XG4gICAgcmV0dXJuIGNyZWF0ZVByb21pc2VBbGwocHJvbWlzZXMsIGNhbGxiYWNrKTtcbiAgfSxcbiAgLyoqXG4gICAqIERlbGV0ZSBhbGwgdGhlIGtleXMgaW4gdGhlIGBrZXlzYCBhcnJheS5cbiAgICovXG4gIG11bHRpUmVtb3ZlOiAoa2V5cywgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCBwcm9taXNlcyA9IGtleXMubWFwKGtleSA9PiBBc3luY1N0b3JhZ2UucmVtb3ZlSXRlbShrZXkpKTtcbiAgICByZXR1cm4gY3JlYXRlUHJvbWlzZUFsbChwcm9taXNlcywgY2FsbGJhY2spO1xuICB9LFxuICAvKipcbiAgICogVGFrZXMgYW4gYXJyYXkgb2Yga2V5LXZhbHVlIGFycmF5IHBhaXJzIGFuZCBtZXJnZXMgdGhlbSB3aXRoIGV4aXN0aW5nXG4gICAqIHZhbHVlcywgYXNzdW1pbmcgdGhleSBhcmUgc3RyaW5naWZpZWQgSlNPTi5cbiAgICpcbiAgICogICBtdWx0aU1lcmdlKFtbJ2sxJywgJ3ZhbDEnXSwgWydrMicsICd2YWwyJ11dKVxuICAgKi9cbiAgbXVsdGlNZXJnZTogKGtleVZhbHVlUGFpcnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBrZXlWYWx1ZVBhaXJzLm1hcChpdGVtID0+IEFzeW5jU3RvcmFnZS5tZXJnZUl0ZW0oaXRlbVswXSwgaXRlbVsxXSkpO1xuICAgIHJldHVybiBjcmVhdGVQcm9taXNlQWxsKHByb21pc2VzLCBjYWxsYmFjayk7XG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBBc3luY1N0b3JhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3luY1N0b3JhZ2UuanMubWFwIiwiaW1wb3J0IEFzeW5jU3RvcmFnZSBmcm9tIFwiLi9Bc3luY1N0b3JhZ2VcIjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VBc3luY1N0b3JhZ2Uoa2V5KSB7XG4gIHJldHVybiB7XG4gICAgZ2V0SXRlbTogKC4uLmFyZ3MpID0+IEFzeW5jU3RvcmFnZS5nZXRJdGVtKGtleSwgLi4uYXJncyksXG4gICAgc2V0SXRlbTogKC4uLmFyZ3MpID0+IEFzeW5jU3RvcmFnZS5zZXRJdGVtKGtleSwgLi4uYXJncyksXG4gICAgbWVyZ2VJdGVtOiAoLi4uYXJncykgPT4gQXN5bmNTdG9yYWdlLm1lcmdlSXRlbShrZXksIC4uLmFyZ3MpLFxuICAgIHJlbW92ZUl0ZW06ICguLi5hcmdzKSA9PiBBc3luY1N0b3JhZ2UucmVtb3ZlSXRlbShrZXksIC4uLmFyZ3MpXG4gIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rcy5qcy5tYXAiLCJpbXBvcnQgQXN5bmNTdG9yYWdlIGZyb20gXCIuL0FzeW5jU3RvcmFnZVwiO1xuZXhwb3J0IHsgdXNlQXN5bmNTdG9yYWdlIH0gZnJvbSBcIi4vaG9va3NcIjtcbmV4cG9ydCBkZWZhdWx0IEFzeW5jU3RvcmFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qKlxuICogRnJlcXVlbmN5IExpc3QgU2VydmljZSAtIE1hbmFnZXMgZnJlcXVlbmN5LXJhbmtlZCB3b3JkIGxpc3RzXG4gKlxuICogU291cmNlczpcbiAqIC0gQnVuZGxlZDogQ29yZSB2b2NhYnVsYXJ5IGZvciBjb21tb24gbGFuZ3VhZ2UgcGFpcnNcbiAqIC0gT3BlbiBzb3VyY2Ugd29yZCBmcmVxdWVuY3kgbGlzdHMgZnJvbSB2YXJpb3VzIGNvcnBvcmFcbiAqIC0gVXNlci1nZW5lcmF0ZWQgdm9jYWJ1bGFyeSBmcm9tIHJlYWRpbmdcbiAqXG4gKiBXb3JkIGZyZXF1ZW5jeSBkZXRlcm1pbmVzIHByb2ZpY2llbmN5IGxldmVsOlxuICogLSBCZWdpbm5lciAoQTEtQTIpOiBUb3AgNTAwIG1vc3QgZnJlcXVlbnQgd29yZHNcbiAqIC0gSW50ZXJtZWRpYXRlIChCMS1CMik6IFdvcmRzIDUwMS0yMDAwXG4gKiAtIEFkdmFuY2VkIChDMS1DMik6IFdvcmRzIDIwMDEtNTAwMCtcbiAqL1xuXG5pbXBvcnQgQXN5bmNTdG9yYWdlIGZyb20gJ0ByZWFjdC1uYXRpdmUtYXN5bmMtc3RvcmFnZS9hc3luYy1zdG9yYWdlJztcbmltcG9ydCB0eXBlIHsgTGFuZ3VhZ2UsIFByb2ZpY2llbmN5TGV2ZWwgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFR5cGVzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnJlcXVlbmN5V29yZCB7XG4gIHdvcmQ6IHN0cmluZztcbiAgcmFuazogbnVtYmVyO1xuICBmcmVxdWVuY3k/OiBudW1iZXI7XG4gIHBhcnRPZlNwZWVjaD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGcmVxdWVuY3lMaXN0IHtcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlO1xuICBzb3VyY2U6IHN0cmluZztcbiAgbGFzdFVwZGF0ZWQ6IHN0cmluZztcbiAgd29yZENvdW50OiBudW1iZXI7XG4gIHdvcmRzOiBGcmVxdWVuY3lXb3JkW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnJlcXVlbmN5TGlzdFN0YXRzIHtcbiAgbGFuZ3VhZ2U6IExhbmd1YWdlO1xuICB0b3RhbFdvcmRzOiBudW1iZXI7XG4gIGJlZ2lubmVyOiBudW1iZXI7XG4gIGludGVybWVkaWF0ZTogbnVtYmVyO1xuICBhZHZhbmNlZDogbnVtYmVyO1xuICBzb3VyY2U6IHN0cmluZztcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gT3BlbiBTb3VyY2UgRnJlcXVlbmN5IExpc3QgU291cmNlc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIFVSTHMgdG8gb3BlbiBmcmVxdWVuY3kgbGlzdHMgKHZhcmlvdXMgbGljZW5zZXMsIG1vc3RseSBDQy9wdWJsaWMgZG9tYWluKVxuICogVGhlc2UgYXJlIHdvcmQgbGlzdHMgZnJvbSBsaW5ndWlzdGljIHJlc2VhcmNoIGFuZCBvcGVuIGNvcnBvcmFcbiAqL1xuY29uc3QgRlJFUVVFTkNZX0xJU1RfU09VUkNFUzogUmVjb3JkPExhbmd1YWdlLCBzdHJpbmcgfCBudWxsPiA9IHtcbiAgZW46ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vaGVybWl0ZGF2ZS9GcmVxdWVuY3lXb3Jkcy9tYXN0ZXIvY29udGVudC8yMDE4L2VuL2VuXzUway50eHQnLFxuICBlczogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9oZXJtaXRkYXZlL0ZyZXF1ZW5jeVdvcmRzL21hc3Rlci9jb250ZW50LzIwMTgvZXMvZXNfNTBrLnR4dCcsXG4gIGZyOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2hlcm1pdGRhdmUvRnJlcXVlbmN5V29yZHMvbWFzdGVyL2NvbnRlbnQvMjAxOC9mci9mcl81MGsudHh0JyxcbiAgZGU6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vaGVybWl0ZGF2ZS9GcmVxdWVuY3lXb3Jkcy9tYXN0ZXIvY29udGVudC8yMDE4L2RlL2RlXzUway50eHQnLFxuICBpdDogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9oZXJtaXRkYXZlL0ZyZXF1ZW5jeVdvcmRzL21hc3Rlci9jb250ZW50LzIwMTgvaXQvaXRfNTBrLnR4dCcsXG4gIHB0OiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2hlcm1pdGRhdmUvRnJlcXVlbmN5V29yZHMvbWFzdGVyL2NvbnRlbnQvMjAxOC9wdC9wdF81MGsudHh0JyxcbiAgcnU6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vaGVybWl0ZGF2ZS9GcmVxdWVuY3lXb3Jkcy9tYXN0ZXIvY29udGVudC8yMDE4L3J1L3J1XzUway50eHQnLFxuICBlbDogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9oZXJtaXRkYXZlL0ZyZXF1ZW5jeVdvcmRzL21hc3Rlci9jb250ZW50LzIwMTgvZWwvZWxfNTBrLnR4dCcsXG4gIGphOiBudWxsLCAvLyBKYXBhbmVzZSByZXF1aXJlcyBzcGVjaWFsIGhhbmRsaW5nXG4gIHpoOiBudWxsLCAvLyBDaGluZXNlIHJlcXVpcmVzIHNwZWNpYWwgaGFuZGxpbmdcbiAga286IG51bGwsIC8vIEtvcmVhbiByZXF1aXJlcyBzcGVjaWFsIGhhbmRsaW5nXG4gIGFyOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2hlcm1pdGRhdmUvRnJlcXVlbmN5V29yZHMvbWFzdGVyL2NvbnRlbnQvMjAxOC9hci9hcl81MGsudHh0Jyxcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENvbnN0YW50c1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBTVE9SQUdFX1BSRUZJWCA9ICdAeGVub2xleGlhL2ZyZXF1ZW5jeV8nO1xuY29uc3QgTUFYX1dPUkRTX1RPX1NUT1JFID0gNTAwMDtcblxuZXhwb3J0IGNvbnN0IFBST0ZJQ0lFTkNZX1RIUkVTSE9MRFMgPSB7XG4gIGJlZ2lubmVyOiB7IG1pbjogMSwgbWF4OiA1MDAgfSxcbiAgaW50ZXJtZWRpYXRlOiB7IG1pbjogNTAxLCBtYXg6IDIwMDAgfSxcbiAgYWR2YW5jZWQ6IHsgbWluOiAyMDAxLCBtYXg6IDUwMDAgfSxcbn0gYXMgY29uc3Q7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEZyZXF1ZW5jeSBMaXN0IFNlcnZpY2Vcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGNsYXNzIEZyZXF1ZW5jeUxpc3RTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBjYWNoZTogTWFwPExhbmd1YWdlLCBGcmVxdWVuY3lMaXN0PiA9IG5ldyBNYXAoKTtcblxuICAvKipcbiAgICogR2V0IGZyZXF1ZW5jeSBsaXN0IGZvciBhIGxhbmd1YWdlXG4gICAqL1xuICBhc3luYyBnZXRGcmVxdWVuY3lMaXN0KGxhbmd1YWdlOiBMYW5ndWFnZSk6IFByb21pc2U8RnJlcXVlbmN5TGlzdCB8IG51bGw+IHtcbiAgICAvLyBDaGVjayBtZW1vcnkgY2FjaGVcbiAgICBpZiAodGhpcy5jYWNoZS5oYXMobGFuZ3VhZ2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQobGFuZ3VhZ2UpITtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBwZXJzaXN0ZW50IHN0b3JhZ2VcbiAgICBjb25zdCBzdG9yZWQgPSBhd2FpdCB0aGlzLmxvYWRGcm9tU3RvcmFnZShsYW5ndWFnZSk7XG4gICAgaWYgKHN0b3JlZCkge1xuICAgICAgdGhpcy5jYWNoZS5zZXQobGFuZ3VhZ2UsIHN0b3JlZCk7XG4gICAgICByZXR1cm4gc3RvcmVkO1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBmZXRjaCBmcm9tIHJlbW90ZSBzb3VyY2VcbiAgICBjb25zdCBmZXRjaGVkID0gYXdhaXQgdGhpcy5mZXRjaEZyZXF1ZW5jeUxpc3QobGFuZ3VhZ2UpO1xuICAgIGlmIChmZXRjaGVkKSB7XG4gICAgICBhd2FpdCB0aGlzLnNhdmVUb1N0b3JhZ2UobGFuZ3VhZ2UsIGZldGNoZWQpO1xuICAgICAgdGhpcy5jYWNoZS5zZXQobGFuZ3VhZ2UsIGZldGNoZWQpO1xuICAgICAgcmV0dXJuIGZldGNoZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdvcmRzIGZvciBhIHNwZWNpZmljIHByb2ZpY2llbmN5IGxldmVsXG4gICAqL1xuICBhc3luYyBnZXRXb3Jkc0J5UHJvZmljaWVuY3koXG4gICAgbGFuZ3VhZ2U6IExhbmd1YWdlLFxuICAgIGxldmVsOiBQcm9maWNpZW5jeUxldmVsXG4gICk6IFByb21pc2U8RnJlcXVlbmN5V29yZFtdPiB7XG4gICAgY29uc3QgbGlzdCA9IGF3YWl0IHRoaXMuZ2V0RnJlcXVlbmN5TGlzdChsYW5ndWFnZSk7XG4gICAgaWYgKCFsaXN0KSByZXR1cm4gW107XG5cbiAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSBQUk9GSUNJRU5DWV9USFJFU0hPTERTW2xldmVsXTtcbiAgICByZXR1cm4gbGlzdC53b3Jkcy5maWx0ZXIoKHcpID0+IHcucmFuayA+PSBtaW4gJiYgdy5yYW5rIDw9IG1heCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHByb2ZpY2llbmN5IGxldmVsIGZvciBhIHdvcmQgcmFua1xuICAgKi9cbiAgZ2V0UHJvZmljaWVuY3lMZXZlbChyYW5rOiBudW1iZXIpOiBQcm9maWNpZW5jeUxldmVsIHtcbiAgICBpZiAocmFuayA8PSBQUk9GSUNJRU5DWV9USFJFU0hPTERTLmJlZ2lubmVyLm1heCkgcmV0dXJuICdiZWdpbm5lcic7XG4gICAgaWYgKHJhbmsgPD0gUFJPRklDSUVOQ1lfVEhSRVNIT0xEUy5pbnRlcm1lZGlhdGUubWF4KSByZXR1cm4gJ2ludGVybWVkaWF0ZSc7XG4gICAgcmV0dXJuICdhZHZhbmNlZCc7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB3b3JkIGlzIGluIHRoZSBmcmVxdWVuY3kgbGlzdFxuICAgKi9cbiAgYXN5bmMgZ2V0V29yZFJhbmsobGFuZ3VhZ2U6IExhbmd1YWdlLCB3b3JkOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlciB8IG51bGw+IHtcbiAgICBjb25zdCBsaXN0ID0gYXdhaXQgdGhpcy5nZXRGcmVxdWVuY3lMaXN0KGxhbmd1YWdlKTtcbiAgICBpZiAoIWxpc3QpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZFdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgZm91bmQgPSBsaXN0LndvcmRzLmZpbmQoKHcpID0+IHcud29yZC50b0xvd2VyQ2FzZSgpID09PSBub3JtYWxpemVkV29yZCk7XG4gICAgcmV0dXJuIGZvdW5kPy5yYW5rIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHN0YXRpc3RpY3MgYWJvdXQgYSBmcmVxdWVuY3kgbGlzdFxuICAgKi9cbiAgYXN5bmMgZ2V0U3RhdHMobGFuZ3VhZ2U6IExhbmd1YWdlKTogUHJvbWlzZTxGcmVxdWVuY3lMaXN0U3RhdHMgfCBudWxsPiB7XG4gICAgY29uc3QgbGlzdCA9IGF3YWl0IHRoaXMuZ2V0RnJlcXVlbmN5TGlzdChsYW5ndWFnZSk7XG4gICAgaWYgKCFsaXN0KSByZXR1cm4gbnVsbDtcblxuICAgIGxldCBiZWdpbm5lciA9IDA7XG4gICAgbGV0IGludGVybWVkaWF0ZSA9IDA7XG4gICAgbGV0IGFkdmFuY2VkID0gMDtcblxuICAgIGZvciAoY29uc3Qgd29yZCBvZiBsaXN0LndvcmRzKSB7XG4gICAgICBjb25zdCBsZXZlbCA9IHRoaXMuZ2V0UHJvZmljaWVuY3lMZXZlbCh3b3JkLnJhbmspO1xuICAgICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgICBjYXNlICdiZWdpbm5lcic6XG4gICAgICAgICAgYmVnaW5uZXIrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW50ZXJtZWRpYXRlJzpcbiAgICAgICAgICBpbnRlcm1lZGlhdGUrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYWR2YW5jZWQnOlxuICAgICAgICAgIGFkdmFuY2VkKys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgdG90YWxXb3JkczogbGlzdC53b3JkQ291bnQsXG4gICAgICBiZWdpbm5lcixcbiAgICAgIGludGVybWVkaWF0ZSxcbiAgICAgIGFkdmFuY2VkLFxuICAgICAgc291cmNlOiBsaXN0LnNvdXJjZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGZyZXF1ZW5jeSBsaXN0IGlzIGF2YWlsYWJsZSBmb3IgYSBsYW5ndWFnZVxuICAgKi9cbiAgYXN5bmMgaGFzRnJlcXVlbmN5TGlzdChsYW5ndWFnZTogTGFuZ3VhZ2UpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGl0IGNhY2hlZCBvciBzdG9yZWRcbiAgICBpZiAodGhpcy5jYWNoZS5oYXMobGFuZ3VhZ2UpKSByZXR1cm4gdHJ1ZTtcblxuICAgIGNvbnN0IHN0b3JlZCA9IGF3YWl0IHRoaXMubG9hZEZyb21TdG9yYWdlKGxhbmd1YWdlKTtcbiAgICBpZiAoc3RvcmVkKSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIENoZWNrIGlmIHdlIGNhbiBmZXRjaCBpdFxuICAgIHJldHVybiBGUkVRVUVOQ1lfTElTVF9TT1VSQ0VTW2xhbmd1YWdlXSAhPT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbGlzdCBvZiBsYW5ndWFnZXMgd2l0aCBhdmFpbGFibGUgZnJlcXVlbmN5IGRhdGFcbiAgICovXG4gIGdldEF2YWlsYWJsZUxhbmd1YWdlcygpOiBMYW5ndWFnZVtdIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoRlJFUVVFTkNZX0xJU1RfU09VUkNFUylcbiAgICAgIC5maWx0ZXIoKFssIHVybF0pID0+IHVybCAhPT0gbnVsbClcbiAgICAgIC5tYXAoKFtsYW5nXSkgPT4gbGFuZyBhcyBMYW5ndWFnZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCBmcmVxdWVuY3kgbGlzdCBmcm9tIHJlbW90ZSBzb3VyY2VcbiAgICovXG4gIGFzeW5jIHJlZnJlc2hGcmVxdWVuY3lMaXN0KGxhbmd1YWdlOiBMYW5ndWFnZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGZldGNoZWQgPSBhd2FpdCB0aGlzLmZldGNoRnJlcXVlbmN5TGlzdChsYW5ndWFnZSk7XG4gICAgaWYgKGZldGNoZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMuc2F2ZVRvU3RvcmFnZShsYW5ndWFnZSwgZmV0Y2hlZCk7XG4gICAgICB0aGlzLmNhY2hlLnNldChsYW5ndWFnZSwgZmV0Y2hlZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGNhY2hlZCBmcmVxdWVuY3kgbGlzdFxuICAgKi9cbiAgYXN5bmMgY2xlYXJDYWNoZShsYW5ndWFnZT86IExhbmd1YWdlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICB0aGlzLmNhY2hlLmRlbGV0ZShsYW5ndWFnZSk7XG4gICAgICBhd2FpdCBBc3luY1N0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX1BSRUZJWCArIGxhbmd1YWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IEFzeW5jU3RvcmFnZS5nZXRBbGxLZXlzKCk7XG4gICAgICBjb25zdCBmcmVxdWVuY3lLZXlzID0ga2V5cy5maWx0ZXIoKGspID0+IGsuc3RhcnRzV2l0aChTVE9SQUdFX1BSRUZJWCkpO1xuICAgICAgYXdhaXQgQXN5bmNTdG9yYWdlLm11bHRpUmVtb3ZlKGZyZXF1ZW5jeUtleXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHJpdmF0ZSBNZXRob2RzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvKipcbiAgICogRmV0Y2ggZnJlcXVlbmN5IGxpc3QgZnJvbSByZW1vdGUgc291cmNlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGZldGNoRnJlcXVlbmN5TGlzdChsYW5ndWFnZTogTGFuZ3VhZ2UpOiBQcm9taXNlPEZyZXF1ZW5jeUxpc3QgfCBudWxsPiB7XG4gICAgY29uc3QgdXJsID0gRlJFUVVFTkNZX0xJU1RfU09VUkNFU1tsYW5ndWFnZV07XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBObyBmcmVxdWVuY3kgbGlzdCBzb3VyY2UgZm9yICR7bGFuZ3VhZ2V9YCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYEZldGNoaW5nIGZyZXF1ZW5jeSBsaXN0IGZvciAke2xhbmd1YWdlfS4uLmApO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGNvbnN0IHdvcmRzID0gdGhpcy5wYXJzZUZyZXF1ZW5jeVRleHQodGV4dCwgbGFuZ3VhZ2UpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYW5ndWFnZSxcbiAgICAgICAgc291cmNlOiAnRnJlcXVlbmN5V29yZHMvaGVybWl0ZGF2ZScsXG4gICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHdvcmRDb3VudDogd29yZHMubGVuZ3RoLFxuICAgICAgICB3b3Jkczogd29yZHMuc2xpY2UoMCwgTUFYX1dPUkRTX1RPX1NUT1JFKSxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBmZXRjaCBmcmVxdWVuY3kgbGlzdCBmb3IgJHtsYW5ndWFnZX06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGZyZXF1ZW5jeSBsaXN0IHRleHQgZm9ybWF0XG4gICAqIEZvcm1hdDogd29yZCBmcmVxdWVuY3kgKHNwYWNlLXNlcGFyYXRlZCwgb25lIHBlciBsaW5lKVxuICAgKi9cbiAgcHJpdmF0ZSBwYXJzZUZyZXF1ZW5jeVRleHQodGV4dDogc3RyaW5nLCBfbGFuZ3VhZ2U6IExhbmd1YWdlKTogRnJlcXVlbmN5V29yZFtdIHtcbiAgICBjb25zdCBsaW5lcyA9IHRleHQudHJpbSgpLnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCB3b3JkczogRnJlcXVlbmN5V29yZFtdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aCAmJiBpIDwgTUFYX1dPUkRTX1RPX1NUT1JFOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XG4gICAgICBpZiAoIWxpbmUpIGNvbnRpbnVlO1xuXG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoL1xccysvKTtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMSkge1xuICAgICAgICBjb25zdCB3b3JkID0gcGFydHNbMF07XG4gICAgICAgIGNvbnN0IGZyZXF1ZW5jeSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJzZUludChwYXJ0c1sxXSwgMTApIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIFNraXAgdmVyeSBzaG9ydCB3b3JkcywgbnVtYmVycywgYW5kIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgICAgICBpZiAod29yZC5sZW5ndGggPCAyIHx8IC9eXFxkKyQvLnRlc3Qod29yZCkgfHwgL1teYS16QS1aXFx1MDM3MC1cXHUwM0ZGXFx1MDQwMC1cXHUwNEZGXS8udGVzdCh3b3JkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd29yZHMucHVzaCh7XG4gICAgICAgICAgd29yZDogd29yZC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIHJhbms6IHdvcmRzLmxlbmd0aCArIDEsXG4gICAgICAgICAgZnJlcXVlbmN5LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd29yZHM7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBmcmVxdWVuY3kgbGlzdCBmcm9tIHBlcnNpc3RlbnQgc3RvcmFnZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBsb2FkRnJvbVN0b3JhZ2UobGFuZ3VhZ2U6IExhbmd1YWdlKTogUHJvbWlzZTxGcmVxdWVuY3lMaXN0IHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yZWQgPSBhd2FpdCBBc3luY1N0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX1BSRUZJWCArIGxhbmd1YWdlKTtcbiAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RvcmVkKSBhcyBGcmVxdWVuY3lMaXN0O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBsb2FkIGZyZXF1ZW5jeSBsaXN0IGZvciAke2xhbmd1YWdlfTpgLCBlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmUgZnJlcXVlbmN5IGxpc3QgdG8gcGVyc2lzdGVudCBzdG9yYWdlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHNhdmVUb1N0b3JhZ2UobGFuZ3VhZ2U6IExhbmd1YWdlLCBsaXN0OiBGcmVxdWVuY3lMaXN0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IEFzeW5jU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfUFJFRklYICsgbGFuZ3VhZ2UsIEpTT04uc3RyaW5naWZ5KGxpc3QpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gc2F2ZSBmcmVxdWVuY3kgbGlzdCBmb3IgJHtsYW5ndWFnZX06YCwgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgZnJlcXVlbmN5TGlzdFNlcnZpY2UgPSBuZXcgRnJlcXVlbmN5TGlzdFNlcnZpY2UoKTtcbiIsIi8qKlxuICogVHJhbnNsYXRpb24gQVBJIFNlcnZpY2UgLSBNdWx0aS1wcm92aWRlciB0cmFuc2xhdGlvbiBzdXBwb3J0XG4gKlxuICogU3VwcG9ydHMgbXVsdGlwbGUgZnJlZSB0cmFuc2xhdGlvbiBBUElzOlxuICogLSBMaWJyZVRyYW5zbGF0ZSAob3BlbiBzb3VyY2UsIHNlbGYtaG9zdGFibGUpXG4gKiAtIE15TWVtb3J5IChmcmVlIHRpZXI6IDEwMDAgd29yZHMvZGF5KVxuICogLSBMaW5ndmEgVHJhbnNsYXRlIChvcGVuIHNvdXJjZSBHb29nbGUgVHJhbnNsYXRlIGZyb250ZW5kKVxuICpcbiAqIEZlYXR1cmVzOlxuICogLSBBdXRvbWF0aWMgZmFsbGJhY2sgYmV0d2VlbiBwcm92aWRlcnNcbiAqIC0gUmVzcG9uc2UgY2FjaGluZ1xuICogLSBSYXRlIGxpbWl0aW5nXG4gKiAtIE9mZmxpbmUgbW9kZSB3aXRoIGNhY2hlZCB0cmFuc2xhdGlvbnNcbiAqL1xuXG5pbXBvcnQgQXN5bmNTdG9yYWdlIGZyb20gJ0ByZWFjdC1uYXRpdmUtYXN5bmMtc3RvcmFnZS9hc3luYy1zdG9yYWdlJztcbmltcG9ydCB0eXBlIHsgTGFuZ3VhZ2UgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFR5cGVzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCB0eXBlIFRyYW5zbGF0aW9uUHJvdmlkZXIgPSAnbGlicmV0cmFuc2xhdGUnIHwgJ215bWVtb3J5JyB8ICdsaW5ndmEnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbGF0aW9uUmVzdWx0IHtcbiAgdHJhbnNsYXRlZFRleHQ6IHN0cmluZztcbiAgc291cmNlTGFuZ3VhZ2U6IExhbmd1YWdlO1xuICB0YXJnZXRMYW5ndWFnZTogTGFuZ3VhZ2U7XG4gIHByb3ZpZGVyOiBUcmFuc2xhdGlvblByb3ZpZGVyO1xuICBjb25maWRlbmNlPzogbnVtYmVyO1xuICBjYWNoZWQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbGF0aW9uQVBJQ29uZmlnIHtcbiAgcHJvdmlkZXI6IFRyYW5zbGF0aW9uUHJvdmlkZXI7XG4gIGJhc2VVcmw6IHN0cmluZztcbiAgYXBpS2V5Pzogc3RyaW5nO1xuICByYXRlTGltaXQ6IG51bWJlcjsgLy8gcmVxdWVzdHMgcGVyIG1pbnV0ZVxuICBlbmFibGVkOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJ1bGtUcmFuc2xhdGlvblJlc3VsdCB7XG4gIHRyYW5zbGF0aW9uczogTWFwPHN0cmluZywgc3RyaW5nPjtcbiAgcHJvdmlkZXI6IFRyYW5zbGF0aW9uUHJvdmlkZXI7XG4gIGZhaWxlZDogc3RyaW5nW107XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEFQSSBQcm92aWRlciBDb25maWd1cmF0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBERUZBVUxUX1BST1ZJREVSUzogVHJhbnNsYXRpb25BUElDb25maWdbXSA9IFtcbiAge1xuICAgIHByb3ZpZGVyOiAnbGlicmV0cmFuc2xhdGUnLFxuICAgIGJhc2VVcmw6ICdodHRwczovL2xpYnJldHJhbnNsYXRlLmNvbScsXG4gICAgcmF0ZUxpbWl0OiAzMCxcbiAgICBlbmFibGVkOiB0cnVlLFxuICB9LFxuICB7XG4gICAgcHJvdmlkZXI6ICdteW1lbW9yeScsXG4gICAgYmFzZVVybDogJ2h0dHBzOi8vYXBpLm15bWVtb3J5LnRyYW5zbGF0ZWQubmV0JyxcbiAgICByYXRlTGltaXQ6IDEwMCxcbiAgICBlbmFibGVkOiB0cnVlLFxuICB9LFxuICB7XG4gICAgcHJvdmlkZXI6ICdsaW5ndmEnLFxuICAgIGJhc2VVcmw6ICdodHRwczovL2xpbmd2YS5tbCcsXG4gICAgcmF0ZUxpbWl0OiA2MCxcbiAgICBlbmFibGVkOiB0cnVlLFxuICB9LFxuXTtcblxuLy8gQWx0ZXJuYXRpdmUgTGlicmVUcmFuc2xhdGUgaW5zdGFuY2VzIChjb21tdW5pdHktaG9zdGVkKVxuY29uc3QgTElCUkVUUkFOU0xBVEVfTUlSUk9SUyA9IFtcbiAgJ2h0dHBzOi8vbGlicmV0cmFuc2xhdGUuY29tJyxcbiAgJ2h0dHBzOi8vdHJhbnNsYXRlLmFyZ29zb3BlbnRlY2guY29tJyxcbiAgJ2h0dHBzOi8vdHJhbnNsYXRlLnRlcnJhcHJpbnQuY28nLFxuXTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTGFuZ3VhZ2UgQ29kZSBNYXBwaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogTWFwcyBvdXIgaW50ZXJuYWwgbGFuZ3VhZ2UgY29kZXMgdG8gQVBJLXNwZWNpZmljIGNvZGVzXG4gKi9cbmNvbnN0IExBTkdVQUdFX0NPREVTOiBSZWNvcmQ8TGFuZ3VhZ2UsIHsgaXNvNjM5XzE6IHN0cmluZzsgbmFtZTogc3RyaW5nIH0+ID0ge1xuICBlbjogeyBpc282MzlfMTogJ2VuJywgbmFtZTogJ0VuZ2xpc2gnIH0sXG4gIGVsOiB7IGlzbzYzOV8xOiAnZWwnLCBuYW1lOiAnR3JlZWsnIH0sXG4gIGVzOiB7IGlzbzYzOV8xOiAnZXMnLCBuYW1lOiAnU3BhbmlzaCcgfSxcbiAgZnI6IHsgaXNvNjM5XzE6ICdmcicsIG5hbWU6ICdGcmVuY2gnIH0sXG4gIGRlOiB7IGlzbzYzOV8xOiAnZGUnLCBuYW1lOiAnR2VybWFuJyB9LFxuICBpdDogeyBpc282MzlfMTogJ2l0JywgbmFtZTogJ0l0YWxpYW4nIH0sXG4gIHB0OiB7IGlzbzYzOV8xOiAncHQnLCBuYW1lOiAnUG9ydHVndWVzZScgfSxcbiAgcnU6IHsgaXNvNjM5XzE6ICdydScsIG5hbWU6ICdSdXNzaWFuJyB9LFxuICBqYTogeyBpc282MzlfMTogJ2phJywgbmFtZTogJ0phcGFuZXNlJyB9LFxuICB6aDogeyBpc282MzlfMTogJ3poJywgbmFtZTogJ0NoaW5lc2UnIH0sXG4gIGtvOiB7IGlzbzYzOV8xOiAna28nLCBuYW1lOiAnS29yZWFuJyB9LFxuICBhcjogeyBpc282MzlfMTogJ2FyJywgbmFtZTogJ0FyYWJpYycgfSxcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENhY2hlIEtleXNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgQ0FDSEVfUFJFRklYID0gJ0B4ZW5vbGV4aWEvdHJhbnNsYXRpb25fY2FjaGVfJztcbmNvbnN0IFJBVEVfTElNSVRfUFJFRklYID0gJ0B4ZW5vbGV4aWEvcmF0ZV9saW1pdF8nO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBUcmFuc2xhdGlvbiBBUEkgU2VydmljZVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRpb25BUElTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBwcm92aWRlcnM6IFRyYW5zbGF0aW9uQVBJQ29uZmlnW107XG4gIHByaXZhdGUgY2FjaGU6IE1hcDxzdHJpbmcsIFRyYW5zbGF0aW9uUmVzdWx0PiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSByYXRlTGltaXRDb3VudGVyczogTWFwPHN0cmluZywgeyBjb3VudDogbnVtYmVyOyByZXNldFRpbWU6IG51bWJlciB9PiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBjdXJyZW50TWlycm9ySW5kZXg6IG51bWJlciA9IDA7XG5cbiAgY29uc3RydWN0b3IoY3VzdG9tUHJvdmlkZXJzPzogVHJhbnNsYXRpb25BUElDb25maWdbXSkge1xuICAgIHRoaXMucHJvdmlkZXJzID0gY3VzdG9tUHJvdmlkZXJzIHx8IFsuLi5ERUZBVUxUX1BST1ZJREVSU107XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNsYXRlIGEgc2luZ2xlIHdvcmQgb3IgcGhyYXNlXG4gICAqL1xuICBhc3luYyB0cmFuc2xhdGUoXG4gICAgdGV4dDogc3RyaW5nLFxuICAgIHNvdXJjZUxhbmd1YWdlOiBMYW5ndWFnZSxcbiAgICB0YXJnZXRMYW5ndWFnZTogTGFuZ3VhZ2VcbiAgKTogUHJvbWlzZTxUcmFuc2xhdGlvblJlc3VsdD4ge1xuICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0XG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmdldENhY2hlS2V5KHRleHQsIHNvdXJjZUxhbmd1YWdlLCB0YXJnZXRMYW5ndWFnZSk7XG4gICAgY29uc3QgY2FjaGVkID0gYXdhaXQgdGhpcy5nZXRGcm9tQ2FjaGUoY2FjaGVLZXkpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiB7IC4uLmNhY2hlZCwgY2FjaGVkOiB0cnVlIH07XG4gICAgfVxuXG4gICAgLy8gVHJ5IGVhY2ggcHJvdmlkZXIgaW4gb3JkZXJcbiAgICBmb3IgKGNvbnN0IHByb3ZpZGVyIG9mIHRoaXMucHJvdmlkZXJzKSB7XG4gICAgICBpZiAoIXByb3ZpZGVyLmVuYWJsZWQpIGNvbnRpbnVlO1xuICAgICAgaWYgKHRoaXMuaXNSYXRlTGltaXRlZChwcm92aWRlci5wcm92aWRlcikpIGNvbnRpbnVlO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnRyYW5zbGF0ZVdpdGhQcm92aWRlcihcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIHNvdXJjZUxhbmd1YWdlLFxuICAgICAgICAgIHRhcmdldExhbmd1YWdlLFxuICAgICAgICAgIHByb3ZpZGVyXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQ2FjaGUgc3VjY2Vzc2Z1bCByZXN1bHRcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlVG9DYWNoZShjYWNoZUtleSwgcmVzdWx0KTtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRSYXRlTGltaXQocHJvdmlkZXIucHJvdmlkZXIpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oYFRyYW5zbGF0aW9uIGZhaWxlZCB3aXRoICR7cHJvdmlkZXIucHJvdmlkZXJ9OmAsIGVycm9yKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbGwgdHJhbnNsYXRpb24gcHJvdmlkZXJzIGZhaWxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSBtdWx0aXBsZSB3b3JkcyBlZmZpY2llbnRseVxuICAgKi9cbiAgYXN5bmMgdHJhbnNsYXRlQnVsayhcbiAgICB3b3Jkczogc3RyaW5nW10sXG4gICAgc291cmNlTGFuZ3VhZ2U6IExhbmd1YWdlLFxuICAgIHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZVxuICApOiBQcm9taXNlPEJ1bGtUcmFuc2xhdGlvblJlc3VsdD4ge1xuICAgIGNvbnN0IHRyYW5zbGF0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gICAgY29uc3QgZmFpbGVkOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHRvVHJhbnNsYXRlOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcbiAgICBmb3IgKGNvbnN0IHdvcmQgb2Ygd29yZHMpIHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5nZXRDYWNoZUtleSh3b3JkLCBzb3VyY2VMYW5ndWFnZSwgdGFyZ2V0TGFuZ3VhZ2UpO1xuICAgICAgY29uc3QgY2FjaGVkID0gYXdhaXQgdGhpcy5nZXRGcm9tQ2FjaGUoY2FjaGVLZXkpO1xuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICB0cmFuc2xhdGlvbnMuc2V0KHdvcmQsIGNhY2hlZC50cmFuc2xhdGVkVGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b1RyYW5zbGF0ZS5wdXNoKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYW5zbGF0ZSB1bmNhY2hlZCB3b3JkcyBpbiBiYXRjaGVzXG4gICAgY29uc3QgYmF0Y2hTaXplID0gMTA7XG4gICAgbGV0IHVzZWRQcm92aWRlcjogVHJhbnNsYXRpb25Qcm92aWRlciA9ICdsaWJyZXRyYW5zbGF0ZSc7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvVHJhbnNsYXRlLmxlbmd0aDsgaSArPSBiYXRjaFNpemUpIHtcbiAgICAgIGNvbnN0IGJhdGNoID0gdG9UcmFuc2xhdGUuc2xpY2UoaSwgaSArIGJhdGNoU2l6ZSk7XG5cbiAgICAgIGZvciAoY29uc3Qgd29yZCBvZiBiYXRjaCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudHJhbnNsYXRlKHdvcmQsIHNvdXJjZUxhbmd1YWdlLCB0YXJnZXRMYW5ndWFnZSk7XG4gICAgICAgICAgdHJhbnNsYXRpb25zLnNldCh3b3JkLCByZXN1bHQudHJhbnNsYXRlZFRleHQpO1xuICAgICAgICAgIHVzZWRQcm92aWRlciA9IHJlc3VsdC5wcm92aWRlcjtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBmYWlsZWQucHVzaCh3b3JkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTbWFsbCBkZWxheSBiZXR3ZWVuIGJhdGNoZXMgdG8gcmVzcGVjdCByYXRlIGxpbWl0c1xuICAgICAgaWYgKGkgKyBiYXRjaFNpemUgPCB0b1RyYW5zbGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5kZWxheSgyMDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHRyYW5zbGF0aW9ucywgcHJvdmlkZXI6IHVzZWRQcm92aWRlciwgZmFpbGVkIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHN1cHBvcnRlZCBsYW5ndWFnZXMgZm9yIGEgcHJvdmlkZXJcbiAgICovXG4gIGFzeW5jIGdldFN1cHBvcnRlZExhbmd1YWdlcyhwcm92aWRlcj86IFRyYW5zbGF0aW9uUHJvdmlkZXIpOiBQcm9taXNlPExhbmd1YWdlW10+IHtcbiAgICBjb25zdCB0YXJnZXRQcm92aWRlciA9IHByb3ZpZGVyIHx8IHRoaXMucHJvdmlkZXJzWzBdLnByb3ZpZGVyO1xuXG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAodGFyZ2V0UHJvdmlkZXIpIHtcbiAgICAgICAgY2FzZSAnbGlicmV0cmFuc2xhdGUnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldExpYnJlVHJhbnNsYXRlTGFuZ3VhZ2VzKCk7XG4gICAgICAgIGNhc2UgJ215bWVtb3J5JzpcbiAgICAgICAgICAvLyBNeU1lbW9yeSBzdXBwb3J0cyBhbGwgbWFqb3IgbGFuZ3VhZ2VzXG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKExBTkdVQUdFX0NPREVTKSBhcyBMYW5ndWFnZVtdO1xuICAgICAgICBjYXNlICdsaW5ndmEnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldExpbmd2YUxhbmd1YWdlcygpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhMQU5HVUFHRV9DT0RFUykgYXMgTGFuZ3VhZ2VbXTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZ2V0IHN1cHBvcnRlZCBsYW5ndWFnZXM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKExBTkdVQUdFX0NPREVTKSBhcyBMYW5ndWFnZVtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGxhbmd1YWdlIHBhaXIgaXMgc3VwcG9ydGVkXG4gICAqL1xuICBhc3luYyBpc0xhbmd1YWdlUGFpclN1cHBvcnRlZChcbiAgICBzb3VyY2VMYW5ndWFnZTogTGFuZ3VhZ2UsXG4gICAgdGFyZ2V0TGFuZ3VhZ2U6IExhbmd1YWdlXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHN1cHBvcnRlZCA9IGF3YWl0IHRoaXMuZ2V0U3VwcG9ydGVkTGFuZ3VhZ2VzKCk7XG4gICAgcmV0dXJuIHN1cHBvcnRlZC5pbmNsdWRlcyhzb3VyY2VMYW5ndWFnZSkgJiYgc3VwcG9ydGVkLmluY2x1ZGVzKHRhcmdldExhbmd1YWdlKTtcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHJvdmlkZXItU3BlY2lmaWMgVHJhbnNsYXRpb24gTWV0aG9kc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgcHJpdmF0ZSBhc3luYyB0cmFuc2xhdGVXaXRoUHJvdmlkZXIoXG4gICAgdGV4dDogc3RyaW5nLFxuICAgIHNvdXJjZUxhbmd1YWdlOiBMYW5ndWFnZSxcbiAgICB0YXJnZXRMYW5ndWFnZTogTGFuZ3VhZ2UsXG4gICAgY29uZmlnOiBUcmFuc2xhdGlvbkFQSUNvbmZpZ1xuICApOiBQcm9taXNlPFRyYW5zbGF0aW9uUmVzdWx0PiB7XG4gICAgc3dpdGNoIChjb25maWcucHJvdmlkZXIpIHtcbiAgICAgIGNhc2UgJ2xpYnJldHJhbnNsYXRlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlV2l0aExpYnJlVHJhbnNsYXRlKHRleHQsIHNvdXJjZUxhbmd1YWdlLCB0YXJnZXRMYW5ndWFnZSwgY29uZmlnKTtcbiAgICAgIGNhc2UgJ215bWVtb3J5JzpcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlV2l0aE15TWVtb3J5KHRleHQsIHNvdXJjZUxhbmd1YWdlLCB0YXJnZXRMYW5ndWFnZSwgY29uZmlnKTtcbiAgICAgIGNhc2UgJ2xpbmd2YSc6XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVdpdGhMaW5ndmEodGV4dCwgc291cmNlTGFuZ3VhZ2UsIHRhcmdldExhbmd1YWdlLCBjb25maWcpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHByb3ZpZGVyOiAke2NvbmZpZy5wcm92aWRlcn1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGlicmVUcmFuc2xhdGUgQVBJXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9MaWJyZVRyYW5zbGF0ZS9MaWJyZVRyYW5zbGF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB0cmFuc2xhdGVXaXRoTGlicmVUcmFuc2xhdGUoXG4gICAgdGV4dDogc3RyaW5nLFxuICAgIHNvdXJjZUxhbmd1YWdlOiBMYW5ndWFnZSxcbiAgICB0YXJnZXRMYW5ndWFnZTogTGFuZ3VhZ2UsXG4gICAgY29uZmlnOiBUcmFuc2xhdGlvbkFQSUNvbmZpZ1xuICApOiBQcm9taXNlPFRyYW5zbGF0aW9uUmVzdWx0PiB7XG4gICAgY29uc3QgYmFzZVVybCA9IHRoaXMuZ2V0TGlicmVUcmFuc2xhdGVNaXJyb3IoY29uZmlnLmJhc2VVcmwpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYXNlVXJsfS90cmFuc2xhdGVgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHE6IHRleHQsXG4gICAgICAgIHNvdXJjZTogTEFOR1VBR0VfQ09ERVNbc291cmNlTGFuZ3VhZ2VdLmlzbzYzOV8xLFxuICAgICAgICB0YXJnZXQ6IExBTkdVQUdFX0NPREVTW3RhcmdldExhbmd1YWdlXS5pc282MzlfMSxcbiAgICAgICAgZm9ybWF0OiAndGV4dCcsXG4gICAgICAgIGFwaV9rZXk6IGNvbmZpZy5hcGlLZXkgfHwgJycsXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIC8vIFRyeSBuZXh0IG1pcnJvclxuICAgICAgdGhpcy5jdXJyZW50TWlycm9ySW5kZXggPSAodGhpcy5jdXJyZW50TWlycm9ySW5kZXggKyAxKSAlIExJQlJFVFJBTlNMQVRFX01JUlJPUlMubGVuZ3RoO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaWJyZVRyYW5zbGF0ZSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2xhdGVkVGV4dDogZGF0YS50cmFuc2xhdGVkVGV4dCxcbiAgICAgIHNvdXJjZUxhbmd1YWdlLFxuICAgICAgdGFyZ2V0TGFuZ3VhZ2UsXG4gICAgICBwcm92aWRlcjogJ2xpYnJldHJhbnNsYXRlJyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE15TWVtb3J5IFRyYW5zbGF0aW9uIEFQSVxuICAgKiBodHRwczovL215bWVtb3J5LnRyYW5zbGF0ZWQubmV0L2RvYy9zcGVjLnBocFxuICAgKiBGcmVlOiAxMDAwIHdvcmRzL2RheSwgMTAwMDAgd2l0aCBlbWFpbFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB0cmFuc2xhdGVXaXRoTXlNZW1vcnkoXG4gICAgdGV4dDogc3RyaW5nLFxuICAgIHNvdXJjZUxhbmd1YWdlOiBMYW5ndWFnZSxcbiAgICB0YXJnZXRMYW5ndWFnZTogTGFuZ3VhZ2UsXG4gICAgY29uZmlnOiBUcmFuc2xhdGlvbkFQSUNvbmZpZ1xuICApOiBQcm9taXNlPFRyYW5zbGF0aW9uUmVzdWx0PiB7XG4gICAgY29uc3QgbGFuZ1BhaXIgPSBgJHtMQU5HVUFHRV9DT0RFU1tzb3VyY2VMYW5ndWFnZV0uaXNvNjM5XzF9fCR7TEFOR1VBR0VfQ09ERVNbdGFyZ2V0TGFuZ3VhZ2VdLmlzbzYzOV8xfWA7XG4gICAgY29uc3QgdXJsID0gYCR7Y29uZmlnLmJhc2VVcmx9L2dldD9xPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHRleHQpfSZsYW5ncGFpcj0ke2xhbmdQYWlyfWA7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE15TWVtb3J5IGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgaWYgKGRhdGEucmVzcG9uc2VTdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNeU1lbW9yeSBlcnJvcjogJHtkYXRhLnJlc3BvbnNlRGV0YWlsc31gKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNsYXRlZFRleHQ6IGRhdGEucmVzcG9uc2VEYXRhLnRyYW5zbGF0ZWRUZXh0LFxuICAgICAgc291cmNlTGFuZ3VhZ2UsXG4gICAgICB0YXJnZXRMYW5ndWFnZSxcbiAgICAgIHByb3ZpZGVyOiAnbXltZW1vcnknLFxuICAgICAgY29uZmlkZW5jZTogZGF0YS5yZXNwb25zZURhdGEubWF0Y2gsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaW5ndmEgVHJhbnNsYXRlIEFQSVxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vdGhlZGF2aWRkZWx0YS9saW5ndmEtdHJhbnNsYXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHRyYW5zbGF0ZVdpdGhMaW5ndmEoXG4gICAgdGV4dDogc3RyaW5nLFxuICAgIHNvdXJjZUxhbmd1YWdlOiBMYW5ndWFnZSxcbiAgICB0YXJnZXRMYW5ndWFnZTogTGFuZ3VhZ2UsXG4gICAgY29uZmlnOiBUcmFuc2xhdGlvbkFQSUNvbmZpZ1xuICApOiBQcm9taXNlPFRyYW5zbGF0aW9uUmVzdWx0PiB7XG4gICAgY29uc3Qgc291cmNlID0gTEFOR1VBR0VfQ09ERVNbc291cmNlTGFuZ3VhZ2VdLmlzbzYzOV8xO1xuICAgIGNvbnN0IHRhcmdldCA9IExBTkdVQUdFX0NPREVTW3RhcmdldExhbmd1YWdlXS5pc282MzlfMTtcbiAgICBjb25zdCB1cmwgPSBgJHtjb25maWcuYmFzZVVybH0vYXBpL3YxLyR7c291cmNlfS8ke3RhcmdldH0vJHtlbmNvZGVVUklDb21wb25lbnQodGV4dCl9YDtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGluZ3ZhIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zbGF0ZWRUZXh0OiBkYXRhLnRyYW5zbGF0aW9uLFxuICAgICAgc291cmNlTGFuZ3VhZ2UsXG4gICAgICB0YXJnZXRMYW5ndWFnZSxcbiAgICAgIHByb3ZpZGVyOiAnbGluZ3ZhJyxcbiAgICB9O1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBMYW5ndWFnZSBTdXBwb3J0IE1ldGhvZHNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0TGlicmVUcmFuc2xhdGVMYW5ndWFnZXMoKTogUHJvbWlzZTxMYW5ndWFnZVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLmdldExpYnJlVHJhbnNsYXRlTWlycm9yKERFRkFVTFRfUFJPVklERVJTWzBdLmJhc2VVcmwpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYXNlVXJsfS9sYW5ndWFnZXNgKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGNvbnN0IHN1cHBvcnRlZDogTGFuZ3VhZ2VbXSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBsYW5nIG9mIGRhdGEpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBPYmplY3QuZW50cmllcyhMQU5HVUFHRV9DT0RFUykuZmluZChcbiAgICAgICAgICAoWywgdl0pID0+IHYuaXNvNjM5XzEgPT09IGxhbmcuY29kZVxuICAgICAgICApO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBzdXBwb3J0ZWQucHVzaChtYXRjaFswXSBhcyBMYW5ndWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhMQU5HVUFHRV9DT0RFUykgYXMgTGFuZ3VhZ2VbXTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldExpbmd2YUxhbmd1YWdlcygpOiBQcm9taXNlPExhbmd1YWdlW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtERUZBVUxUX1BST1ZJREVSU1syXS5iYXNlVXJsfS9hcGkvdjEvbGFuZ3VhZ2VzYCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBjb25zdCBzdXBwb3J0ZWQ6IExhbmd1YWdlW10gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbGFuZyBvZiBkYXRhLmxhbmd1YWdlcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IE9iamVjdC5lbnRyaWVzKExBTkdVQUdFX0NPREVTKS5maW5kKFxuICAgICAgICAgIChbLCB2XSkgPT4gdi5pc282MzlfMSA9PT0gbGFuZy5jb2RlXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHN1cHBvcnRlZC5wdXNoKG1hdGNoWzBdIGFzIExhbmd1YWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKExBTkdVQUdFX0NPREVTKSBhcyBMYW5ndWFnZVtdO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0TGlicmVUcmFuc2xhdGVNaXJyb3IoZGVmYXVsdFVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoTElCUkVUUkFOU0xBVEVfTUlSUk9SUy5pbmNsdWRlcyhkZWZhdWx0VXJsKSkge1xuICAgICAgcmV0dXJuIExJQlJFVFJBTlNMQVRFX01JUlJPUlNbdGhpcy5jdXJyZW50TWlycm9ySW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFVybDtcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gQ2FjaGUgTWV0aG9kc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgcHJpdmF0ZSBnZXRDYWNoZUtleSh0ZXh0OiBzdHJpbmcsIHNvdXJjZTogTGFuZ3VhZ2UsIHRhcmdldDogTGFuZ3VhZ2UpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHtzb3VyY2V9XyR7dGFyZ2V0fV8ke3RleHQudG9Mb3dlckNhc2UoKX1gO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRGcm9tQ2FjaGUoa2V5OiBzdHJpbmcpOiBQcm9taXNlPFRyYW5zbGF0aW9uUmVzdWx0IHwgbnVsbD4ge1xuICAgIC8vIENoZWNrIG1lbW9yeSBjYWNoZVxuICAgIGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoa2V5KSE7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgcGVyc2lzdGVudCBjYWNoZVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yZWQgPSBhd2FpdCBBc3luY1N0b3JhZ2UuZ2V0SXRlbShDQUNIRV9QUkVGSVggKyBrZXkpO1xuICAgICAgaWYgKHN0b3JlZCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKHN0b3JlZCkgYXMgVHJhbnNsYXRpb25SZXN1bHQ7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gQ2FjaGUgbWlzc1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzYXZlVG9DYWNoZShrZXk6IHN0cmluZywgcmVzdWx0OiBUcmFuc2xhdGlvblJlc3VsdCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFNhdmUgdG8gbWVtb3J5IGNhY2hlXG4gICAgdGhpcy5jYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuXG4gICAgLy8gTGltaXQgbWVtb3J5IGNhY2hlIHNpemVcbiAgICBpZiAodGhpcy5jYWNoZS5zaXplID4gMTAwMDApIHtcbiAgICAgIGNvbnN0IGZpcnN0S2V5ID0gdGhpcy5jYWNoZS5rZXlzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgaWYgKGZpcnN0S2V5KSB0aGlzLmNhY2hlLmRlbGV0ZShmaXJzdEtleSk7XG4gICAgfVxuXG4gICAgLy8gU2F2ZSB0byBwZXJzaXN0ZW50IGNhY2hlXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IEFzeW5jU3RvcmFnZS5zZXRJdGVtKENBQ0hFX1BSRUZJWCArIGtleSwgSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNhdmUgdG8gY2FjaGU6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgY2FjaGVkIHRyYW5zbGF0aW9uc1xuICAgKi9cbiAgYXN5bmMgY2xlYXJDYWNoZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBBc3luY1N0b3JhZ2UuZ2V0QWxsS2V5cygpO1xuICAgICAgY29uc3QgY2FjaGVLZXlzID0ga2V5cy5maWx0ZXIoKGspID0+IGsuc3RhcnRzV2l0aChDQUNIRV9QUkVGSVgpKTtcbiAgICAgIGF3YWl0IEFzeW5jU3RvcmFnZS5tdWx0aVJlbW92ZShjYWNoZUtleXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjbGVhciBjYWNoZTonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjYWNoZSBzdGF0aXN0aWNzXG4gICAqL1xuICBhc3luYyBnZXRDYWNoZVN0YXRzKCk6IFByb21pc2U8eyBtZW1vcnlTaXplOiBudW1iZXI7IHBlcnNpc3RlbnRTaXplOiBudW1iZXIgfT4ge1xuICAgIGxldCBwZXJzaXN0ZW50U2l6ZSA9IDA7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBBc3luY1N0b3JhZ2UuZ2V0QWxsS2V5cygpO1xuICAgICAgcGVyc2lzdGVudFNpemUgPSBrZXlzLmZpbHRlcigoaykgPT4gay5zdGFydHNXaXRoKENBQ0hFX1BSRUZJWCkpLmxlbmd0aDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWdub3JlXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1lbW9yeVNpemU6IHRoaXMuY2FjaGUuc2l6ZSxcbiAgICAgIHBlcnNpc3RlbnRTaXplLFxuICAgIH07XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFJhdGUgTGltaXRpbmdcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHByaXZhdGUgaXNSYXRlTGltaXRlZChwcm92aWRlcjogVHJhbnNsYXRpb25Qcm92aWRlcik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGNvdW50ZXIgPSB0aGlzLnJhdGVMaW1pdENvdW50ZXJzLmdldChwcm92aWRlcik7XG4gICAgaWYgKCFjb3VudGVyKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoRGF0ZS5ub3coKSA+IGNvdW50ZXIucmVzZXRUaW1lKSB7XG4gICAgICB0aGlzLnJhdGVMaW1pdENvdW50ZXJzLmRlbGV0ZShwcm92aWRlcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5wcm92aWRlcnMuZmluZCgocCkgPT4gcC5wcm92aWRlciA9PT0gcHJvdmlkZXIpO1xuICAgIHJldHVybiBjb3VudGVyLmNvdW50ID49IChjb25maWc/LnJhdGVMaW1pdCB8fCA2MCk7XG4gIH1cblxuICBwcml2YXRlIGluY3JlbWVudFJhdGVMaW1pdChwcm92aWRlcjogVHJhbnNsYXRpb25Qcm92aWRlcik6IHZvaWQge1xuICAgIGNvbnN0IGNvdW50ZXIgPSB0aGlzLnJhdGVMaW1pdENvdW50ZXJzLmdldChwcm92aWRlcik7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGlmICghY291bnRlciB8fCBub3cgPiBjb3VudGVyLnJlc2V0VGltZSkge1xuICAgICAgdGhpcy5yYXRlTGltaXRDb3VudGVycy5zZXQocHJvdmlkZXIsIHtcbiAgICAgICAgY291bnQ6IDEsXG4gICAgICAgIHJlc2V0VGltZTogbm93ICsgNjAwMDAsIC8vIFJlc2V0IGFmdGVyIDEgbWludXRlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnRlci5jb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gVXRpbGl0eSBNZXRob2RzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBwcml2YXRlIGRlbGF5KG1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBhIHByb3ZpZGVyXG4gICAqL1xuICBzZXRQcm92aWRlckVuYWJsZWQocHJvdmlkZXI6IFRyYW5zbGF0aW9uUHJvdmlkZXIsIGVuYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLnByb3ZpZGVycy5maW5kKChwKSA9PiBwLnByb3ZpZGVyID09PSBwcm92aWRlcik7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgY29uZmlnLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgQVBJIGtleSBmb3IgYSBwcm92aWRlclxuICAgKi9cbiAgc2V0QXBpS2V5KHByb3ZpZGVyOiBUcmFuc2xhdGlvblByb3ZpZGVyLCBhcGlLZXk6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMucHJvdmlkZXJzLmZpbmQoKHApID0+IHAucHJvdmlkZXIgPT09IHByb3ZpZGVyKTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBjb25maWcuYXBpS2V5ID0gYXBpS2V5O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbGFuZ3VhZ2UgZGlzcGxheSBuYW1lXG4gICAqL1xuICBzdGF0aWMgZ2V0TGFuZ3VhZ2VOYW1lKGNvZGU6IExhbmd1YWdlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gTEFOR1VBR0VfQ09ERVNbY29kZV0/Lm5hbWUgfHwgY29kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHN1cHBvcnRlZCBsYW5ndWFnZSBjb2Rlc1xuICAgKi9cbiAgc3RhdGljIGdldEFsbExhbmd1YWdlcygpOiBBcnJheTx7IGNvZGU6IExhbmd1YWdlOyBuYW1lOiBzdHJpbmcgfT4ge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhMQU5HVUFHRV9DT0RFUykubWFwKChbY29kZSwgZGF0YV0pID0+ICh7XG4gICAgICBjb2RlOiBjb2RlIGFzIExhbmd1YWdlLFxuICAgICAgbmFtZTogZGF0YS5uYW1lLFxuICAgIH0pKTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgdHJhbnNsYXRpb25BUEkgPSBuZXcgVHJhbnNsYXRpb25BUElTZXJ2aWNlKCk7XG4iLCIvKipcbiAqIER5bmFtaWMgV29yZCBEYXRhYmFzZSAtIExhbmd1YWdlLWFnbm9zdGljIHdvcmQgdHJhbnNsYXRpb24gZGF0YWJhc2VcbiAqXG4gKiBDb21iaW5lczpcbiAqIC0gVHJhbnNsYXRpb25BUElTZXJ2aWNlIGZvciByZWFsLXRpbWUgdHJhbnNsYXRpb25zXG4gKiAtIEZyZXF1ZW5jeUxpc3RTZXJ2aWNlIGZvciBwcm9maWNpZW5jeS1iYXNlZCB3b3JkIHNlbGVjdGlvblxuICogLSBTUUxpdGUgZm9yIGNhY2hpbmcgYW5kIG9mZmxpbmUgc3VwcG9ydFxuICpcbiAqIEZlYXR1cmVzOlxuICogLSBTdXBwb3J0cyBhbnkgbGFuZ3VhZ2UgcGFpclxuICogLSBCdWlsZHMgdm9jYWJ1bGFyeSBkeW5hbWljYWxseSB1c2luZyB0cmFuc2xhdGlvbiBBUElzXG4gKiAtIFVzZXMgZnJlcXVlbmN5IGxpc3RzIHRvIGRldGVybWluZSB3b3JkIGRpZmZpY3VsdHlcbiAqIC0gQ2FjaGVzIHRyYW5zbGF0aW9ucyBmb3Igb2ZmbGluZSB1c2VcbiAqL1xuXG5pbXBvcnQge0RhdGFiYXNlU2NoZW1hfSBmcm9tICcuLi9TdG9yYWdlU2VydmljZS9EYXRhYmFzZVNjaGVtYSc7XG5pbXBvcnQge2RhdGFiYXNlU2VydmljZX0gZnJvbSAnLi4vU3RvcmFnZVNlcnZpY2UvRGF0YWJhc2VTZXJ2aWNlJztcblxuaW1wb3J0IHtcbiAgRnJlcXVlbmN5TGlzdFNlcnZpY2UsXG4gIGZyZXF1ZW5jeUxpc3RTZXJ2aWNlLFxuICBQUk9GSUNJRU5DWV9USFJFU0hPTERTLFxufSBmcm9tICcuL0ZyZXF1ZW5jeUxpc3RTZXJ2aWNlJztcbmltcG9ydCB7VHJhbnNsYXRpb25BUElTZXJ2aWNlLCB0cmFuc2xhdGlvbkFQSX0gZnJvbSAnLi9UcmFuc2xhdGlvbkFQSVNlcnZpY2UnO1xuXG5pbXBvcnQgdHlwZSB7TGFuZ3VhZ2UsIFByb2ZpY2llbmN5TGV2ZWwsIFdvcmRFbnRyeSwgUGFydE9mU3BlZWNofSBmcm9tICcuLi90eXBlcyc7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFR5cGVzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHluYW1pY1dvcmRFbnRyeSBleHRlbmRzIFdvcmRFbnRyeSB7XG4gIGlzVHJhbnNsYXRlZDogYm9vbGVhbjtcbiAgdHJhbnNsYXRpb25Qcm92aWRlcj86IHN0cmluZztcbiAgY2FjaGVkQXQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV29yZExvb2t1cFJlc3VsdCB7XG4gIGVudHJ5OiBEeW5hbWljV29yZEVudHJ5IHwgbnVsbDtcbiAgc291cmNlOiAnY2FjaGUnIHwgJ2RhdGFiYXNlJyB8ICdhcGknIHwgJ25vbmUnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFiYXNlU3RhdHMge1xuICB0b3RhbENhY2hlZFdvcmRzOiBudW1iZXI7XG4gIGxhbmd1YWdlUGFpcnM6IEFycmF5PHtzb3VyY2U6IExhbmd1YWdlOyB0YXJnZXQ6IExhbmd1YWdlOyBjb3VudDogbnVtYmVyfT47XG4gIGxhc3RVcGRhdGVkOiBzdHJpbmcgfCBudWxsO1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEeW5hbWljIFdvcmQgRGF0YWJhc2Vcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGNsYXNzIER5bmFtaWNXb3JkRGF0YWJhc2Uge1xuICBwcml2YXRlIGRiOiB0eXBlb2YgZGF0YWJhc2VTZXJ2aWNlO1xuICBwcml2YXRlIHRyYW5zbGF0aW9uQVBJOiBUcmFuc2xhdGlvbkFQSVNlcnZpY2U7XG4gIHByaXZhdGUgZnJlcXVlbmN5U2VydmljZTogRnJlcXVlbmN5TGlzdFNlcnZpY2U7XG4gIHByaXZhdGUgbWVtb3J5Q2FjaGU6IE1hcDxzdHJpbmcsIER5bmFtaWNXb3JkRW50cnk+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIGluaXRpYWxpemVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kYiA9IGRhdGFiYXNlU2VydmljZTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uQVBJID0gdHJhbnNsYXRpb25BUEk7XG4gICAgdGhpcy5mcmVxdWVuY3lTZXJ2aWNlID0gZnJlcXVlbmN5TGlzdFNlcnZpY2U7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgZGF0YWJhc2VcbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICBhd2FpdCB0aGlzLmRiLmluaXRpYWxpemUoKTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rIHVwIGEgd29yZCB0cmFuc2xhdGlvblxuICAgKiBDaGVja3M6IG1lbW9yeSBjYWNoZSDihpIgZGF0YWJhc2Ug4oaSIHRyYW5zbGF0aW9uIEFQSVxuICAgKi9cbiAgYXN5bmMgbG9va3VwV29yZChcbiAgICB3b3JkOiBzdHJpbmcsXG4gICAgc291cmNlTGFuZ3VhZ2U6IExhbmd1YWdlLFxuICAgIHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZVxuICApOiBQcm9taXNlPFdvcmRMb29rdXBSZXN1bHQ+IHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICBjb25zdCBub3JtYWxpemVkV29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmdldENhY2hlS2V5KG5vcm1hbGl6ZWRXb3JkLCBzb3VyY2VMYW5ndWFnZSwgdGFyZ2V0TGFuZ3VhZ2UpO1xuXG4gICAgLy8gMS4gQ2hlY2sgbWVtb3J5IGNhY2hlXG4gICAgaWYgKHRoaXMubWVtb3J5Q2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgcmV0dXJuIHtlbnRyeTogdGhpcy5tZW1vcnlDYWNoZS5nZXQoY2FjaGVLZXkpISwgc291cmNlOiAnY2FjaGUnfTtcbiAgICB9XG5cbiAgICAvLyAyLiBDaGVjayBkYXRhYmFzZVxuICAgIGNvbnN0IGRiRW50cnkgPSBhd2FpdCB0aGlzLmxvb2t1cEZyb21EYXRhYmFzZShub3JtYWxpemVkV29yZCwgc291cmNlTGFuZ3VhZ2UsIHRhcmdldExhbmd1YWdlKTtcbiAgICBpZiAoZGJFbnRyeSkge1xuICAgICAgdGhpcy5tZW1vcnlDYWNoZS5zZXQoY2FjaGVLZXksIGRiRW50cnkpO1xuICAgICAgcmV0dXJuIHtlbnRyeTogZGJFbnRyeSwgc291cmNlOiAnZGF0YWJhc2UnfTtcbiAgICB9XG5cbiAgICAvLyAzLiBUcmFuc2xhdGUgdmlhIEFQSSBhbmQgY2FjaGVcbiAgICB0cnkge1xuICAgICAgY29uc3QgdHJhbnNsYXRlZCA9IGF3YWl0IHRoaXMudHJhbnNsYXRlQW5kQ2FjaGUoXG4gICAgICAgIG5vcm1hbGl6ZWRXb3JkLFxuICAgICAgICBzb3VyY2VMYW5ndWFnZSxcbiAgICAgICAgdGFyZ2V0TGFuZ3VhZ2VcbiAgICAgICk7XG4gICAgICBpZiAodHJhbnNsYXRlZCkge1xuICAgICAgICB0aGlzLm1lbW9yeUNhY2hlLnNldChjYWNoZUtleSwgdHJhbnNsYXRlZCk7XG4gICAgICAgIHJldHVybiB7ZW50cnk6IHRyYW5zbGF0ZWQsIHNvdXJjZTogJ2FwaSd9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFRyYW5zbGF0aW9uIGZhaWxlZCBmb3IgXCIke3dvcmR9XCI6YCwgZXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiB7ZW50cnk6IG51bGwsIHNvdXJjZTogJ25vbmUnfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rIHVwIG11bHRpcGxlIHdvcmRzIGVmZmljaWVudGx5XG4gICAqL1xuICBhc3luYyBsb29rdXBXb3JkcyhcbiAgICB3b3Jkczogc3RyaW5nW10sXG4gICAgc291cmNlTGFuZ3VhZ2U6IExhbmd1YWdlLFxuICAgIHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZVxuICApOiBQcm9taXNlPE1hcDxzdHJpbmcsIFdvcmRMb29rdXBSZXN1bHQ+PiB7XG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBNYXA8c3RyaW5nLCBXb3JkTG9va3VwUmVzdWx0PigpO1xuICAgIGNvbnN0IHRvVHJhbnNsYXRlOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gRmlyc3QgcGFzczogY2hlY2sgY2FjaGUgYW5kIGRhdGFiYXNlXG4gICAgZm9yIChjb25zdCB3b3JkIG9mIHdvcmRzKSB7XG4gICAgICBjb25zdCBub3JtYWxpemVkV29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2V0Q2FjaGVLZXkobm9ybWFsaXplZFdvcmQsIHNvdXJjZUxhbmd1YWdlLCB0YXJnZXRMYW5ndWFnZSk7XG5cbiAgICAgIGlmICh0aGlzLm1lbW9yeUNhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgICAgcmVzdWx0cy5zZXQod29yZCwge2VudHJ5OiB0aGlzLm1lbW9yeUNhY2hlLmdldChjYWNoZUtleSkhLCBzb3VyY2U6ICdjYWNoZSd9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRiRW50cnkgPSBhd2FpdCB0aGlzLmxvb2t1cEZyb21EYXRhYmFzZShcbiAgICAgICAgICBub3JtYWxpemVkV29yZCxcbiAgICAgICAgICBzb3VyY2VMYW5ndWFnZSxcbiAgICAgICAgICB0YXJnZXRMYW5ndWFnZVxuICAgICAgICApO1xuICAgICAgICBpZiAoZGJFbnRyeSkge1xuICAgICAgICAgIHRoaXMubWVtb3J5Q2FjaGUuc2V0KGNhY2hlS2V5LCBkYkVudHJ5KTtcbiAgICAgICAgICByZXN1bHRzLnNldCh3b3JkLCB7ZW50cnk6IGRiRW50cnksIHNvdXJjZTogJ2RhdGFiYXNlJ30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvVHJhbnNsYXRlLnB1c2god29yZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCYXRjaCB0cmFuc2xhdGUgcmVtYWluaW5nIHdvcmRzXG4gICAgaWYgKHRvVHJhbnNsYXRlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJ1bGtSZXN1bHQgPSBhd2FpdCB0aGlzLnRyYW5zbGF0aW9uQVBJLnRyYW5zbGF0ZUJ1bGsoXG4gICAgICAgIHRvVHJhbnNsYXRlLFxuICAgICAgICBzb3VyY2VMYW5ndWFnZSxcbiAgICAgICAgdGFyZ2V0TGFuZ3VhZ2VcbiAgICAgICk7XG5cbiAgICAgIGZvciAoY29uc3QgW3dvcmQsIHRyYW5zbGF0aW9uXSBvZiBidWxrUmVzdWx0LnRyYW5zbGF0aW9ucykge1xuICAgICAgICBjb25zdCBlbnRyeSA9IGF3YWl0IHRoaXMuY3JlYXRlQW5kQ2FjaGVFbnRyeShcbiAgICAgICAgICB3b3JkLFxuICAgICAgICAgIHRyYW5zbGF0aW9uLFxuICAgICAgICAgIHNvdXJjZUxhbmd1YWdlLFxuICAgICAgICAgIHRhcmdldExhbmd1YWdlLFxuICAgICAgICAgIGJ1bGtSZXN1bHQucHJvdmlkZXJcbiAgICAgICAgKTtcbiAgICAgICAgcmVzdWx0cy5zZXQod29yZCwge2VudHJ5LCBzb3VyY2U6ICdhcGknfSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3Qgd29yZCBvZiBidWxrUmVzdWx0LmZhaWxlZCkge1xuICAgICAgICByZXN1bHRzLnNldCh3b3JkLCB7ZW50cnk6IG51bGwsIHNvdXJjZTogJ25vbmUnfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdvcmRzIGJ5IHByb2ZpY2llbmN5IGxldmVsIGZvciBhIGxhbmd1YWdlXG4gICAqIFVzZXMgZnJlcXVlbmN5IGxpc3QgdG8gc2VsZWN0IGFwcHJvcHJpYXRlIHdvcmRzXG4gICAqL1xuICBhc3luYyBnZXRXb3Jkc0J5UHJvZmljaWVuY3koXG4gICAgc291cmNlTGFuZ3VhZ2U6IExhbmd1YWdlLFxuICAgIHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZSxcbiAgICBsZXZlbDogUHJvZmljaWVuY3lMZXZlbCxcbiAgICBsaW1pdDogbnVtYmVyID0gNTBcbiAgKTogUHJvbWlzZTxEeW5hbWljV29yZEVudHJ5W10+IHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcblxuICAgIC8vIEdldCBmcmVxdWVuY3ktcmFua2VkIHdvcmRzIGZvciB0aGUgc291cmNlIGxhbmd1YWdlXG4gICAgY29uc3QgZnJlcXVlbmN5V29yZHMgPSBhd2FpdCB0aGlzLmZyZXF1ZW5jeVNlcnZpY2UuZ2V0V29yZHNCeVByb2ZpY2llbmN5KHNvdXJjZUxhbmd1YWdlLCBsZXZlbCk7XG5cbiAgICBpZiAoZnJlcXVlbmN5V29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBGcmVxdWVuY3kgbGlzdCBub3QgYXZhaWxhYmxlLCByZXR1cm4gY2FjaGVkIHdvcmRzXG4gICAgICByZXR1cm4gdGhpcy5nZXRDYWNoZWRXb3Jkc0J5TGV2ZWwoc291cmNlTGFuZ3VhZ2UsIHRhcmdldExhbmd1YWdlLCBsZXZlbCwgbGltaXQpO1xuICAgIH1cblxuICAgIC8vIFNlbGVjdCByYW5kb20gc3Vic2V0XG4gICAgY29uc3Qgc2h1ZmZsZWQgPSBbLi4uZnJlcXVlbmN5V29yZHNdLnNvcnQoKCkgPT4gTWF0aC5yYW5kb20oKSAtIDAuNSk7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBzaHVmZmxlZC5zbGljZSgwLCBsaW1pdCk7XG5cbiAgICAvLyBMb29rIHVwIHRyYW5zbGF0aW9ucyBmb3Igc2VsZWN0ZWQgd29yZHNcbiAgICBjb25zdCBlbnRyaWVzOiBEeW5hbWljV29yZEVudHJ5W10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZyZXFXb3JkIG9mIHNlbGVjdGVkKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmxvb2t1cFdvcmQoZnJlcVdvcmQud29yZCwgc291cmNlTGFuZ3VhZ2UsIHRhcmdldExhbmd1YWdlKTtcbiAgICAgIGlmIChyZXN1bHQuZW50cnkpIHtcbiAgICAgICAgZW50cmllcy5wdXNoKHJlc3VsdC5lbnRyeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHJhbmRvbSB3b3JkcyBmb3Igdm9jYWJ1bGFyeSBwcmFjdGljZVxuICAgKi9cbiAgYXN5bmMgZ2V0UmFuZG9tV29yZHMoXG4gICAgc291cmNlTGFuZ3VhZ2U6IExhbmd1YWdlLFxuICAgIHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZSxcbiAgICBsZXZlbDogUHJvZmljaWVuY3lMZXZlbCxcbiAgICBjb3VudDogbnVtYmVyXG4gICk6IFByb21pc2U8RHluYW1pY1dvcmRFbnRyeVtdPiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V29yZHNCeVByb2ZpY2llbmN5KHNvdXJjZUxhbmd1YWdlLCB0YXJnZXRMYW5ndWFnZSwgbGV2ZWwsIGNvdW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGxhbmd1YWdlIHBhaXIgaXMgc3VwcG9ydGVkXG4gICAqL1xuICBhc3luYyBpc0xhbmd1YWdlUGFpclN1cHBvcnRlZChcbiAgICBzb3VyY2VMYW5ndWFnZTogTGFuZ3VhZ2UsXG4gICAgdGFyZ2V0TGFuZ3VhZ2U6IExhbmd1YWdlXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0aW9uQVBJLmlzTGFuZ3VhZ2VQYWlyU3VwcG9ydGVkKHNvdXJjZUxhbmd1YWdlLCB0YXJnZXRMYW5ndWFnZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRhdGFiYXNlIHN0YXRpc3RpY3NcbiAgICovXG4gIGFzeW5jIGdldFN0YXRzKCk6IFByb21pc2U8RGF0YWJhc2VTdGF0cz4ge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZSgpO1xuXG4gICAgY29uc3QgdG90YWxSZXN1bHQgPSBhd2FpdCB0aGlzLmRiLmdldE9uZTx7Y291bnQ6IG51bWJlcn0+KFxuICAgICAgJ1NFTEVDVCBDT1VOVCgqKSBhcyBjb3VudCBGUk9NIHdvcmRfbGlzdCdcbiAgICApO1xuXG4gICAgY29uc3QgcGFpcnNSZXN1bHQgPSBhd2FpdCB0aGlzLmRiLmdldEFsbDx7XG4gICAgICBzb3VyY2VfbGFuZzogc3RyaW5nO1xuICAgICAgdGFyZ2V0X2xhbmc6IHN0cmluZztcbiAgICAgIGNvdW50OiBudW1iZXI7XG4gICAgfT4oXG4gICAgICBgU0VMRUNUIHNvdXJjZV9sYW5nLCB0YXJnZXRfbGFuZywgQ09VTlQoKikgYXMgY291bnQgXG4gICAgICAgRlJPTSB3b3JkX2xpc3QgXG4gICAgICAgR1JPVVAgQlkgc291cmNlX2xhbmcsIHRhcmdldF9sYW5nYFxuICAgICk7XG5cbiAgICBjb25zdCBsYW5ndWFnZVBhaXJzID0gcGFpcnNSZXN1bHQubWFwKHJvdyA9PiAoe1xuICAgICAgc291cmNlOiByb3cuc291cmNlX2xhbmcgYXMgTGFuZ3VhZ2UsXG4gICAgICB0YXJnZXQ6IHJvdy50YXJnZXRfbGFuZyBhcyBMYW5ndWFnZSxcbiAgICAgIGNvdW50OiByb3cuY291bnQsXG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsQ2FjaGVkV29yZHM6IHRvdGFsUmVzdWx0Py5jb3VudCB8fCAwLFxuICAgICAgbGFuZ3VhZ2VQYWlycyxcbiAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBjYWNoZWQgdHJhbnNsYXRpb25zIGZvciBhIGxhbmd1YWdlIHBhaXJcbiAgICovXG4gIGFzeW5jIGNsZWFyQ2FjaGUoc291cmNlTGFuZ3VhZ2U/OiBMYW5ndWFnZSwgdGFyZ2V0TGFuZ3VhZ2U/OiBMYW5ndWFnZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChzb3VyY2VMYW5ndWFnZSAmJiB0YXJnZXRMYW5ndWFnZSkge1xuICAgICAgYXdhaXQgdGhpcy5kYi5leGVjdXRlKCdERUxFVEUgRlJPTSB3b3JkX2xpc3QgV0hFUkUgc291cmNlX2xhbmcgPSA/IEFORCB0YXJnZXRfbGFuZyA9ID8nLCBbXG4gICAgICAgIHNvdXJjZUxhbmd1YWdlLFxuICAgICAgICB0YXJnZXRMYW5ndWFnZSxcbiAgICAgIF0pO1xuXG4gICAgICAvLyBDbGVhciBtZW1vcnkgY2FjaGUgZm9yIHRoaXMgcGFpclxuICAgICAgY29uc3QgcHJlZml4ID0gYCR7c291cmNlTGFuZ3VhZ2V9XyR7dGFyZ2V0TGFuZ3VhZ2V9X2A7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLm1lbW9yeUNhY2hlLmtleXMoKSkge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgocHJlZml4KSkge1xuICAgICAgICAgIHRoaXMubWVtb3J5Q2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgdGhpcy5kYi5leGVjdXRlKCdERUxFVEUgRlJPTSB3b3JkX2xpc3QnKTtcbiAgICAgIHRoaXMubWVtb3J5Q2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJlLWNhY2hlIGNvbW1vbiB3b3JkcyBmb3IgYSBsYW5ndWFnZSBwYWlyXG4gICAqL1xuICBhc3luYyBwcmVDYWNoZUNvbW1vbldvcmRzKFxuICAgIHNvdXJjZUxhbmd1YWdlOiBMYW5ndWFnZSxcbiAgICB0YXJnZXRMYW5ndWFnZTogTGFuZ3VhZ2UsXG4gICAgY291bnQ6IG51bWJlciA9IDUwMFxuICApOiBQcm9taXNlPHtjYWNoZWQ6IG51bWJlcjsgZmFpbGVkOiBudW1iZXJ9PiB7XG4gICAgLy8gR2V0IG1vc3QgZnJlcXVlbnQgd29yZHNcbiAgICBjb25zdCBmcmVxdWVuY3lXb3JkcyA9IGF3YWl0IHRoaXMuZnJlcXVlbmN5U2VydmljZS5nZXRXb3Jkc0J5UHJvZmljaWVuY3koXG4gICAgICBzb3VyY2VMYW5ndWFnZSxcbiAgICAgICdiZWdpbm5lcidcbiAgICApO1xuICAgIGNvbnN0IHdvcmRzID0gZnJlcXVlbmN5V29yZHMuc2xpY2UoMCwgY291bnQpLm1hcCh3ID0+IHcud29yZCk7XG5cbiAgICBpZiAod29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge2NhY2hlZDogMCwgZmFpbGVkOiAwfTtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2xhdGUgYW5kIGNhY2hlXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMubG9va3VwV29yZHMod29yZHMsIHNvdXJjZUxhbmd1YWdlLCB0YXJnZXRMYW5ndWFnZSk7XG5cbiAgICBsZXQgY2FjaGVkID0gMDtcbiAgICBsZXQgZmFpbGVkID0gMDtcbiAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocmVzdWx0LmVudHJ5KSB7XG4gICAgICAgIGNhY2hlZCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFpbGVkKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtjYWNoZWQsIGZhaWxlZH07XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFByaXZhdGUgTWV0aG9kc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgcHJpdmF0ZSBnZXRDYWNoZUtleSh3b3JkOiBzdHJpbmcsIHNvdXJjZTogTGFuZ3VhZ2UsIHRhcmdldDogTGFuZ3VhZ2UpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHtzb3VyY2V9XyR7dGFyZ2V0fV8ke3dvcmR9YDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9va3VwRnJvbURhdGFiYXNlKFxuICAgIHdvcmQ6IHN0cmluZyxcbiAgICBzb3VyY2VMYW5ndWFnZTogTGFuZ3VhZ2UsXG4gICAgdGFyZ2V0TGFuZ3VhZ2U6IExhbmd1YWdlXG4gICk6IFByb21pc2U8RHluYW1pY1dvcmRFbnRyeSB8IG51bGw+IHtcbiAgICBjb25zdCByb3cgPSBhd2FpdCB0aGlzLmRiLmdldE9uZTxhbnk+KERhdGFiYXNlU2NoZW1hLndvcmRMaXN0LmdldEJ5V29yZCwgW1xuICAgICAgd29yZCxcbiAgICAgIHNvdXJjZUxhbmd1YWdlLFxuICAgICAgdGFyZ2V0TGFuZ3VhZ2UsXG4gICAgXSk7XG5cbiAgICBpZiAoIXJvdykgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gdGhpcy5yb3dUb0VudHJ5KHJvdyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHRyYW5zbGF0ZUFuZENhY2hlKFxuICAgIHdvcmQ6IHN0cmluZyxcbiAgICBzb3VyY2VMYW5ndWFnZTogTGFuZ3VhZ2UsXG4gICAgdGFyZ2V0TGFuZ3VhZ2U6IExhbmd1YWdlXG4gICk6IFByb21pc2U8RHluYW1pY1dvcmRFbnRyeSB8IG51bGw+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnRyYW5zbGF0aW9uQVBJLnRyYW5zbGF0ZSh3b3JkLCBzb3VyY2VMYW5ndWFnZSwgdGFyZ2V0TGFuZ3VhZ2UpO1xuXG4gICAgaWYgKHJlc3VsdC50cmFuc2xhdGVkVGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kQ2FjaGVFbnRyeShcbiAgICAgICAgd29yZCxcbiAgICAgICAgcmVzdWx0LnRyYW5zbGF0ZWRUZXh0LFxuICAgICAgICBzb3VyY2VMYW5ndWFnZSxcbiAgICAgICAgdGFyZ2V0TGFuZ3VhZ2UsXG4gICAgICAgIHJlc3VsdC5wcm92aWRlclxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlQW5kQ2FjaGVFbnRyeShcbiAgICBzb3VyY2VXb3JkOiBzdHJpbmcsXG4gICAgdGFyZ2V0V29yZDogc3RyaW5nLFxuICAgIHNvdXJjZUxhbmd1YWdlOiBMYW5ndWFnZSxcbiAgICB0YXJnZXRMYW5ndWFnZTogTGFuZ3VhZ2UsXG4gICAgcHJvdmlkZXI6IHN0cmluZ1xuICApOiBQcm9taXNlPER5bmFtaWNXb3JkRW50cnk+IHtcbiAgICAvLyBHZXQgZnJlcXVlbmN5IHJhbmsgaWYgYXZhaWxhYmxlXG4gICAgY29uc3QgcmFuayA9IGF3YWl0IHRoaXMuZnJlcXVlbmN5U2VydmljZS5nZXRXb3JkUmFuayhzb3VyY2VMYW5ndWFnZSwgc291cmNlV29yZCk7XG4gICAgY29uc3QgcHJvZmljaWVuY3lMZXZlbCA9IHJhbmtcbiAgICAgID8gdGhpcy5mcmVxdWVuY3lTZXJ2aWNlLmdldFByb2ZpY2llbmN5TGV2ZWwocmFuaylcbiAgICAgIDogJ2ludGVybWVkaWF0ZSc7IC8vIERlZmF1bHQgdG8gaW50ZXJtZWRpYXRlIGlmIG5vIGZyZXF1ZW5jeSBkYXRhXG5cbiAgICBjb25zdCBlbnRyeTogRHluYW1pY1dvcmRFbnRyeSA9IHtcbiAgICAgIGlkOiBgJHtzb3VyY2VMYW5ndWFnZX1fJHt0YXJnZXRMYW5ndWFnZX1fJHtzb3VyY2VXb3JkfWAsXG4gICAgICBzb3VyY2VXb3JkLFxuICAgICAgdGFyZ2V0V29yZCxcbiAgICAgIHNvdXJjZUxhbmd1YWdlLFxuICAgICAgdGFyZ2V0TGFuZ3VhZ2UsXG4gICAgICBwcm9maWNpZW5jeUxldmVsLFxuICAgICAgZnJlcXVlbmN5UmFuazogcmFuayB8fCAxMDAwLCAvLyBEZWZhdWx0IHJhbmtcbiAgICAgIHBhcnRPZlNwZWVjaDogJ290aGVyJyBhcyBQYXJ0T2ZTcGVlY2gsXG4gICAgICB2YXJpYW50czogW10sXG4gICAgICBpc1RyYW5zbGF0ZWQ6IHRydWUsXG4gICAgICB0cmFuc2xhdGlvblByb3ZpZGVyOiBwcm92aWRlcixcbiAgICAgIGNhY2hlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfTtcblxuICAgIC8vIFNhdmUgdG8gZGF0YWJhc2VcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5kYi5leGVjdXRlKERhdGFiYXNlU2NoZW1hLndvcmRMaXN0Lmluc2VydCwgW1xuICAgICAgICBlbnRyeS5pZCxcbiAgICAgICAgZW50cnkuc291cmNlV29yZCxcbiAgICAgICAgZW50cnkudGFyZ2V0V29yZCxcbiAgICAgICAgZW50cnkuc291cmNlTGFuZ3VhZ2UsXG4gICAgICAgIGVudHJ5LnRhcmdldExhbmd1YWdlLFxuICAgICAgICBlbnRyeS5wcm9maWNpZW5jeUxldmVsLFxuICAgICAgICBlbnRyeS5mcmVxdWVuY3lSYW5rLFxuICAgICAgICBlbnRyeS5wYXJ0T2ZTcGVlY2gsXG4gICAgICAgIG51bGwsIC8vIHZhcmlhbnRzXG4gICAgICAgIG51bGwsIC8vIHByb251bmNpYXRpb25cbiAgICAgIF0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBFbnRyeSBtaWdodCBhbHJlYWR5IGV4aXN0LCBpZ25vcmUgZHVwbGljYXRlIGVycm9yXG4gICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ1VOSVFVRScpKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjYWNoZSB0cmFuc2xhdGlvbjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJ5O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRDYWNoZWRXb3Jkc0J5TGV2ZWwoXG4gICAgc291cmNlTGFuZ3VhZ2U6IExhbmd1YWdlLFxuICAgIHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZSxcbiAgICBsZXZlbDogUHJvZmljaWVuY3lMZXZlbCxcbiAgICBsaW1pdDogbnVtYmVyXG4gICk6IFByb21pc2U8RHluYW1pY1dvcmRFbnRyeVtdPiB7XG4gICAgY29uc3Qgcm93cyA9IGF3YWl0IHRoaXMuZGIuZ2V0QWxsPGFueT4oXG4gICAgICBgU0VMRUNUICogRlJPTSB3b3JkX2xpc3QgXG4gICAgICAgV0hFUkUgc291cmNlX2xhbmcgPSA/IEFORCB0YXJnZXRfbGFuZyA9ID8gQU5EIHByb2ZpY2llbmN5ID0gP1xuICAgICAgIE9SREVSIEJZIFJBTkRPTSgpIExJTUlUID9gLFxuICAgICAgW3NvdXJjZUxhbmd1YWdlLCB0YXJnZXRMYW5ndWFnZSwgbGV2ZWwsIGxpbWl0XVxuICAgICk7XG5cbiAgICByZXR1cm4gcm93cy5tYXAocm93ID0+IHRoaXMucm93VG9FbnRyeShyb3cpKTtcbiAgfVxuXG4gIHByaXZhdGUgcm93VG9FbnRyeShyb3c6IGFueSk6IER5bmFtaWNXb3JkRW50cnkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogcm93LmlkLFxuICAgICAgc291cmNlV29yZDogcm93LnNvdXJjZV93b3JkLFxuICAgICAgdGFyZ2V0V29yZDogcm93LnRhcmdldF93b3JkLFxuICAgICAgc291cmNlTGFuZ3VhZ2U6IHJvdy5zb3VyY2VfbGFuZyBhcyBMYW5ndWFnZSxcbiAgICAgIHRhcmdldExhbmd1YWdlOiByb3cudGFyZ2V0X2xhbmcgYXMgTGFuZ3VhZ2UsXG4gICAgICBwcm9maWNpZW5jeUxldmVsOiByb3cucHJvZmljaWVuY3kgYXMgUHJvZmljaWVuY3lMZXZlbCxcbiAgICAgIGZyZXF1ZW5jeVJhbms6IHJvdy5mcmVxdWVuY3lfcmFuayB8fCAwLFxuICAgICAgcGFydE9mU3BlZWNoOiAocm93LnBhcnRfb2Zfc3BlZWNoIGFzIFBhcnRPZlNwZWVjaCkgfHwgJ290aGVyJyxcbiAgICAgIHZhcmlhbnRzOiByb3cudmFyaWFudHMgPyBKU09OLnBhcnNlKHJvdy52YXJpYW50cykgOiBbXSxcbiAgICAgIHByb251bmNpYXRpb246IHJvdy5wcm9udW5jaWF0aW9uLFxuICAgICAgaXNUcmFuc2xhdGVkOiB0cnVlLFxuICAgIH07XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGR5bmFtaWNXb3JkRGF0YWJhc2UgPSBuZXcgRHluYW1pY1dvcmREYXRhYmFzZSgpO1xuIiwiLyoqXG4gKiBUZXh0IFByb2Nlc3NpbmcgU2VydmljZVxuICpcbiAqIEludGVncmF0ZXMgdG9rZW5pemF0aW9uLCB3b3JkIG1hdGNoaW5nLCBhbmQgcmVwbGFjZW1lbnQgZm9yIEVQVUIgY29udGVudC5cbiAqIFRoaXMgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIHByb2Nlc3NpbmcgY2hhcHRlciB0ZXh0IGZvciBmb3JlaWduIHdvcmQgZGlzcGxheS5cbiAqXG4gKiBGZWF0dXJlczpcbiAqIC0gRXh0cmFjdHMgY2xlYW4gY29udGVudCBmcm9tIEVQVUIgSFRNTFxuICogLSBUb2tlbml6ZXMgdGV4dCB3aGlsZSBwcmVzZXJ2aW5nIEhUTUwgc3RydWN0dXJlXG4gKiAtIEhhbmRsZXMgZW1iZWRkZWQgQ1NTIHN0eWxlc1xuICogLSBQcm9jZXNzZXMgaW1hZ2VzIHRvIGJhc2U2NFxuICogLSBBcHBsaWVzIHdvcmQgcmVwbGFjZW1lbnRzXG4gKiAtIE1haW50YWlucyB3b3JkIHBvc2l0aW9ucyBmb3IgdGFwIGRldGVjdGlvblxuICovXG5cbmltcG9ydCB0eXBlIHtcbiAgQ2hhcHRlcixcbiAgV29yZEVudHJ5LFxuICBQcm9maWNpZW5jeUxldmVsLFxuICBGb3JlaWduV29yZERhdGEsXG4gIExhbmd1YWdlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1Rva2VuaXplciwgdHlwZSBUb2tlbiwgdHlwZSBUb2tlbml6ZXJPcHRpb25zfSBmcm9tICcuLi9UcmFuc2xhdGlvbkVuZ2luZS9Ub2tlbml6ZXInO1xuaW1wb3J0IHtXb3JkUmVwbGFjZXIsIHR5cGUgUmVwbGFjZXJPcHRpb25zLCB0eXBlIFJlcGxhY2VtZW50U3RhdHN9IGZyb20gJy4uL1RyYW5zbGF0aW9uRW5naW5lL1dvcmRSZXBsYWNlcic7XG5pbXBvcnQge2R5bmFtaWNXb3JkRGF0YWJhc2V9IGZyb20gJy4uL1RyYW5zbGF0aW9uRW5naW5lL0R5bmFtaWNXb3JkRGF0YWJhc2UnO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBUeXBlc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2Nlc3NpbmdPcHRpb25zIHtcbiAgLyoqIFNvdXJjZSBsYW5ndWFnZSBjb2RlICovXG4gIHNvdXJjZUxhbmd1YWdlOiBMYW5ndWFnZTtcbiAgLyoqIFRhcmdldCBsYW5ndWFnZSBjb2RlICovXG4gIHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZTtcbiAgLyoqIE1heGltdW0gcHJvZmljaWVuY3kgbGV2ZWwgKi9cbiAgcHJvZmljaWVuY3lMZXZlbDogUHJvZmljaWVuY3lMZXZlbDtcbiAgLyoqIFdvcmQgZGVuc2l0eSAoMC4wIC0gMS4wKSAqL1xuICBkZW5zaXR5OiBudW1iZXI7XG4gIC8qKiBNaW5pbXVtIHNwYWNpbmcgYmV0d2VlbiByZXBsYWNlZCB3b3JkcyAqL1xuICBtaW5Xb3JkU3BhY2luZz86IG51bWJlcjtcbiAgLyoqIFNlbGVjdGlvbiBzdHJhdGVneSAqL1xuICBzZWxlY3Rpb25TdHJhdGVneT86ICdyYW5kb20nIHwgJ2ZyZXF1ZW5jeScgfCAnZGlzdHJpYnV0ZWQnO1xuICAvKiogV29yZHMgdG8gZXhjbHVkZSBmcm9tIHJlcGxhY2VtZW50ICovXG4gIGV4Y2x1ZGVXb3Jkcz86IHN0cmluZ1tdO1xuICAvKiogU2tpcCB3b3JkcyBpbiBxdW90ZXMgKi9cbiAgc2tpcFF1b3Rlcz86IGJvb2xlYW47XG4gIC8qKiBTa2lwIHByb3BlciBuYW1lcyAqL1xuICBza2lwTmFtZXM/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2Nlc3NlZENvbnRlbnQge1xuICAvKiogVGhlIHByb2Nlc3NlZCBIVE1MIHdpdGggZm9yZWlnbiB3b3JkIG1hcmtlcnMgKi9cbiAgaHRtbDogc3RyaW5nO1xuICAvKiogQXJyYXkgb2YgZm9yZWlnbiB3b3JkcyBpbiB0aGUgY29udGVudCAqL1xuICBmb3JlaWduV29yZHM6IEZvcmVpZ25Xb3JkRGF0YVtdO1xuICAvKiogUHJvY2Vzc2luZyBzdGF0aXN0aWNzICovXG4gIHN0YXRzOiBQcm9jZXNzaW5nU3RhdHM7XG4gIC8qKiBVbmlxdWUgd29yZHMgZm91bmQgaW4gdGhlIGNvbnRlbnQgKi9cbiAgdW5pcXVlV29yZHM6IHN0cmluZ1tdO1xuICAvKiogVG9rZW5zIGV4dHJhY3RlZCBmcm9tIHRoZSBjb250ZW50ICovXG4gIHRva2VuczogVG9rZW5bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9jZXNzaW5nU3RhdHMgZXh0ZW5kcyBSZXBsYWNlbWVudFN0YXRzIHtcbiAgLyoqIFRpbWUgdGFrZW4gdG8gcHJvY2VzcyBpbiBtaWxsaXNlY29uZHMgKi9cbiAgcHJvY2Vzc2luZ1RpbWVNczogbnVtYmVyO1xuICAvKiogTnVtYmVyIG9mIHVuaXF1ZSB3b3JkcyAqL1xuICB1bmlxdWVXb3JkQ291bnQ6IG51bWJlcjtcbiAgLyoqIE51bWJlciBvZiB3b3JkcyBsb29rZWQgdXAgaW4gZGF0YWJhc2UgKi9cbiAgZGF0YWJhc2VMb29rdXBzOiBudW1iZXI7XG4gIC8qKiBOdW1iZXIgb2Ygd29yZHMgZm91bmQgaW4gZGF0YWJhc2UgKi9cbiAgZGF0YWJhc2VIaXRzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXh0cmFjdGVkQ29udGVudCB7XG4gIC8qKiBUaGUgYm9keSBIVE1MIGNvbnRlbnQgKi9cbiAgYm9keTogc3RyaW5nO1xuICAvKiogRXh0cmFjdGVkIENTUyBzdHlsZXMgKi9cbiAgc3R5bGVzOiBzdHJpbmdbXTtcbiAgLyoqIFRpdGxlIGZyb20gdGhlIEhUTUwgKi9cbiAgdGl0bGU/OiBzdHJpbmc7XG4gIC8qKiBMYW5ndWFnZSBhdHRyaWJ1dGUgaWYgcHJlc2VudCAqL1xuICBsYW5ndWFnZT86IHN0cmluZztcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVGV4dCBQcm9jZXNzaW5nIFNlcnZpY2UgQ2xhc3Ncbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGNsYXNzIFRleHRQcm9jZXNzaW5nU2VydmljZSB7XG4gIHByaXZhdGUgdG9rZW5pemVyOiBUb2tlbml6ZXI7XG4gIHByaXZhdGUgd29yZFJlcGxhY2VyOiBXb3JkUmVwbGFjZXI7XG4gIHByaXZhdGUgd29yZENhY2hlOiBNYXA8c3RyaW5nLCBXb3JkRW50cnkgfCBudWxsPiA9IG5ldyBNYXAoKTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoKTtcbiAgICB0aGlzLndvcmRSZXBsYWNlciA9IG5ldyBXb3JkUmVwbGFjZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGNoYXB0ZXIgY29udGVudCBhbmQgcmVwbGFjZSB3b3JkcyB3aXRoIGZvcmVpZ24gZXF1aXZhbGVudHNcbiAgICovXG4gIGFzeW5jIHByb2Nlc3NDaGFwdGVyKFxuICAgIGNoYXB0ZXI6IENoYXB0ZXIsXG4gICAgb3B0aW9uczogUHJvY2Vzc2luZ09wdGlvbnNcbiAgKTogUHJvbWlzZTxQcm9jZXNzZWRDb250ZW50PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIEV4dHJhY3QgY2xlYW4gSFRNTCBmcm9tIGNoYXB0ZXIgY29udGVudFxuICAgIGNvbnN0IGV4dHJhY3RlZCA9IHRoaXMuZXh0cmFjdENvbnRlbnQoY2hhcHRlci5jb250ZW50KTtcblxuICAgIC8vIFVwZGF0ZSB0b2tlbml6ZXIgb3B0aW9uc1xuICAgIHRoaXMudG9rZW5pemVyLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgc2tpcFF1b3Rlczogb3B0aW9ucy5za2lwUXVvdGVzID8/IHRydWUsXG4gICAgICBza2lwTmFtZXM6IG9wdGlvbnMuc2tpcE5hbWVzID8/IHRydWUsXG4gICAgICBza2lwV29yZHM6IG5ldyBTZXQob3B0aW9ucy5leGNsdWRlV29yZHMpLFxuICAgIH0pO1xuXG4gICAgLy8gVG9rZW5pemUgdGhlIGNvbnRlbnRcbiAgICBjb25zdCB0b2tlbnMgPSB0aGlzLnRva2VuaXplci50b2tlbml6ZShleHRyYWN0ZWQuYm9keSk7XG5cbiAgICAvLyBHZXQgdW5pcXVlIHdvcmRzIGZvciBkYXRhYmFzZSBsb29rdXBcbiAgICBjb25zdCB1bmlxdWVXb3JkcyA9IFRva2VuaXplci5nZXRVbmlxdWVXb3Jkcyh0b2tlbnMpO1xuXG4gICAgLy8gTG9vayB1cCB3b3JkcyBpbiBkYXRhYmFzZVxuICAgIGNvbnN0IHt3b3JkRW50cmllcywgbG9va3VwcywgaGl0c30gPSBhd2FpdCB0aGlzLmxvb2t1cFdvcmRzKFxuICAgICAgdW5pcXVlV29yZHMsXG4gICAgICBvcHRpb25zLnNvdXJjZUxhbmd1YWdlLFxuICAgICAgb3B0aW9ucy50YXJnZXRMYW5ndWFnZVxuICAgICk7XG5cbiAgICAvLyBVcGRhdGUgcmVwbGFjZXIgb3B0aW9uc1xuICAgIHRoaXMud29yZFJlcGxhY2VyLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgZGVuc2l0eTogb3B0aW9ucy5kZW5zaXR5LFxuICAgICAgbWF4UHJvZmljaWVuY3k6IG9wdGlvbnMucHJvZmljaWVuY3lMZXZlbCxcbiAgICAgIG1pbldvcmRTcGFjaW5nOiBvcHRpb25zLm1pbldvcmRTcGFjaW5nID8/IDMsXG4gICAgICBzZWxlY3Rpb25TdHJhdGVneTogb3B0aW9ucy5zZWxlY3Rpb25TdHJhdGVneSA/PyAnZGlzdHJpYnV0ZWQnLFxuICAgICAgZXhjbHVkZVdvcmRzOiBuZXcgU2V0KG9wdGlvbnMuZXhjbHVkZVdvcmRzKSxcbiAgICB9KTtcblxuICAgIC8vIFBlcmZvcm0gd29yZCByZXBsYWNlbWVudFxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMud29yZFJlcGxhY2VyLnJlcGxhY2UoZXh0cmFjdGVkLmJvZHksIHRva2Vucywgd29yZEVudHJpZXMpO1xuXG4gICAgY29uc3QgcHJvY2Vzc2luZ1RpbWVNcyA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaHRtbDogcmVzdWx0Lmh0bWwsXG4gICAgICBmb3JlaWduV29yZHM6IHJlc3VsdC5mb3JlaWduV29yZHMsXG4gICAgICB0b2tlbnMsXG4gICAgICB1bmlxdWVXb3JkcyxcbiAgICAgIHN0YXRzOiB7XG4gICAgICAgIC4uLnJlc3VsdC5zdGF0cyxcbiAgICAgICAgcHJvY2Vzc2luZ1RpbWVNcyxcbiAgICAgICAgdW5pcXVlV29yZENvdW50OiB1bmlxdWVXb3Jkcy5sZW5ndGgsXG4gICAgICAgIGRhdGFiYXNlTG9va3VwczogbG9va3VwcyxcbiAgICAgICAgZGF0YWJhc2VIaXRzOiBoaXRzLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgY2xlYW4gY29udGVudCBmcm9tIEVQVUIgSFRNTFxuICAgKi9cbiAgZXh0cmFjdENvbnRlbnQoaHRtbDogc3RyaW5nKTogRXh0cmFjdGVkQ29udGVudCB7XG4gICAgY29uc3QgcmVzdWx0OiBFeHRyYWN0ZWRDb250ZW50ID0ge1xuICAgICAgYm9keTogJycsXG4gICAgICBzdHlsZXM6IFtdLFxuICAgIH07XG5cbiAgICAvLyBFeHRyYWN0IHRpdGxlXG4gICAgY29uc3QgdGl0bGVNYXRjaCA9IGh0bWwubWF0Y2goLzx0aXRsZVtePl0qPihbXFxzXFxTXSo/KTxcXC90aXRsZT4vaSk7XG4gICAgaWYgKHRpdGxlTWF0Y2gpIHtcbiAgICAgIHJlc3VsdC50aXRsZSA9IHRoaXMuZGVjb2RlSHRtbEVudGl0aWVzKHRpdGxlTWF0Y2hbMV0udHJpbSgpKTtcbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IGxhbmd1YWdlXG4gICAgY29uc3QgbGFuZ01hdGNoID0gaHRtbC5tYXRjaCgvPGh0bWxbXj5dKlxcc2xhbmc9W1wiJ10oW15cIiddKylbXCInXS9pKTtcbiAgICBpZiAobGFuZ01hdGNoKSB7XG4gICAgICByZXN1bHQubGFuZ3VhZ2UgPSBsYW5nTWF0Y2hbMV07XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCBzdHlsZXMgZnJvbSA8c3R5bGU+IHRhZ3NcbiAgICBjb25zdCBzdHlsZVJlZ2V4ID0gLzxzdHlsZVtePl0qPihbXFxzXFxTXSo/KTxcXC9zdHlsZT4vZ2k7XG4gICAgbGV0IHN0eWxlTWF0Y2g7XG4gICAgd2hpbGUgKChzdHlsZU1hdGNoID0gc3R5bGVSZWdleC5leGVjKGh0bWwpKSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnN0eWxlcy5wdXNoKHN0eWxlTWF0Y2hbMV0pO1xuICAgIH1cblxuICAgIC8vIEV4dHJhY3QgbGlua2VkIHN0eWxlc2hlZXRzIChqdXN0IHRoZSByZWZlcmVuY2VzLCBhY3R1YWwgY29udGVudCBoYW5kbGVkIGVsc2V3aGVyZSlcbiAgICBjb25zdCBsaW5rUmVnZXggPSAvPGxpbmtbXj5dKnJlbD1bXCInXXN0eWxlc2hlZXRbXCInXVtePl0qaHJlZj1bXCInXShbXlwiJ10rKVtcIiddW14+XSo+L2dpO1xuICAgIC8vIE5vdGU6IFdlJ2QgbmVlZCB0aGUgRVBVQiBjb250ZXh0IHRvIHJlc29sdmUgdGhlc2UsIHNraXBwaW5nIGZvciBub3dcblxuICAgIC8vIEV4dHJhY3QgYm9keSBjb250ZW50XG4gICAgY29uc3QgYm9keU1hdGNoID0gaHRtbC5tYXRjaCgvPGJvZHlbXj5dKj4oW1xcc1xcU10qPyk8XFwvYm9keT4vaSk7XG4gICAgaWYgKGJvZHlNYXRjaCkge1xuICAgICAgcmVzdWx0LmJvZHkgPSBib2R5TWF0Y2hbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIGJvZHkgdGFnLCB0cnkgdG8gZXh0cmFjdCBjb250ZW50IGFmdGVyIDwvaGVhZD4gb3IgdXNlIGVudGlyZSBjb250ZW50XG4gICAgICBjb25zdCBhZnRlckhlYWRNYXRjaCA9IGh0bWwubWF0Y2goLzxcXC9oZWFkPlxccyooW1xcc1xcU10qPykkL2kpO1xuICAgICAgaWYgKGFmdGVySGVhZE1hdGNoKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjbG9zaW5nIHRhZ3NcbiAgICAgICAgcmVzdWx0LmJvZHkgPSBhZnRlckhlYWRNYXRjaFsxXS5yZXBsYWNlKC88XFwvaHRtbD5cXHMqJC9pLCAnJykudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gaGVhZCBlaXRoZXIsIHN0cmlwIGRvY3R5cGUgYW5kIGh0bWwgd3JhcHBlclxuICAgICAgICByZXN1bHQuYm9keSA9IGh0bWxcbiAgICAgICAgICAucmVwbGFjZSgvPCFET0NUWVBFW14+XSo+L2ksICcnKVxuICAgICAgICAgIC5yZXBsYWNlKC88XFwvP2h0bWxbXj5dKj4vZ2ksICcnKVxuICAgICAgICAgIC5yZXBsYWNlKC88aGVhZFtePl0qPltcXHNcXFNdKj88XFwvaGVhZD4vaSwgJycpXG4gICAgICAgICAgLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cCB0aGUgYm9keSBjb250ZW50XG4gICAgcmVzdWx0LmJvZHkgPSB0aGlzLmNsZWFuQm9keUNvbnRlbnQocmVzdWx0LmJvZHkpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBib2R5IGNvbnRlbnQgZm9yIHByb2Nlc3NpbmdcbiAgICovXG4gIHByaXZhdGUgY2xlYW5Cb2R5Q29udGVudChodG1sOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiAoXG4gICAgICBodG1sXG4gICAgICAgIC8vIFJlbW92ZSBYTUwgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbnNcbiAgICAgICAgLnJlcGxhY2UoLzxcXD94bWxbXj9dKlxcPz4vZ2ksICcnKVxuICAgICAgICAvLyBOb3JtYWxpemUgd2hpdGVzcGFjZSBpbiB0ZXh0IG5vZGVzIChidXQgcHJlc2VydmUgc3RydWN0dXJlKVxuICAgICAgICAucmVwbGFjZSgvPlxccys8L2csICc+IDwnKVxuICAgICAgICAvLyBSZW1vdmUgZW1wdHkgcGFyYWdyYXBoc1xuICAgICAgICAucmVwbGFjZSgvPHBbXj5dKj5cXHMqPFxcL3A+L2dpLCAnJylcbiAgICAgICAgLy8gTm9ybWFsaXplIGxpbmUgYnJlYWtzXG4gICAgICAgIC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpXG4gICAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcbicpXG4gICAgICAgIC8vIFJlbW92ZSBleGNlc3NpdmUgYmxhbmsgbGluZXNcbiAgICAgICAgLnJlcGxhY2UoL1xcbnszLH0vZywgJ1xcblxcbicpXG4gICAgICAgIC50cmltKClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBIVE1MIGVudGl0aWVzXG4gICAqL1xuICBwcml2YXRlIGRlY29kZUh0bWxFbnRpdGllcyh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGVudGl0aWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgJyZhbXA7JzogJyYnLFxuICAgICAgJyZsdDsnOiAnPCcsXG4gICAgICAnJmd0Oyc6ICc+JyxcbiAgICAgICcmcXVvdDsnOiAnXCInLFxuICAgICAgJyYjMzk7JzogXCInXCIsXG4gICAgICAnJmFwb3M7JzogXCInXCIsXG4gICAgICAnJm5ic3A7JzogJyAnLFxuICAgICAgJyZtZGFzaDsnOiAn4oCUJyxcbiAgICAgICcmbmRhc2g7JzogJ+KAkycsXG4gICAgICAnJmhlbGxpcDsnOiAn4oCmJyxcbiAgICAgICcmbHNxdW87JzogJ1xcdTIwMTgnLFxuICAgICAgJyZyc3F1bzsnOiAnXFx1MjAxOScsXG4gICAgICAnJmxkcXVvOyc6ICdcXHUyMDFDJyxcbiAgICAgICcmcmRxdW87JzogJ1xcdTIwMUQnLFxuICAgIH07XG5cbiAgICBsZXQgZGVjb2RlZCA9IHRleHQ7XG4gICAgZm9yIChjb25zdCBbZW50aXR5LCBjaGFyXSBvZiBPYmplY3QuZW50cmllcyhlbnRpdGllcykpIHtcbiAgICAgIGRlY29kZWQgPSBkZWNvZGVkLnJlcGxhY2UobmV3IFJlZ0V4cChlbnRpdHksICdnJyksIGNoYXIpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBudW1lcmljIGVudGl0aWVzXG4gICAgZGVjb2RlZCA9IGRlY29kZWQucmVwbGFjZSgvJiMoXFxkKyk7L2csIChfLCBjb2RlKSA9PlxuICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjb2RlLCAxMCkpXG4gICAgKTtcbiAgICBkZWNvZGVkID0gZGVjb2RlZC5yZXBsYWNlKC8mI3goWzAtOWEtZl0rKTsvZ2ksIChfLCBjb2RlKSA9PlxuICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjb2RlLCAxNikpXG4gICAgKTtcblxuICAgIHJldHVybiBkZWNvZGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2sgdXAgd29yZHMgaW4gdGhlIGR5bmFtaWMgd29yZCBkYXRhYmFzZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBsb29rdXBXb3JkcyhcbiAgICB3b3Jkczogc3RyaW5nW10sXG4gICAgc291cmNlTGFuZ3VhZ2U6IExhbmd1YWdlLFxuICAgIHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZVxuICApOiBQcm9taXNlPHtcbiAgICB3b3JkRW50cmllczogTWFwPHN0cmluZywgV29yZEVudHJ5IHwgbnVsbD47XG4gICAgbG9va3VwczogbnVtYmVyO1xuICAgIGhpdHM6IG51bWJlcjtcbiAgfT4ge1xuICAgIGNvbnN0IHdvcmRFbnRyaWVzID0gbmV3IE1hcDxzdHJpbmcsIFdvcmRFbnRyeSB8IG51bGw+KCk7XG4gICAgbGV0IGxvb2t1cHMgPSAwO1xuICAgIGxldCBoaXRzID0gMDtcblxuICAgIGZvciAoY29uc3Qgd29yZCBvZiB3b3Jkcykge1xuICAgICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7c291cmNlTGFuZ3VhZ2V9OiR7dGFyZ2V0TGFuZ3VhZ2V9OiR7d29yZH1gO1xuICAgICAgaWYgKHRoaXMud29yZENhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy53b3JkQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgd29yZEVudHJpZXMuc2V0KHdvcmQsIGNhY2hlZCA/PyBudWxsKTtcbiAgICAgICAgaWYgKGNhY2hlZCkgaGl0cysrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbG9va3VwcysrO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBkeW5hbWljV29yZERhdGFiYXNlLmxvb2t1cFdvcmQoXG4gICAgICAgICAgd29yZCxcbiAgICAgICAgICBzb3VyY2VMYW5ndWFnZSxcbiAgICAgICAgICB0YXJnZXRMYW5ndWFnZVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBjb25zdCBlbnRyeTogV29yZEVudHJ5ID0ge1xuICAgICAgICAgICAgaWQ6IHJlc3VsdC5pZCxcbiAgICAgICAgICAgIHNvdXJjZVdvcmQ6IHJlc3VsdC5zb3VyY2VXb3JkLFxuICAgICAgICAgICAgdGFyZ2V0V29yZDogcmVzdWx0LnRhcmdldFdvcmQsXG4gICAgICAgICAgICBzb3VyY2VMYW5ndWFnZSxcbiAgICAgICAgICAgIHRhcmdldExhbmd1YWdlLFxuICAgICAgICAgICAgcHJvZmljaWVuY3lMZXZlbDogcmVzdWx0LnByb2ZpY2llbmN5TGV2ZWwsXG4gICAgICAgICAgICBmcmVxdWVuY3lSYW5rOiByZXN1bHQuZnJlcXVlbmN5UmFuayxcbiAgICAgICAgICAgIHBhcnRPZlNwZWVjaDogcmVzdWx0LnBhcnRPZlNwZWVjaCB8fCAndW5rbm93bicsXG4gICAgICAgICAgICBwcm9udW5jaWF0aW9uOiByZXN1bHQucHJvbnVuY2lhdGlvbixcbiAgICAgICAgICAgIHZhcmlhbnRzOiByZXN1bHQudmFyaWFudHMsXG4gICAgICAgICAgfTtcbiAgICAgICAgICB3b3JkRW50cmllcy5zZXQod29yZCwgZW50cnkpO1xuICAgICAgICAgIHRoaXMud29yZENhY2hlLnNldChjYWNoZUtleSwgZW50cnkpO1xuICAgICAgICAgIGhpdHMrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3b3JkRW50cmllcy5zZXQod29yZCwgbnVsbCk7XG4gICAgICAgICAgdGhpcy53b3JkQ2FjaGUuc2V0KGNhY2hlS2V5LCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gbG9va3VwIHdvcmQgXCIke3dvcmR9XCI6YCwgZXJyb3IpO1xuICAgICAgICB3b3JkRW50cmllcy5zZXQod29yZCwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHt3b3JkRW50cmllcywgbG9va3VwcywgaGl0c307XG4gIH1cblxuICAvKipcbiAgICogR2V0IHdvcmQgYXQgYSBzcGVjaWZpYyBwb3NpdGlvbiBpbiB0aGUgb3JpZ2luYWwgY29udGVudFxuICAgKi9cbiAgZ2V0V29yZEF0UG9zaXRpb24odG9rZW5zOiBUb2tlbltdLCBwb3NpdGlvbjogbnVtYmVyKTogVG9rZW4gfCBudWxsIHtcbiAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgaWYgKHBvc2l0aW9uID49IHRva2VuLnN0YXJ0SW5kZXggJiYgcG9zaXRpb24gPD0gdG9rZW4uZW5kSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd29yZHMgaW4gYSByYW5nZSBvZiBwb3NpdGlvbnNcbiAgICovXG4gIGdldFdvcmRzSW5SYW5nZSh0b2tlbnM6IFRva2VuW10sIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogVG9rZW5bXSB7XG4gICAgcmV0dXJuIHRva2Vucy5maWx0ZXIoXG4gICAgICB0b2tlbiA9PiB0b2tlbi5zdGFydEluZGV4ID49IHN0YXJ0ICYmIHRva2VuLmVuZEluZGV4IDw9IGVuZFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvbnRleHQgYXJvdW5kIGEgd29yZCAoc3Vycm91bmRpbmcgc2VudGVuY2UpXG4gICAqL1xuICBnZXRXb3JkQ29udGV4dChodG1sOiBzdHJpbmcsIHRva2VuOiBUb2tlbiwgY29udGV4dExlbmd0aDogbnVtYmVyID0gMTAwKTogc3RyaW5nIHtcbiAgICBjb25zdCBwbGFpblRleHQgPSB0aGlzLnN0cmlwSHRtbChodG1sKTtcblxuICAgIC8vIEZpbmQgYXBwcm94aW1hdGUgcG9zaXRpb24gaW4gcGxhaW4gdGV4dFxuICAgIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWNhdGlvbjsgaW4gcHJhY3RpY2UgeW91J2QgbmVlZCBwcm9wZXIgcG9zaXRpb24gbWFwcGluZ1xuICAgIGNvbnN0IHdvcmRQb3MgPSBwbGFpblRleHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKHRva2VuLndvcmQudG9Mb3dlckNhc2UoKSk7XG4gICAgaWYgKHdvcmRQb3MgPT09IC0xKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCB3b3JkUG9zIC0gY29udGV4dExlbmd0aCk7XG4gICAgY29uc3QgZW5kID0gTWF0aC5taW4ocGxhaW5UZXh0Lmxlbmd0aCwgd29yZFBvcyArIHRva2VuLndvcmQubGVuZ3RoICsgY29udGV4dExlbmd0aCk7XG5cbiAgICBsZXQgY29udGV4dCA9IHBsYWluVGV4dC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG5cbiAgICAvLyBUcnkgdG8gZXh0ZW5kIHRvIHNlbnRlbmNlIGJvdW5kYXJpZXNcbiAgICBjb25zdCBzZW50ZW5jZVN0YXJ0ID0gY29udGV4dC5sYXN0SW5kZXhPZignLicsIHdvcmRQb3MgLSBzdGFydCk7XG4gICAgY29uc3Qgc2VudGVuY2VFbmQgPSBjb250ZXh0LmluZGV4T2YoJy4nLCB3b3JkUG9zIC0gc3RhcnQgKyB0b2tlbi53b3JkLmxlbmd0aCk7XG5cbiAgICBpZiAoc2VudGVuY2VTdGFydCAhPT0gLTEgJiYgc2VudGVuY2VFbmQgIT09IC0xKSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dC5zdWJzdHJpbmcoc2VudGVuY2VTdGFydCArIDEsIHNlbnRlbmNlRW5kICsgMSkudHJpbSgpO1xuICAgIH1cblxuICAgIHJldHVybiAoc3RhcnQgPiAwID8gJy4uLicgOiAnJykgKyBjb250ZXh0ICsgKGVuZCA8IHBsYWluVGV4dC5sZW5ndGggPyAnLi4uJyA6ICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJpcCBIVE1MIHRhZ3MgZnJvbSBjb250ZW50XG4gICAqL1xuICBwcml2YXRlIHN0cmlwSHRtbChodG1sOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBodG1sXG4gICAgICAucmVwbGFjZSgvPHNjcmlwdFtePl0qPltcXHNcXFNdKj88XFwvc2NyaXB0Pi9naSwgJycpXG4gICAgICAucmVwbGFjZSgvPHN0eWxlW14+XSo+W1xcc1xcU10qPzxcXC9zdHlsZT4vZ2ksICcnKVxuICAgICAgLnJlcGxhY2UoLzxbXj5dKz4vZywgJyAnKVxuICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKVxuICAgICAgLnRyaW0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgd29yZCBjYWNoZVxuICAgKi9cbiAgY2xlYXJDYWNoZSgpOiB2b2lkIHtcbiAgICB0aGlzLndvcmRDYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjYWNoZSBzdGF0aXN0aWNzXG4gICAqL1xuICBnZXRDYWNoZVN0YXRzKCk6IHtzaXplOiBudW1iZXI7IG1lbW9yeUVzdGltYXRlOiBudW1iZXJ9IHtcbiAgICBjb25zdCBzaXplID0gdGhpcy53b3JkQ2FjaGUuc2l6ZTtcbiAgICAvLyBSb3VnaCBlc3RpbWF0ZTogfjIwMCBieXRlcyBwZXIgZW50cnlcbiAgICBjb25zdCBtZW1vcnlFc3RpbWF0ZSA9IHNpemUgKiAyMDA7XG4gICAgcmV0dXJuIHtzaXplLCBtZW1vcnlFc3RpbWF0ZX07XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgY29uc3QgdGV4dFByb2Nlc3NpbmdTZXJ2aWNlID0gbmV3IFRleHRQcm9jZXNzaW5nU2VydmljZSgpO1xuIiwiLyoqXG4gKiBNZXRhZGF0YSBFeHRyYWN0b3JcbiAqXG4gKiBIaWdoLWxldmVsIHV0aWxpdHkgZm9yIGV4dHJhY3RpbmcgY29tcGxldGUgbWV0YWRhdGEgZnJvbSBFUFVCIGZpbGVzLlxuICogQ29tYmluZXMgRVBVQkV4dHJhY3RvciB3aXRoIFRPQyBwYXJzaW5nIHRvIHByb3ZpZGUgYSB1bmlmaWVkIEFQSS5cbiAqL1xuXG5pbXBvcnQgUk5GUyBmcm9tICdyZWFjdC1uYXRpdmUtZnMnO1xuXG5pbXBvcnQgdHlwZSB7Qm9va01ldGFkYXRhLCBUYWJsZU9mQ29udGVudHNJdGVtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7RVBVQkV4dHJhY3Rvcn0gZnJvbSAnLi9FUFVCRXh0cmFjdG9yJztcbmltcG9ydCB0eXBlIHtFUFVCUGFja2FnZSwgRVBVQk1hbmlmZXN0SXRlbX0gZnJvbSAnLi9FUFVCRXh0cmFjdG9yJztcbmltcG9ydCB7cGFyc2VOQ1gsIHBhcnNlTkFWfSBmcm9tICcuL1RPQ1BhcnNlcic7XG5pbXBvcnQgdHlwZSB7VE9DUGFyc2VSZXN1bHR9IGZyb20gJy4vVE9DUGFyc2VyJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVHlwZXNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGludGVyZmFjZSBFeHRyYWN0ZWRNZXRhZGF0YSB7XG4gIG1ldGFkYXRhOiBCb29rTWV0YWRhdGE7XG4gIHRhYmxlT2ZDb250ZW50czogVGFibGVPZkNvbnRlbnRzSXRlbVtdO1xuICBjb3ZlckltYWdlUGF0aD86IHN0cmluZztcbiAgY2hhcHRlckNvdW50OiBudW1iZXI7XG4gIGVzdGltYXRlZFdvcmRDb3VudD86IG51bWJlcjtcbiAgZXB1YlZlcnNpb246IHN0cmluZztcbiAgbGFuZ3VhZ2U/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ292ZXJFeHRyYWN0aW9uUmVzdWx0IHtcbiAgYmFzZTY0RGF0YTogc3RyaW5nO1xuICBtaW1lVHlwZTogc3RyaW5nO1xuICBmaWxlTmFtZTogc3RyaW5nO1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBNZXRhZGF0YSBFeHRyYWN0b3IgQ2xhc3Ncbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGNsYXNzIE1ldGFkYXRhRXh0cmFjdG9yIHtcbiAgcHJpdmF0ZSBleHRyYWN0b3I6IEVQVUJFeHRyYWN0b3I7XG4gIHByaXZhdGUgZXB1YlBhY2thZ2U6IEVQVUJQYWNrYWdlIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgZmlsZVBhdGg6IHN0cmluZyA9ICcnO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZXh0cmFjdG9yID0gbmV3IEVQVUJFeHRyYWN0b3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGNvbXBsZXRlIG1ldGFkYXRhIGZyb20gYW4gRVBVQiBmaWxlXG4gICAqL1xuICBhc3luYyBleHRyYWN0RnJvbUZpbGUoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8RXh0cmFjdGVkTWV0YWRhdGE+IHtcbiAgICB0aGlzLmZpbGVQYXRoID0gZmlsZVBhdGg7XG5cbiAgICAvLyBMb2FkIHRoZSBFUFVCXG4gICAgYXdhaXQgdGhpcy5leHRyYWN0b3IubG9hZChmaWxlUGF0aCk7XG5cbiAgICAvLyBQYXJzZSBjb250YWluZXIueG1sXG4gICAgY29uc3QgY29udGFpbmVyID0gYXdhaXQgdGhpcy5leHRyYWN0b3IucGFyc2VDb250YWluZXIoKTtcblxuICAgIC8vIFBhcnNlIHRoZSBPUEYgcGFja2FnZVxuICAgIHRoaXMuZXB1YlBhY2thZ2UgPSBhd2FpdCB0aGlzLmV4dHJhY3Rvci5wYXJzZVBhY2thZ2UoY29udGFpbmVyLnJvb3RGaWxlUGF0aCk7XG5cbiAgICAvLyBFeHRyYWN0IHRhYmxlIG9mIGNvbnRlbnRzXG4gICAgY29uc3QgdG9jUmVzdWx0ID0gYXdhaXQgdGhpcy5leHRyYWN0VGFibGVPZkNvbnRlbnRzKCk7XG5cbiAgICAvLyBCdWlsZCBtZXRhZGF0YSBvYmplY3RcbiAgICBjb25zdCBtZXRhZGF0YTogQm9va01ldGFkYXRhID0ge1xuICAgICAgdGl0bGU6IHRoaXMuZXB1YlBhY2thZ2UubWV0YWRhdGEudGl0bGUsXG4gICAgICBhdXRob3I6IHRoaXMuZXB1YlBhY2thZ2UubWV0YWRhdGEuY3JlYXRvcixcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmVwdWJQYWNrYWdlLm1ldGFkYXRhLmRlc2NyaXB0aW9uLFxuICAgICAgcHVibGlzaGVyOiB0aGlzLmVwdWJQYWNrYWdlLm1ldGFkYXRhLnB1Ymxpc2hlcixcbiAgICAgIHB1Ymxpc2hEYXRlOiB0aGlzLmVwdWJQYWNrYWdlLm1ldGFkYXRhLmRhdGUsXG4gICAgICBpc2JuOiB0aGlzLmV4dHJhY3RJU0JOKHRoaXMuZXB1YlBhY2thZ2UubWV0YWRhdGEuaWRlbnRpZmllciksXG4gICAgICBzdWJqZWN0czogdGhpcy5lcHViUGFja2FnZS5tZXRhZGF0YS5zdWJqZWN0LFxuICAgIH07XG5cbiAgICAvLyBDb3VudCBjaGFwdGVycyAoc3BpbmUgaXRlbXMpXG4gICAgY29uc3QgY2hhcHRlckNvdW50ID0gdGhpcy5lcHViUGFja2FnZS5zcGluZS5maWx0ZXIoXG4gICAgICBpdGVtID0+IGl0ZW0ubGluZWFyLFxuICAgICkubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGFkYXRhLFxuICAgICAgdGFibGVPZkNvbnRlbnRzOiB0b2NSZXN1bHQuaXRlbXMsXG4gICAgICBjaGFwdGVyQ291bnQsXG4gICAgICBlcHViVmVyc2lvbjogdGhpcy5lcHViUGFja2FnZS52ZXJzaW9uLFxuICAgICAgbGFuZ3VhZ2U6IHRoaXMuZXB1YlBhY2thZ2UubWV0YWRhdGEubGFuZ3VhZ2UsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGFuZCBzYXZlIGNvdmVyIGltYWdlXG4gICAqL1xuICBhc3luYyBleHRyYWN0Q292ZXIob3V0cHV0RGlyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICBpZiAoIXRoaXMuZXB1YlBhY2thZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRVBVQiBub3QgbG9hZGVkLiBDYWxsIGV4dHJhY3RGcm9tRmlsZSBmaXJzdC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb3ZlcklkID0gdGhpcy5lcHViUGFja2FnZS5jb3ZlckltYWdlSWQ7XG4gICAgaWYgKCFjb3ZlcklkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBjb3Zlckl0ZW0gPSB0aGlzLmVwdWJQYWNrYWdlLm1hbmlmZXN0LmdldChjb3ZlcklkKTtcbiAgICBpZiAoIWNvdmVySXRlbSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjb3ZlciBpbWFnZSBhcyBiYXNlNjRcbiAgICAgIGNvbnN0IGJhc2U2NERhdGEgPSBhd2FpdCB0aGlzLmV4dHJhY3Rvci5nZXRCYXNlNjRGaWxlKGNvdmVySXRlbS5ocmVmKTtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGZpbGUgZXh0ZW5zaW9uXG4gICAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmdldEltYWdlRXh0ZW5zaW9uKGNvdmVySXRlbS5tZWRpYVR5cGUpO1xuICAgICAgY29uc3QgZmlsZU5hbWUgPSBgY292ZXIuJHtleHRlbnNpb259YDtcbiAgICAgIGNvbnN0IG91dHB1dFBhdGggPSBgJHtvdXRwdXREaXJ9LyR7ZmlsZU5hbWV9YDtcblxuICAgICAgLy8gRW5zdXJlIG91dHB1dCBkaXJlY3RvcnkgZXhpc3RzXG4gICAgICBhd2FpdCBSTkZTLm1rZGlyKG91dHB1dERpcik7XG5cbiAgICAgIC8vIFdyaXRlIHRoZSBpbWFnZSBmaWxlXG4gICAgICBhd2FpdCBSTkZTLndyaXRlRmlsZShvdXRwdXRQYXRoLCBiYXNlNjREYXRhLCAnYmFzZTY0Jyk7XG5cbiAgICAgIHJldHVybiBvdXRwdXRQYXRoO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBleHRyYWN0IGNvdmVyIGltYWdlOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY292ZXIgaW1hZ2UgYXMgYmFzZTY0IChmb3IgcHJldmlldyB3aXRob3V0IHNhdmluZylcbiAgICovXG4gIGFzeW5jIGdldENvdmVyQmFzZTY0KCk6IFByb21pc2U8Q292ZXJFeHRyYWN0aW9uUmVzdWx0IHwgbnVsbD4ge1xuICAgIGlmICghdGhpcy5lcHViUGFja2FnZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFUFVCIG5vdCBsb2FkZWQuIENhbGwgZXh0cmFjdEZyb21GaWxlIGZpcnN0LicpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvdmVySWQgPSB0aGlzLmVwdWJQYWNrYWdlLmNvdmVySW1hZ2VJZDtcbiAgICBpZiAoIWNvdmVySWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGNvdmVySXRlbSA9IHRoaXMuZXB1YlBhY2thZ2UubWFuaWZlc3QuZ2V0KGNvdmVySWQpO1xuICAgIGlmICghY292ZXJJdGVtKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYmFzZTY0RGF0YSA9IGF3YWl0IHRoaXMuZXh0cmFjdG9yLmdldEJhc2U2NEZpbGUoY292ZXJJdGVtLmhyZWYpO1xuICAgICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5nZXRJbWFnZUV4dGVuc2lvbihjb3Zlckl0ZW0ubWVkaWFUeXBlKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZTY0RGF0YSxcbiAgICAgICAgbWltZVR5cGU6IGNvdmVySXRlbS5tZWRpYVR5cGUsXG4gICAgICAgIGZpbGVOYW1lOiBgY292ZXIuJHtleHRlbnNpb259YCxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGdldCBjb3ZlciBpbWFnZTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCB0YWJsZSBvZiBjb250ZW50c1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBleHRyYWN0VGFibGVPZkNvbnRlbnRzKCk6IFByb21pc2U8VE9DUGFyc2VSZXN1bHQ+IHtcbiAgICBpZiAoIXRoaXMuZXB1YlBhY2thZ2UpIHtcbiAgICAgIHJldHVybiB7aXRlbXM6IFtdfTtcbiAgICB9XG5cbiAgICBjb25zdCB0b2NJZCA9IHRoaXMuZXB1YlBhY2thZ2UudG9jSWQ7XG4gICAgaWYgKCF0b2NJZCkge1xuICAgICAgLy8gRmFsbGJhY2s6IGdlbmVyYXRlIFRPQyBmcm9tIHNwaW5lXG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVRPQ0Zyb21TcGluZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IHRvY0l0ZW0gPSB0aGlzLmVwdWJQYWNrYWdlLm1hbmlmZXN0LmdldCh0b2NJZCk7XG4gICAgaWYgKCF0b2NJdGVtKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVRPQ0Zyb21TcGluZSgpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0b2NDb250ZW50ID0gYXdhaXQgdGhpcy5leHRyYWN0b3IuZ2V0RmlsZSh0b2NJdGVtLmhyZWYpO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgZm9ybWF0IGFuZCBwYXJzZVxuICAgICAgaWYgKFxuICAgICAgICB0b2NJdGVtLm1lZGlhVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3gtZHRibmN4K3htbCcgfHxcbiAgICAgICAgdG9jSXRlbS5ocmVmLmVuZHNXaXRoKCcubmN4JylcbiAgICAgICkge1xuICAgICAgICAvLyBOQ1ggZm9ybWF0IChFUFVCIDIpXG4gICAgICAgIHJldHVybiBwYXJzZU5DWCh0b2NDb250ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5BViBmb3JtYXQgKEVQVUIgMylcbiAgICAgICAgcmV0dXJuIHBhcnNlTkFWKHRvY0NvbnRlbnQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBUT0MsIGdlbmVyYXRpbmcgZnJvbSBzcGluZTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVRPQ0Zyb21TcGluZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIGJhc2ljIFRPQyBmcm9tIHRoZSBzcGluZSB3aGVuIG5vIHByb3BlciBUT0MgZXhpc3RzXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlVE9DRnJvbVNwaW5lKCk6IFRPQ1BhcnNlUmVzdWx0IHtcbiAgICBpZiAoIXRoaXMuZXB1YlBhY2thZ2UpIHtcbiAgICAgIHJldHVybiB7aXRlbXM6IFtdfTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtczogVGFibGVPZkNvbnRlbnRzSXRlbVtdID0gW107XG5cbiAgICB0aGlzLmVwdWJQYWNrYWdlLnNwaW5lLmZvckVhY2goKHNwaW5lSXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghc3BpbmVJdGVtLmxpbmVhcikgcmV0dXJuO1xuXG4gICAgICBjb25zdCBtYW5pZmVzdEl0ZW0gPSB0aGlzLmVwdWJQYWNrYWdlIS5tYW5pZmVzdC5nZXQoc3BpbmVJdGVtLmlkcmVmKTtcbiAgICAgIGlmIChtYW5pZmVzdEl0ZW0pIHtcbiAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgaWQ6IHNwaW5lSXRlbS5pZHJlZixcbiAgICAgICAgICB0aXRsZTogYENoYXB0ZXIgJHtpbmRleCArIDF9YCxcbiAgICAgICAgICBocmVmOiBtYW5pZmVzdEl0ZW0uaHJlZixcbiAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge2l0ZW1zfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb3JkZXJlZCBsaXN0IG9mIGNvbnRlbnQgZmlsZXMgZnJvbSBzcGluZVxuICAgKi9cbiAgZ2V0U3BpbmVJdGVtcygpOiBFUFVCTWFuaWZlc3RJdGVtW10ge1xuICAgIGlmICghdGhpcy5lcHViUGFja2FnZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zOiBFUFVCTWFuaWZlc3RJdGVtW10gPSBbXTtcblxuICAgIGZvciAoY29uc3Qgc3BpbmVJdGVtIG9mIHRoaXMuZXB1YlBhY2thZ2Uuc3BpbmUpIHtcbiAgICAgIGNvbnN0IG1hbmlmZXN0SXRlbSA9IHRoaXMuZXB1YlBhY2thZ2UubWFuaWZlc3QuZ2V0KHNwaW5lSXRlbS5pZHJlZik7XG4gICAgICBpZiAobWFuaWZlc3RJdGVtKSB7XG4gICAgICAgIGl0ZW1zLnB1c2gobWFuaWZlc3RJdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvbnRlbnQgb2YgYSBjaGFwdGVyIGJ5IGhyZWZcbiAgICovXG4gIGFzeW5jIGdldENoYXB0ZXJDb250ZW50KGhyZWY6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuZXh0cmFjdG9yLmdldEZpbGUoaHJlZik7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBJU0JOIGZyb20gaWRlbnRpZmllciBpZiBwcmVzZW50XG4gICAqL1xuICBwcml2YXRlIGV4dHJhY3RJU0JOKGlkZW50aWZpZXI/OiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGlmICghaWRlbnRpZmllcikgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIC8vIFRyeSB0byBleHRyYWN0IElTQk4tMTAgb3IgSVNCTi0xM1xuICAgIGNvbnN0IGlzYm4xM01hdGNoID0gaWRlbnRpZmllci5tYXRjaCgvKD86SVNCTls6XFxzLV0/KT8oXFxkezEzfSkvaSk7XG4gICAgaWYgKGlzYm4xM01hdGNoKSByZXR1cm4gaXNibjEzTWF0Y2hbMV07XG5cbiAgICBjb25zdCBpc2JuMTBNYXRjaCA9IGlkZW50aWZpZXIubWF0Y2goXG4gICAgICAvKD86SVNCTls6XFxzLV0/KT8oXFxkezl9W1xcZFh4XSkvaSxcbiAgICApO1xuICAgIGlmIChpc2JuMTBNYXRjaCkgcmV0dXJuIGlzYm4xME1hdGNoWzFdO1xuXG4gICAgLy8gSWYgaXQgbG9va3MgbGlrZSBhIFVSTiwgdHJ5IHRvIGV4dHJhY3QgSVNCTlxuICAgIGNvbnN0IHVybk1hdGNoID0gaWRlbnRpZmllci5tYXRjaCgvdXJuOmlzYm46KFxcZHsxMH18XFxkezEzfSkvaSk7XG4gICAgaWYgKHVybk1hdGNoKSByZXR1cm4gdXJuTWF0Y2hbMV07XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBpbWFnZSBmaWxlIGV4dGVuc2lvbiBmcm9tIE1JTUUgdHlwZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRJbWFnZUV4dGVuc2lvbihtaW1lVHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBtaW1lVG9FeHQ6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAnaW1hZ2UvanBlZyc6ICdqcGcnLFxuICAgICAgJ2ltYWdlL2pwZyc6ICdqcGcnLFxuICAgICAgJ2ltYWdlL3BuZyc6ICdwbmcnLFxuICAgICAgJ2ltYWdlL2dpZic6ICdnaWYnLFxuICAgICAgJ2ltYWdlL3N2Zyt4bWwnOiAnc3ZnJyxcbiAgICAgICdpbWFnZS93ZWJwJzogJ3dlYnAnLFxuICAgIH07XG5cbiAgICByZXR1cm4gbWltZVRvRXh0W21pbWVUeXBlLnRvTG93ZXJDYXNlKCldIHx8ICdqcGcnO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIHJlc291cmNlc1xuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLmV4dHJhY3Rvci5kaXNwb3NlKCk7XG4gICAgdGhpcy5lcHViUGFja2FnZSA9IG51bGw7XG4gICAgdGhpcy5maWxlUGF0aCA9ICcnO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFF1aWNrIEV4dHJhY3Rpb24gRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogUXVpY2sgZnVuY3Rpb24gdG8gZXh0cmFjdCBqdXN0IHRoZSBiYXNpYyBtZXRhZGF0YVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEVQVUJNZXRhZGF0YShcbiAgZmlsZVBhdGg6IHN0cmluZyxcbik6IFByb21pc2U8Qm9va01ldGFkYXRhPiB7XG4gIGNvbnN0IGV4dHJhY3RvciA9IG5ldyBNZXRhZGF0YUV4dHJhY3RvcigpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4dHJhY3Rvci5leHRyYWN0RnJvbUZpbGUoZmlsZVBhdGgpO1xuICAgIHJldHVybiByZXN1bHQubWV0YWRhdGE7XG4gIH0gZmluYWxseSB7XG4gICAgZXh0cmFjdG9yLmRpc3Bvc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFF1aWNrIGZ1bmN0aW9uIHRvIGV4dHJhY3QgbWV0YWRhdGEgYW5kIFRPQ1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEVQVUJJbmZvKFxuICBmaWxlUGF0aDogc3RyaW5nLFxuKTogUHJvbWlzZTxFeHRyYWN0ZWRNZXRhZGF0YT4ge1xuICBjb25zdCBleHRyYWN0b3IgPSBuZXcgTWV0YWRhdGFFeHRyYWN0b3IoKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZXh0cmFjdG9yLmV4dHJhY3RGcm9tRmlsZShmaWxlUGF0aCk7XG4gIH0gZmluYWxseSB7XG4gICAgZXh0cmFjdG9yLmRpc3Bvc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFF1aWNrIGZ1bmN0aW9uIHRvIGV4dHJhY3QgY292ZXIgaW1hZ2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RFUFVCQ292ZXIoXG4gIGZpbGVQYXRoOiBzdHJpbmcsXG4gIG91dHB1dERpcjogc3RyaW5nLFxuKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIGNvbnN0IGV4dHJhY3RvciA9IG5ldyBNZXRhZGF0YUV4dHJhY3RvcigpO1xuICB0cnkge1xuICAgIGF3YWl0IGV4dHJhY3Rvci5leHRyYWN0RnJvbUZpbGUoZmlsZVBhdGgpO1xuICAgIHJldHVybiBhd2FpdCBleHRyYWN0b3IuZXh0cmFjdENvdmVyKG91dHB1dERpcik7XG4gIH0gZmluYWxseSB7XG4gICAgZXh0cmFjdG9yLmRpc3Bvc2UoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBCb29rIFBhcnNlciBTZXJ2aWNlIC0gUGFyc2VzIHZhcmlvdXMgZS1ib29rIGZvcm1hdHNcbiAqL1xuXG4vLyBNYWluIHNlcnZpY2UgYW5kIHBhcnNlclxuZXhwb3J0IHtCb29rUGFyc2VyU2VydmljZX0gZnJvbSAnLi9Cb29rUGFyc2VyU2VydmljZSc7XG5leHBvcnQge0VQVUJQYXJzZXJ9IGZyb20gJy4vRVBVQlBhcnNlcic7XG5leHBvcnQge1RYVFBhcnNlcn0gZnJvbSAnLi9UWFRQYXJzZXInO1xuZXhwb3J0IHtGQjJQYXJzZXJ9IGZyb20gJy4vRkIyUGFyc2VyJztcbmV4cG9ydCB7TU9CSVBhcnNlcn0gZnJvbSAnLi9NT0JJUGFyc2VyJztcblxuLy8gQ2hhcHRlciBjb250ZW50IHNlcnZpY2VcbmV4cG9ydCB7Q2hhcHRlckNvbnRlbnRTZXJ2aWNlLCBjaGFwdGVyQ29udGVudFNlcnZpY2V9IGZyb20gJy4vQ2hhcHRlckNvbnRlbnRTZXJ2aWNlJztcbmV4cG9ydCB0eXBlIHtDaGFwdGVyU3R5bGVzLCBQcm9jZXNzZWRDaGFwdGVyQ29udGVudH0gZnJvbSAnLi9DaGFwdGVyQ29udGVudFNlcnZpY2UnO1xuXG4vLyBUZXh0IHByb2Nlc3Npbmcgc2VydmljZSAodG9rZW5pemF0aW9uLCB3b3JkIHJlcGxhY2VtZW50KVxuZXhwb3J0IHtUZXh0UHJvY2Vzc2luZ1NlcnZpY2UsIHRleHRQcm9jZXNzaW5nU2VydmljZX0gZnJvbSAnLi9UZXh0UHJvY2Vzc2luZ1NlcnZpY2UnO1xuZXhwb3J0IHR5cGUge1xuICBQcm9jZXNzaW5nT3B0aW9ucyxcbiAgUHJvY2Vzc2VkQ29udGVudCxcbiAgUHJvY2Vzc2luZ1N0YXRzLFxuICBFeHRyYWN0ZWRDb250ZW50LFxufSBmcm9tICcuL1RleHRQcm9jZXNzaW5nU2VydmljZSc7XG5cbi8vIExvdy1sZXZlbCB1dGlsaXRpZXNcbmV4cG9ydCB7RVBVQkV4dHJhY3Rvcn0gZnJvbSAnLi9FUFVCRXh0cmFjdG9yJztcbmV4cG9ydCB0eXBlIHtcbiAgRVBVQkNvbnRhaW5lcixcbiAgRVBVQk1hbmlmZXN0SXRlbSxcbiAgRVBVQlNwaW5lSXRlbSxcbiAgRVBVQlBhY2thZ2UsXG4gIEVQVUJSYXdNZXRhZGF0YSxcbn0gZnJvbSAnLi9FUFVCRXh0cmFjdG9yJztcblxuLy8gVE9DIHBhcnNpbmdcbmV4cG9ydCB7cGFyc2VOQ1gsIHBhcnNlTkFWLCBmbGF0dGVuVE9DLCBjb3VudFRPQ0l0ZW1zLCBmaW5kVE9DSXRlbUJ5SHJlZn0gZnJvbSAnLi9UT0NQYXJzZXInO1xuZXhwb3J0IHR5cGUge1RPQ1BhcnNlUmVzdWx0LCBQYWdlTGlzdEl0ZW19IGZyb20gJy4vVE9DUGFyc2VyJztcblxuLy8gTWV0YWRhdGEgZXh0cmFjdGlvblxuZXhwb3J0IHtcbiAgTWV0YWRhdGFFeHRyYWN0b3IsXG4gIGV4dHJhY3RFUFVCTWV0YWRhdGEsXG4gIGV4dHJhY3RFUFVCSW5mbyxcbiAgZXh0cmFjdEVQVUJDb3Zlcixcbn0gZnJvbSAnLi9NZXRhZGF0YUV4dHJhY3Rvcic7XG5leHBvcnQgdHlwZSB7RXh0cmFjdGVkTWV0YWRhdGEsIENvdmVyRXh0cmFjdGlvblJlc3VsdH0gZnJvbSAnLi9NZXRhZGF0YUV4dHJhY3Rvcic7XG5cbi8vIFR5cGVzXG5leHBvcnQgdHlwZSB7SUJvb2tQYXJzZXIsIFNlYXJjaFJlc3VsdCwgUGFyc2VyT3B0aW9uc30gZnJvbSAnLi90eXBlcyc7XG4iXSwibmFtZXMiOlsiU0tJUF9UQUdTIiwiU2V0IiwiQ09OVFJBQ1RJT05TIiwiTkFNRV9QUkVGSVhFUyIsIkFCQlJFVklBVElPTlMiLCJUb2tlbml6ZXIiLCJfb3B0aW9ucyRza2lwUXVvdGVzIiwiX29wdGlvbnMkc2tpcE5hbWVzIiwiX29wdGlvbnMkc2tpcENvZGUiLCJfb3B0aW9ucyRtaW5Xb3JkTGVuZ3QiLCJfb3B0aW9ucyRtYXhXb3JkTGVuZ3QiLCJfb3B0aW9ucyRza2lwV29yZHMiLCJvcHRpb25zIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiX2NsYXNzQ2FsbENoZWNrIiwic2tpcFF1b3RlcyIsInNraXBOYW1lcyIsInNraXBDb2RlIiwibWluV29yZExlbmd0aCIsIm1heFdvcmRMZW5ndGgiLCJza2lwV29yZHMiLCJfY3JlYXRlQ2xhc3MiLCJrZXkiLCJ2YWx1ZSIsInRva2VuaXplIiwiaHRtbCIsInNlZ21lbnRzIiwiZXh0cmFjdFRleHRTZWdtZW50cyIsInRva2VucyIsIl9pdGVyYXRvciIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIiwiX3N0ZXAiLCJzIiwibiIsImRvbmUiLCJzZWdtZW50IiwiaXNQcm90ZWN0ZWQiLCJzaG91bGRTa2lwUHJvdGVjdGVkIiwicHJvdGVjdGlvblR5cGUiLCJzZWdtZW50VG9rZW5zIiwidG9rZW5pemVTZWdtZW50IiwicHVzaCIsImFwcGx5IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiZXJyIiwiZSIsImYiLCJjdXJyZW50SW5kZXgiLCJpbnNpZGVTa2lwVGFnIiwic2tpcFRhZ05hbWUiLCJxdW90ZURlcHRoIiwidGFnUmVnZXgiLCJtYXRjaCIsImV4ZWMiLCJ0YWdTdGFydCIsImluZGV4IiwidGFnRW5kIiwidGFnTmFtZSIsInRvTG93ZXJDYXNlIiwiaXNDbG9zaW5nIiwic3RhcnRzV2l0aCIsInRleHQiLCJzdWJzdHJpbmciLCJ0cmltIiwic3RhcnRJbmRleCIsImVuZEluZGV4IiwiaGFzIiwid29yZFBhdHRlcm4iLCJpblF1b3RlIiwibGFzdFF1b3RlQ2hhciIsIl9tYXRjaCIsIl9tYXRjaDIiLCJfc2xpY2VkVG9BcnJheSIsInByZWZpeCIsIndvcmQiLCJzdWZmaXgiLCJzdGFydEluU2VnbWVudCIsImVuZEluU2VnbWVudCIsIl9pdGVyYXRvcjIiLCJfc3RlcDIiLCJjaGFyIiwiaXNNYXRjaGluZ1F1b3RlIiwibG9va3NMaWtlTmFtZSIsIm5vcm1hbGl6ZWQiLCJyZXBsYWNlIiwib3JpZ2luYWwiLCJfaXRlcmF0b3IzIiwiX3N0ZXAzIiwiZnVsbFRleHQiLCJwb3NpdGlvbkluVGV4dCIsInRlc3QiLCJ0cmltbWVkUHJlZml4IiwidHJpbUVuZCIsImVuZHNXaXRoIiwidG9VcHBlckNhc2UiLCJzbGljZSIsInByZXZXb3JkIiwiZ2V0UHJldmlvdXNXb3JkIiwicG9zaXRpb24iLCJiZWZvcmUiLCJvcGVuIiwiY2xvc2UiLCJwYWlycyIsInR5cGUiLCJ1cGRhdGVPcHRpb25zIiwiX29iamVjdFNwcmVhZCIsImdldFVuaXF1ZVdvcmRzIiwid29yZHMiLCJfaXRlcmF0b3I0IiwiX3N0ZXA0IiwidG9rZW4iLCJhZGQiLCJBcnJheSIsImZyb20iLCJ0b2tlbml6ZXIiLCJQUk9GSUNJRU5DWV9PUkRFUiIsIldvcmRSZXBsYWNlciIsIl9vcHRpb25zJGRlbnNpdHkiLCJfb3B0aW9ucyRtYXhQcm9maWNpZW4iLCJfb3B0aW9ucyRwcmVmZXJyZWRQYXIiLCJfb3B0aW9ucyRleGNsdWRlV29yZHMiLCJfb3B0aW9ucyRtaW5Xb3JkU3BhY2kiLCJfb3B0aW9ucyRzZWxlY3Rpb25TdHIiLCJkZW5zaXR5IiwibWF4UHJvZmljaWVuY3kiLCJwcmVmZXJyZWRQYXJ0c09mU3BlZWNoIiwiZXhjbHVkZVdvcmRzIiwibWluV29yZFNwYWNpbmciLCJzZWxlY3Rpb25TdHJhdGVneSIsIndvcmRFbnRyaWVzIiwiY2FuZGlkYXRlcyIsImJ1aWxkQ2FuZGlkYXRlcyIsInNlbGVjdGVkIiwic2VsZWN0UmVwbGFjZW1lbnRzIiwic29ydCIsImEiLCJiIiwibW9kaWZpZWRIdG1sIiwiZm9yZWlnbldvcmRzIiwib2Zmc2V0IiwiY2FuZGlkYXRlIiwiZW50cnkiLCJmb3JlaWduV29yZCIsInByZXNlcnZlQ2FzZSIsInRhcmdldFdvcmQiLCJtYXJrZXIiLCJjcmVhdGVNYXJrZXIiLCJzdGFydCIsImVuZCIsIm9yaWdpbmFsV29yZCIsIndvcmRFbnRyeSIsInJldmVyc2UiLCJzdGF0cyIsInRvdGFsVG9rZW5zIiwiZWxpZ2libGVUb2tlbnMiLCJyZXBsYWNlZFRva2VucyIsInByb3RlY3RlZFRva2VucyIsImZpbHRlciIsInQiLCJkZW5zaXR5U2tpcHBlZCIsImdldCIsImlzV2l0aGluUHJvZmljaWVuY3kiLCJwcm9maWNpZW5jeUxldmVsIiwic2NvcmUiLCJjYWxjdWxhdGVTY29yZSIsInRhcmdldENvdW50IiwiTWF0aCIsIm1heCIsImZsb29yIiwic2VsZWN0QnlGcmVxdWVuY3kiLCJzZWxlY3REaXN0cmlidXRlZCIsInNlbGVjdFJhbmRvbSIsInNodWZmbGVkIiwicmFuZG9tIiwiYXBwbHlTcGFjaW5nQ29uc3RyYWludCIsInNvcnRlZCIsImZyZXF1ZW5jeVJhbmsiLCJzdGVwIiwiaSIsIm1heENvdW50IiwibGFzdFBvc2l0aW9uIiwiSW5maW5pdHkiLCJ3b3Jkc0JldHdlZW4iLCJtaW4iLCJpbmNsdWRlcyIsInBhcnRPZlNwZWVjaCIsImxldmVsIiwibWF4SW5kZXgiLCJpbmRleE9mIiwibGV2ZWxJbmRleCIsInJlcGxhY2VtZW50IiwiYXR0cnMiLCJjb25jYXQiLCJlc2NhcGVIdG1sIiwic291cmNlV29yZCIsImlkIiwicHJvbnVuY2lhdGlvbiIsImpvaW4iLCJnZXRPcHRpb25zIiwiY3JlYXRlV29yZFJlcGxhY2VyIiwiRGF0YWJhc2VTY2hlbWEiLCJjcmVhdGVUYWJsZXMiLCJib29rcyIsImluc2VydCIsInVwZGF0ZSIsImRlbGV0ZSIsImdldEJ5SWQiLCJnZXRBbGwiLCJzZWFyY2giLCJ2b2NhYnVsYXJ5IiwiZ2V0QnlTdGF0dXMiLCJnZXRCeUJvb2siLCJnZXREdWVGb3JSZXZpZXciLCJzZXNzaW9ucyIsImdldFJlY2VudCIsImdldFN0YXRzIiwicHJlZmVyZW5jZXMiLCJzZXQiLCJ3b3JkTGlzdCIsImdldEJ5V29yZCIsImdldEJ5TGV2ZWwiLCJjb3VudCIsIkFzeW5jU3RvcmFnZSIsIkZSRVFVRU5DWV9MSVNUX1NPVVJDRVMiLCJlbiIsImVzIiwiZnIiLCJkZSIsIml0IiwicHQiLCJydSIsImVsIiwiamEiLCJ6aCIsImtvIiwiYXIiLCJTVE9SQUdFX1BSRUZJWCIsIk1BWF9XT1JEU19UT19TVE9SRSIsIlBST0ZJQ0lFTkNZX1RIUkVTSE9MRFMiLCJiZWdpbm5lciIsImludGVybWVkaWF0ZSIsImFkdmFuY2VkIiwiRnJlcXVlbmN5TGlzdFNlcnZpY2UiLCJfZGVmaW5lUHJvcGVydHkiLCJNYXAiLCJfZ2V0RnJlcXVlbmN5TGlzdCIsIl9hc3luY1RvR2VuZXJhdG9yIiwiX3JlZ2VuZXJhdG9yUnVudGltZSIsIm1hcmsiLCJfY2FsbGVlIiwibGFuZ3VhZ2UiLCJzdG9yZWQiLCJmZXRjaGVkIiwid3JhcCIsIl9jb250ZXh0IiwicHJldiIsIm5leHQiLCJjYWNoZSIsImFicnVwdCIsImxvYWRGcm9tU3RvcmFnZSIsInNlbnQiLCJmZXRjaEZyZXF1ZW5jeUxpc3QiLCJzYXZlVG9TdG9yYWdlIiwic3RvcCIsImdldEZyZXF1ZW5jeUxpc3QiLCJfeCIsIl9nZXRXb3Jkc0J5UHJvZmljaWVuY3kiLCJfY2FsbGVlMiIsImxpc3QiLCJfUFJPRklDSUVOQ1lfVEhSRVNIT0wiLCJfY29udGV4dDIiLCJ3IiwicmFuayIsImdldFdvcmRzQnlQcm9maWNpZW5jeSIsIl94MiIsIl94MyIsImdldFByb2ZpY2llbmN5TGV2ZWwiLCJfZ2V0V29yZFJhbmsiLCJfY2FsbGVlMyIsIm5vcm1hbGl6ZWRXb3JkIiwiZm91bmQiLCJfY29udGV4dDMiLCJmaW5kIiwiZ2V0V29yZFJhbmsiLCJfeDQiLCJfeDUiLCJfZ2V0U3RhdHMiLCJfY2FsbGVlNCIsIl90IiwiX3QyIiwiX2NvbnRleHQ0IiwiZmluaXNoIiwidG90YWxXb3JkcyIsIndvcmRDb3VudCIsInNvdXJjZSIsIl94NiIsIl9oYXNGcmVxdWVuY3lMaXN0IiwiX2NhbGxlZTUiLCJfY29udGV4dDUiLCJoYXNGcmVxdWVuY3lMaXN0IiwiX3g3IiwiZ2V0QXZhaWxhYmxlTGFuZ3VhZ2VzIiwiT2JqZWN0IiwiZW50cmllcyIsIl9yZWYiLCJfcmVmMiIsInVybCIsIm1hcCIsIl9yZWYzIiwiX3JlZjQiLCJsYW5nIiwiX3JlZnJlc2hGcmVxdWVuY3lMaXN0IiwiX2NhbGxlZTYiLCJfY29udGV4dDYiLCJyZWZyZXNoRnJlcXVlbmN5TGlzdCIsIl94OCIsIl9jbGVhckNhY2hlIiwiX2NhbGxlZTciLCJrZXlzIiwiZnJlcXVlbmN5S2V5cyIsIl9jb250ZXh0NyIsInJlbW92ZUl0ZW0iLCJjbGVhciIsImdldEFsbEtleXMiLCJrIiwibXVsdGlSZW1vdmUiLCJjbGVhckNhY2hlIiwiX3g5IiwiX2ZldGNoRnJlcXVlbmN5TGlzdCIsIl9jYWxsZWU4IiwicmVzcG9uc2UiLCJfdDMiLCJfY29udGV4dDgiLCJjb25zb2xlIiwibG9nIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzIiwicGFyc2VGcmVxdWVuY3lUZXh0IiwibGFzdFVwZGF0ZWQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJlcnJvciIsIl94MCIsIl9sYW5ndWFnZSIsImxpbmVzIiwic3BsaXQiLCJsaW5lIiwicGFydHMiLCJmcmVxdWVuY3kiLCJwYXJzZUludCIsIl9sb2FkRnJvbVN0b3JhZ2UiLCJfY2FsbGVlOSIsIl90NCIsIl9jb250ZXh0OSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJ3YXJuIiwiX3gxIiwiX3NhdmVUb1N0b3JhZ2UiLCJfY2FsbGVlMCIsIl90NSIsIl9jb250ZXh0MCIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJfeDEwIiwiX3gxMSIsImZyZXF1ZW5jeUxpc3RTZXJ2aWNlIiwiREVGQVVMVF9QUk9WSURFUlMiLCJwcm92aWRlciIsImJhc2VVcmwiLCJyYXRlTGltaXQiLCJlbmFibGVkIiwiTElCUkVUUkFOU0xBVEVfTUlSUk9SUyIsIkxBTkdVQUdFX0NPREVTIiwiaXNvNjM5XzEiLCJuYW1lIiwiQ0FDSEVfUFJFRklYIiwiUkFURV9MSU1JVF9QUkVGSVgiLCJUcmFuc2xhdGlvbkFQSVNlcnZpY2UiLCJjdXN0b21Qcm92aWRlcnMiLCJwcm92aWRlcnMiLCJfdHJhbnNsYXRlIiwic291cmNlTGFuZ3VhZ2UiLCJ0YXJnZXRMYW5ndWFnZSIsImNhY2hlS2V5IiwiY2FjaGVkIiwicmVzdWx0IiwiZ2V0Q2FjaGVLZXkiLCJnZXRGcm9tQ2FjaGUiLCJpc1JhdGVMaW1pdGVkIiwidHJhbnNsYXRlV2l0aFByb3ZpZGVyIiwic2F2ZVRvQ2FjaGUiLCJpbmNyZW1lbnRSYXRlTGltaXQiLCJ0cmFuc2xhdGUiLCJfdHJhbnNsYXRlQnVsayIsInRyYW5zbGF0aW9ucyIsImZhaWxlZCIsInRvVHJhbnNsYXRlIiwiX3dvcmQiLCJiYXRjaFNpemUiLCJ1c2VkUHJvdmlkZXIiLCJiYXRjaCIsInRyYW5zbGF0ZWRUZXh0IiwiZGVsYXkiLCJ0cmFuc2xhdGVCdWxrIiwiX2dldFN1cHBvcnRlZExhbmd1YWdlcyIsInRhcmdldFByb3ZpZGVyIiwiX3Q2IiwiX3Q3IiwiZ2V0TGlicmVUcmFuc2xhdGVMYW5ndWFnZXMiLCJnZXRMaW5ndmFMYW5ndWFnZXMiLCJnZXRTdXBwb3J0ZWRMYW5ndWFnZXMiLCJfaXNMYW5ndWFnZVBhaXJTdXBwb3J0ZWQiLCJzdXBwb3J0ZWQiLCJpc0xhbmd1YWdlUGFpclN1cHBvcnRlZCIsIl90cmFuc2xhdGVXaXRoUHJvdmlkZXIiLCJjb25maWciLCJfdDgiLCJ0cmFuc2xhdGVXaXRoTGlicmVUcmFuc2xhdGUiLCJ0cmFuc2xhdGVXaXRoTXlNZW1vcnkiLCJ0cmFuc2xhdGVXaXRoTGluZ3ZhIiwiX3RyYW5zbGF0ZVdpdGhMaWJyZVRyYW5zbGF0ZSIsImRhdGEiLCJnZXRMaWJyZVRyYW5zbGF0ZU1pcnJvciIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwicSIsInRhcmdldCIsImZvcm1hdCIsImFwaV9rZXkiLCJhcGlLZXkiLCJjdXJyZW50TWlycm9ySW5kZXgiLCJqc29uIiwiX3gxMiIsIl94MTMiLCJfeDE0IiwiX3gxNSIsIl90cmFuc2xhdGVXaXRoTXlNZW1vcnkiLCJsYW5nUGFpciIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlc3BvbnNlU3RhdHVzIiwicmVzcG9uc2VEZXRhaWxzIiwicmVzcG9uc2VEYXRhIiwiY29uZmlkZW5jZSIsIl94MTYiLCJfeDE3IiwiX3gxOCIsIl94MTkiLCJfdHJhbnNsYXRlV2l0aExpbmd2YSIsInRyYW5zbGF0aW9uIiwiX3gyMCIsIl94MjEiLCJfeDIyIiwiX3gyMyIsIl9nZXRMaWJyZVRyYW5zbGF0ZUxhbmd1YWdlcyIsIl9sb29wIiwiX3Q5IiwiX3QwIiwidiIsImNvZGUiLCJkZWxlZ2F0ZVlpZWxkIiwiX2dldExpbmd2YUxhbmd1YWdlcyIsIl9pdGVyYXRvcjUiLCJfc3RlcDUiLCJfbG9vcDIiLCJfdDEiLCJfdDEwIiwiX2NvbnRleHQxMCIsImxhbmd1YWdlcyIsIl9jb250ZXh0MSIsImRlZmF1bHRVcmwiLCJfZ2V0RnJvbUNhY2hlIiwiX2NhbGxlZTEiLCJfdDExIiwiX2NvbnRleHQxMSIsIl94MjQiLCJfc2F2ZVRvQ2FjaGUiLCJfY2FsbGVlMTAiLCJmaXJzdEtleSIsIl90MTIiLCJfY29udGV4dDEyIiwic2l6ZSIsIl94MjUiLCJfeDI2IiwiX2NhbGxlZTExIiwiY2FjaGVLZXlzIiwiX3QxMyIsIl9jb250ZXh0MTMiLCJfZ2V0Q2FjaGVTdGF0cyIsIl9jYWxsZWUxMiIsInBlcnNpc3RlbnRTaXplIiwiX3QxNCIsIl9jb250ZXh0MTQiLCJtZW1vcnlTaXplIiwiZ2V0Q2FjaGVTdGF0cyIsImNvdW50ZXIiLCJyYXRlTGltaXRDb3VudGVycyIsIm5vdyIsInJlc2V0VGltZSIsInAiLCJtcyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInNldFByb3ZpZGVyRW5hYmxlZCIsInNldEFwaUtleSIsImdldExhbmd1YWdlTmFtZSIsIl9MQU5HVUFHRV9DT0RFUyRjb2RlIiwiZ2V0QWxsTGFuZ3VhZ2VzIiwiX3JlZjUiLCJfcmVmNiIsInRyYW5zbGF0aW9uQVBJIiwiZGF0YWJhc2VTZXJ2aWNlIiwiRHluYW1pY1dvcmREYXRhYmFzZSIsImRiIiwiZnJlcXVlbmN5U2VydmljZSIsIl9pbml0aWFsaXplIiwiaW5pdGlhbGl6ZWQiLCJpbml0aWFsaXplIiwiX2xvb2t1cFdvcmQiLCJkYkVudHJ5IiwidHJhbnNsYXRlZCIsIm1lbW9yeUNhY2hlIiwibG9va3VwRnJvbURhdGFiYXNlIiwidHJhbnNsYXRlQW5kQ2FjaGUiLCJsb29rdXBXb3JkIiwiX2xvb2t1cFdvcmRzIiwicmVzdWx0cyIsIl93b3JkMiIsImJ1bGtSZXN1bHQiLCJfc3RlcDIkdmFsdWUiLCJjcmVhdGVBbmRDYWNoZUVudHJ5IiwibG9va3VwV29yZHMiLCJsaW1pdCIsImZyZXF1ZW5jeVdvcmRzIiwiZnJlcVdvcmQiLCJfYXJnczQiLCJnZXRDYWNoZWRXb3Jkc0J5TGV2ZWwiLCJfZ2V0UmFuZG9tV29yZHMiLCJnZXRSYW5kb21Xb3JkcyIsInRvdGFsUmVzdWx0IiwicGFpcnNSZXN1bHQiLCJsYW5ndWFnZVBhaXJzIiwiZ2V0T25lIiwicm93Iiwic291cmNlX2xhbmciLCJ0YXJnZXRfbGFuZyIsInRvdGFsQ2FjaGVkV29yZHMiLCJleGVjdXRlIiwiX3ByZUNhY2hlQ29tbW9uV29yZHMiLCJfaXRlcmF0b3I2IiwiX3N0ZXA2IiwiX2FyZ3M5IiwidmFsdWVzIiwicHJlQ2FjaGVDb21tb25Xb3JkcyIsIl9sb29rdXBGcm9tRGF0YWJhc2UiLCJyb3dUb0VudHJ5IiwiX3RyYW5zbGF0ZUFuZENhY2hlIiwiX2NyZWF0ZUFuZENhY2hlRW50cnkiLCJ2YXJpYW50cyIsImlzVHJhbnNsYXRlZCIsInRyYW5zbGF0aW9uUHJvdmlkZXIiLCJjYWNoZWRBdCIsIm1lc3NhZ2UiLCJfeDI3IiwiX3gyOCIsIl9nZXRDYWNoZWRXb3Jkc0J5TGV2ZWwiLCJfdGhpcyIsInJvd3MiLCJfeDI5IiwiX3gzMCIsIl94MzEiLCJfeDMyIiwic291cmNlX3dvcmQiLCJ0YXJnZXRfd29yZCIsInByb2ZpY2llbmN5IiwiZnJlcXVlbmN5X3JhbmsiLCJwYXJ0X29mX3NwZWVjaCIsImR5bmFtaWNXb3JkRGF0YWJhc2UiLCJUZXh0UHJvY2Vzc2luZ1NlcnZpY2UiLCJ3b3JkUmVwbGFjZXIiLCJfcHJvY2Vzc0NoYXB0ZXIiLCJjaGFwdGVyIiwic3RhcnRUaW1lIiwiZXh0cmFjdGVkIiwidW5pcXVlV29yZHMiLCJfeWllbGQkdGhpcyRsb29rdXBXb3IiLCJsb29rdXBzIiwiaGl0cyIsInByb2Nlc3NpbmdUaW1lTXMiLCJleHRyYWN0Q29udGVudCIsImNvbnRlbnQiLCJ1bmlxdWVXb3JkQ291bnQiLCJkYXRhYmFzZUxvb2t1cHMiLCJkYXRhYmFzZUhpdHMiLCJwcm9jZXNzQ2hhcHRlciIsInN0eWxlcyIsInRpdGxlTWF0Y2giLCJ0aXRsZSIsImRlY29kZUh0bWxFbnRpdGllcyIsImxhbmdNYXRjaCIsInN0eWxlUmVnZXgiLCJzdHlsZU1hdGNoIiwibGlua1JlZ2V4IiwiYm9keU1hdGNoIiwiYWZ0ZXJIZWFkTWF0Y2giLCJjbGVhbkJvZHlDb250ZW50IiwiZW50aXRpZXMiLCJkZWNvZGVkIiwiX2kiLCJfT2JqZWN0JGVudHJpZXMiLCJfT2JqZWN0JGVudHJpZXMkX2kiLCJlbnRpdHkiLCJSZWdFeHAiLCJfIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwid29yZENhY2hlIiwiZ2V0V29yZEF0UG9zaXRpb24iLCJnZXRXb3Jkc0luUmFuZ2UiLCJnZXRXb3JkQ29udGV4dCIsImNvbnRleHRMZW5ndGgiLCJwbGFpblRleHQiLCJzdHJpcEh0bWwiLCJ3b3JkUG9zIiwiY29udGV4dCIsInNlbnRlbmNlU3RhcnQiLCJsYXN0SW5kZXhPZiIsInNlbnRlbmNlRW5kIiwibWVtb3J5RXN0aW1hdGUiLCJ0ZXh0UHJvY2Vzc2luZ1NlcnZpY2UiLCJSTkZTIiwiRVBVQkV4dHJhY3RvciIsInBhcnNlTkNYIiwicGFyc2VOQVYiLCJNZXRhZGF0YUV4dHJhY3RvciIsImV4dHJhY3RvciIsIl9leHRyYWN0RnJvbUZpbGUiLCJmaWxlUGF0aCIsImNvbnRhaW5lciIsInRvY1Jlc3VsdCIsIm1ldGFkYXRhIiwiY2hhcHRlckNvdW50IiwibG9hZCIsInBhcnNlQ29udGFpbmVyIiwicGFyc2VQYWNrYWdlIiwicm9vdEZpbGVQYXRoIiwiZXB1YlBhY2thZ2UiLCJleHRyYWN0VGFibGVPZkNvbnRlbnRzIiwiYXV0aG9yIiwiY3JlYXRvciIsImRlc2NyaXB0aW9uIiwicHVibGlzaGVyIiwicHVibGlzaERhdGUiLCJkYXRlIiwiaXNibiIsImV4dHJhY3RJU0JOIiwiaWRlbnRpZmllciIsInN1YmplY3RzIiwic3ViamVjdCIsInNwaW5lIiwiaXRlbSIsImxpbmVhciIsInRhYmxlT2ZDb250ZW50cyIsIml0ZW1zIiwiZXB1YlZlcnNpb24iLCJ2ZXJzaW9uIiwiZXh0cmFjdEZyb21GaWxlIiwiX2V4dHJhY3RDb3ZlciIsIm91dHB1dERpciIsImNvdmVySWQiLCJjb3Zlckl0ZW0iLCJiYXNlNjREYXRhIiwiZXh0ZW5zaW9uIiwiZmlsZU5hbWUiLCJvdXRwdXRQYXRoIiwiY292ZXJJbWFnZUlkIiwibWFuaWZlc3QiLCJnZXRCYXNlNjRGaWxlIiwiaHJlZiIsImdldEltYWdlRXh0ZW5zaW9uIiwibWVkaWFUeXBlIiwibWtkaXIiLCJ3cml0ZUZpbGUiLCJleHRyYWN0Q292ZXIiLCJfZ2V0Q292ZXJCYXNlIiwibWltZVR5cGUiLCJnZXRDb3ZlckJhc2U2NCIsIl9leHRyYWN0VGFibGVPZkNvbnRlbnRzIiwidG9jSWQiLCJ0b2NJdGVtIiwidG9jQ29udGVudCIsImdlbmVyYXRlVE9DRnJvbVNwaW5lIiwiZ2V0RmlsZSIsImZvckVhY2giLCJzcGluZUl0ZW0iLCJtYW5pZmVzdEl0ZW0iLCJpZHJlZiIsImdldFNwaW5lSXRlbXMiLCJfZ2V0Q2hhcHRlckNvbnRlbnQiLCJnZXRDaGFwdGVyQ29udGVudCIsImlzYm4xM01hdGNoIiwiaXNibjEwTWF0Y2giLCJ1cm5NYXRjaCIsIm1pbWVUb0V4dCIsImRpc3Bvc2UiLCJleHRyYWN0RVBVQk1ldGFkYXRhIiwiX2V4dHJhY3RFUFVCTWV0YWRhdGEiLCJleHRyYWN0RVBVQkluZm8iLCJfZXh0cmFjdEVQVUJJbmZvIiwiZXh0cmFjdEVQVUJDb3ZlciIsIl9leHRyYWN0RVBVQkNvdmVyIiwiQm9va1BhcnNlclNlcnZpY2UiLCJFUFVCUGFyc2VyIiwiVFhUUGFyc2VyIiwiRkIyUGFyc2VyIiwiTU9CSVBhcnNlciIsIkNoYXB0ZXJDb250ZW50U2VydmljZSIsImNoYXB0ZXJDb250ZW50U2VydmljZSIsImZsYXR0ZW5UT0MiLCJjb3VudFRPQ0l0ZW1zIiwiZmluZFRPQ0l0ZW1CeUhyZWYiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4300\n\n}')},5057(module,__unused_webpack_exports,__webpack_require__){eval("{\nconst isOptionObject = __webpack_require__(1103);\n\nconst {hasOwnProperty} = Object.prototype;\nconst {propertyIsEnumerable} = Object;\nconst defineProperty = (object, name, value) => Object.defineProperty(object, name, {\n\tvalue,\n\twritable: true,\n\tenumerable: true,\n\tconfigurable: true\n});\n\nconst globalThis = this;\nconst defaultMergeOptions = {\n\tconcatArrays: false,\n\tignoreUndefined: false\n};\n\nconst getEnumerableOwnPropertyKeys = value => {\n\tconst keys = [];\n\n\tfor (const key in value) {\n\t\tif (hasOwnProperty.call(value, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\n\t/* istanbul ignore else  */\n\tif (Object.getOwnPropertySymbols) {\n\t\tconst symbols = Object.getOwnPropertySymbols(value);\n\n\t\tfor (const symbol of symbols) {\n\t\t\tif (propertyIsEnumerable.call(value, symbol)) {\n\t\t\t\tkeys.push(symbol);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn keys;\n};\n\nfunction clone(value) {\n\tif (Array.isArray(value)) {\n\t\treturn cloneArray(value);\n\t}\n\n\tif (isOptionObject(value)) {\n\t\treturn cloneOptionObject(value);\n\t}\n\n\treturn value;\n}\n\nfunction cloneArray(array) {\n\tconst result = array.slice(0, 0);\n\n\tgetEnumerableOwnPropertyKeys(array).forEach(key => {\n\t\tdefineProperty(result, key, clone(array[key]));\n\t});\n\n\treturn result;\n}\n\nfunction cloneOptionObject(object) {\n\tconst result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};\n\n\tgetEnumerableOwnPropertyKeys(object).forEach(key => {\n\t\tdefineProperty(result, key, clone(object[key]));\n\t});\n\n\treturn result;\n}\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {string[]} keys keys to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nconst mergeKeys = (merged, source, keys, config) => {\n\tkeys.forEach(key => {\n\t\tif (typeof source[key] === 'undefined' && config.ignoreUndefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not recurse into prototype chain of merged\n\t\tif (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\n\t\t\tdefineProperty(merged, key, merge(merged[key], source[key], config));\n\t\t} else {\n\t\t\tdefineProperty(merged, key, clone(source[key]));\n\t\t}\n\t});\n\n\treturn merged;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n *\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\n */\nconst concatArrays = (merged, source, config) => {\n\tlet result = merged.slice(0, 0);\n\tlet resultIndex = 0;\n\n\t[merged, source].forEach(array => {\n\t\tconst indices = [];\n\n\t\t// `result.concat(array)` with cloning\n\t\tfor (let k = 0; k < array.length; k++) {\n\t\t\tif (!hasOwnProperty.call(array, k)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tindices.push(String(k));\n\n\t\t\tif (array === merged) {\n\t\t\t\t// Already cloned\n\t\t\t\tdefineProperty(result, resultIndex++, array[k]);\n\t\t\t} else {\n\t\t\t\tdefineProperty(result, resultIndex++, clone(array[k]));\n\t\t\t}\n\t\t}\n\n\t\t// Merge non-index keys\n\t\tresult = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);\n\t});\n\n\treturn result;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nfunction merge(merged, source, config) {\n\tif (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\n\t\treturn concatArrays(merged, source, config);\n\t}\n\n\tif (!isOptionObject(source) || !isOptionObject(merged)) {\n\t\treturn clone(source);\n\t}\n\n\treturn mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);\n}\n\nmodule.exports = function (...options) {\n\tconst config = merge(clone(defaultMergeOptions), (this !== globalThis && this) || {}, defaultMergeOptions);\n\tlet merged = {_: {}};\n\n\tfor (const option of options) {\n\t\tif (option === undefined) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!isOptionObject(option)) {\n\t\t\tthrow new TypeError('`' + option + '` is not an Option Object');\n\t\t}\n\n\t\tmerged = merge(merged, {_: option}, config);\n\t}\n\n\treturn merged._;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTA1Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHVCQUF1QixtQkFBTyxDQUFDLElBQWM7O0FBRTdDLE9BQU8sZ0JBQWdCO0FBQ3ZCLE9BQU8sc0JBQXNCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFGQUFxRjtBQUNyRixlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsVUFBVTtBQUNwQzs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veGVub2xleGlhLWRlc2t0b3AvLi4vLi4vbm9kZV9tb2R1bGVzL21lcmdlLW9wdGlvbnMvaW5kZXguanM/MjE4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBpc09wdGlvbk9iamVjdCA9IHJlcXVpcmUoJ2lzLXBsYWluLW9iaicpO1xuXG5jb25zdCB7aGFzT3duUHJvcGVydHl9ID0gT2JqZWN0LnByb3RvdHlwZTtcbmNvbnN0IHtwcm9wZXJ0eUlzRW51bWVyYWJsZX0gPSBPYmplY3Q7XG5jb25zdCBkZWZpbmVQcm9wZXJ0eSA9IChvYmplY3QsIG5hbWUsIHZhbHVlKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG5cdHZhbHVlLFxuXHR3cml0YWJsZTogdHJ1ZSxcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Y29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuY29uc3QgZ2xvYmFsVGhpcyA9IHRoaXM7XG5jb25zdCBkZWZhdWx0TWVyZ2VPcHRpb25zID0ge1xuXHRjb25jYXRBcnJheXM6IGZhbHNlLFxuXHRpZ25vcmVVbmRlZmluZWQ6IGZhbHNlXG59O1xuXG5jb25zdCBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzID0gdmFsdWUgPT4ge1xuXHRjb25zdCBrZXlzID0gW107XG5cblx0Zm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcblx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuXHRcdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0fVxuXHR9XG5cblx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG5cdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0Y29uc3Qgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpO1xuXG5cdFx0Zm9yIChjb25zdCBzeW1ib2wgb2Ygc3ltYm9scykge1xuXHRcdFx0aWYgKHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsIHN5bWJvbCkpIHtcblx0XHRcdFx0a2V5cy5wdXNoKHN5bWJvbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGtleXM7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuXHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gY2xvbmVBcnJheSh2YWx1ZSk7XG5cdH1cblxuXHRpZiAoaXNPcHRpb25PYmplY3QodmFsdWUpKSB7XG5cdFx0cmV0dXJuIGNsb25lT3B0aW9uT2JqZWN0KHZhbHVlKTtcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVBcnJheShhcnJheSkge1xuXHRjb25zdCByZXN1bHQgPSBhcnJheS5zbGljZSgwLCAwKTtcblxuXHRnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzKGFycmF5KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0ZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIGNsb25lKGFycmF5W2tleV0pKTtcblx0fSk7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY2xvbmVPcHRpb25PYmplY3Qob2JqZWN0KSB7XG5cdGNvbnN0IHJlc3VsdCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuXG5cdGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMob2JqZWN0KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0ZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIGNsb25lKG9iamVjdFtrZXldKSk7XG5cdH0pO1xuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSBtZXJnZWQgYWxyZWFkeSBjbG9uZWRcbiAqIEBwYXJhbSB7Kn0gc291cmNlIHNvbWV0aGluZyB0byBtZXJnZVxuICogQHBhcmFtIHtzdHJpbmdbXX0ga2V5cyBrZXlzIHRvIG1lcmdlXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZyBPYmplY3RcbiAqIEByZXR1cm5zIHsqfSBjbG9uZWQgT2JqZWN0XG4gKi9cbmNvbnN0IG1lcmdlS2V5cyA9IChtZXJnZWQsIHNvdXJjZSwga2V5cywgY29uZmlnKSA9PiB7XG5cdGtleXMuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGlmICh0eXBlb2Ygc291cmNlW2tleV0gPT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5pZ25vcmVVbmRlZmluZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEbyBub3QgcmVjdXJzZSBpbnRvIHByb3RvdHlwZSBjaGFpbiBvZiBtZXJnZWRcblx0XHRpZiAoa2V5IGluIG1lcmdlZCAmJiBtZXJnZWRba2V5XSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1lcmdlZCkpIHtcblx0XHRcdGRlZmluZVByb3BlcnR5KG1lcmdlZCwga2V5LCBtZXJnZShtZXJnZWRba2V5XSwgc291cmNlW2tleV0sIGNvbmZpZykpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eShtZXJnZWQsIGtleSwgY2xvbmUoc291cmNlW2tleV0pKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBtZXJnZWQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gbWVyZ2VkIGFscmVhZHkgY2xvbmVkXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBzb21ldGhpbmcgdG8gbWVyZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlnIE9iamVjdFxuICogQHJldHVybnMgeyp9IGNsb25lZCBPYmplY3RcbiAqXG4gKiBzZWUgW0FycmF5LnByb3RvdHlwZS5jb25jYXQgKCAuLi5hcmd1bWVudHMgKV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWFycmF5LnByb3RvdHlwZS5jb25jYXQpXG4gKi9cbmNvbnN0IGNvbmNhdEFycmF5cyA9IChtZXJnZWQsIHNvdXJjZSwgY29uZmlnKSA9PiB7XG5cdGxldCByZXN1bHQgPSBtZXJnZWQuc2xpY2UoMCwgMCk7XG5cdGxldCByZXN1bHRJbmRleCA9IDA7XG5cblx0W21lcmdlZCwgc291cmNlXS5mb3JFYWNoKGFycmF5ID0+IHtcblx0XHRjb25zdCBpbmRpY2VzID0gW107XG5cblx0XHQvLyBgcmVzdWx0LmNvbmNhdChhcnJheSlgIHdpdGggY2xvbmluZ1xuXHRcdGZvciAobGV0IGsgPSAwOyBrIDwgYXJyYXkubGVuZ3RoOyBrKyspIHtcblx0XHRcdGlmICghaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaykpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGluZGljZXMucHVzaChTdHJpbmcoaykpO1xuXG5cdFx0XHRpZiAoYXJyYXkgPT09IG1lcmdlZCkge1xuXHRcdFx0XHQvLyBBbHJlYWR5IGNsb25lZFxuXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShyZXN1bHQsIHJlc3VsdEluZGV4KyssIGFycmF5W2tdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc3VsdCwgcmVzdWx0SW5kZXgrKywgY2xvbmUoYXJyYXlba10pKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNZXJnZSBub24taW5kZXgga2V5c1xuXHRcdHJlc3VsdCA9IG1lcmdlS2V5cyhyZXN1bHQsIGFycmF5LCBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzKGFycmF5KS5maWx0ZXIoa2V5ID0+ICFpbmRpY2VzLmluY2x1ZGVzKGtleSkpLCBjb25maWcpO1xuXHR9KTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG1lcmdlZCBhbHJlYWR5IGNsb25lZFxuICogQHBhcmFtIHsqfSBzb3VyY2Ugc29tZXRoaW5nIHRvIG1lcmdlXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZyBPYmplY3RcbiAqIEByZXR1cm5zIHsqfSBjbG9uZWQgT2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1lcmdlKG1lcmdlZCwgc291cmNlLCBjb25maWcpIHtcblx0aWYgKGNvbmZpZy5jb25jYXRBcnJheXMgJiYgQXJyYXkuaXNBcnJheShtZXJnZWQpICYmIEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuXHRcdHJldHVybiBjb25jYXRBcnJheXMobWVyZ2VkLCBzb3VyY2UsIGNvbmZpZyk7XG5cdH1cblxuXHRpZiAoIWlzT3B0aW9uT2JqZWN0KHNvdXJjZSkgfHwgIWlzT3B0aW9uT2JqZWN0KG1lcmdlZCkpIHtcblx0XHRyZXR1cm4gY2xvbmUoc291cmNlKTtcblx0fVxuXG5cdHJldHVybiBtZXJnZUtleXMobWVyZ2VkLCBzb3VyY2UsIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoc291cmNlKSwgY29uZmlnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLi4ub3B0aW9ucykge1xuXHRjb25zdCBjb25maWcgPSBtZXJnZShjbG9uZShkZWZhdWx0TWVyZ2VPcHRpb25zKSwgKHRoaXMgIT09IGdsb2JhbFRoaXMgJiYgdGhpcykgfHwge30sIGRlZmF1bHRNZXJnZU9wdGlvbnMpO1xuXHRsZXQgbWVyZ2VkID0ge186IHt9fTtcblxuXHRmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoIWlzT3B0aW9uT2JqZWN0KG9wdGlvbikpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2AnICsgb3B0aW9uICsgJ2AgaXMgbm90IGFuIE9wdGlvbiBPYmplY3QnKTtcblx0XHR9XG5cblx0XHRtZXJnZWQgPSBtZXJnZShtZXJnZWQsIHtfOiBvcHRpb259LCBjb25maWcpO1xuXHR9XG5cblx0cmV0dXJuIG1lcmdlZC5fO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5057\n\n}")}}]);